<?php

namespace Consilience\XeroAccounting\Sdk\Api;

/**
 * AccountingApi
 * PHP version 5
 *
 * @category Class
 * @package  Consilience\XeroAccounting\Sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Accounting API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: api@xero.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// PSR-18
use Psr\Http\Client\ClientInterface;
use Psr\Http\Client\RequestExceptionInterface;

// PSR-7
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\UriInterface;
use Psr\Http\Message\StreamInterface;

// PSR-17
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\UriFactoryInterface;
use Psr\Http\Message\StreamFactoryInterface;

// Guzzle
use GuzzleHttp\ClientInterface as GuzzleClientInterface;

use Consilience\XeroAccounting\Sdk\ApiException;
use Consilience\XeroAccounting\Sdk\Configuration;
use Consilience\XeroAccounting\Sdk\HeaderSelector;
use Consilience\XeroAccounting\Sdk\ObjectSerializer;

/**
 * AccountingApi Class Doc Comment
 *
 * @category Class
 * @package  Consilience\XeroAccounting\Sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AccountingApi
{
    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * FIXME: think about the client. We need a client that can handle both synchronous and
     * asynchronous requests. There is no PSR for asyn as yet, and implementations are so
     * diverse that we need to pick a specific implementaton (Guzzle, I guess). So do we
     * provide a wrapper that we can put one, the other, or both into? Even when there is a
     * PSR for promises, it will not be PSR-18, so we would still need two clients I believe.
     * The wrapper would support both interfaces for PSR-18 and whatever provides async requests.
     * We cannot do that with generator templates alone. We'll just add them to the configuration,
     * like the factories to avoid making this a blocker.
     *
     * @param ClientInterface|GuzzleClient $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->setConfig($config ?: new Configuration());
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * @param Configuration $config
     * @return $this
     */
    protected function setConfig(Configuration $config)
    {
        $this->config = $config;
        return $this;
    }

    /**
     * @param Configuration $config
     * @return $this
     */
    protected function withConfig(Configuration $config)
    {
        $clone = clone $this;
        return $clone->setConfig($config);
    }

    /**
     * Operation createAccount
     *
     * Allows you to create a new chart of accounts
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Account $account Request of type Account (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Accounts|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createAccount($account)
    {
        list($response) = $this->createAccountWithHttpInfo($account);
        return $response;
    }

    /**
     * Operation createAccountWithHttpInfo
     *
     * Allows you to create a new chart of accounts
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Account $account Request of type Account (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Accounts|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountWithHttpInfo($account)
    {
        $request = $this->createAccountRequest($account);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Accounts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Accounts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Accounts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Accounts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAccountAsync
     *
     * Allows you to create a new chart of accounts
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Account $account Request of type Account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountAsync($account)
    {
        return $this->createAccountAsyncWithHttpInfo($account)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAccountAsyncWithHttpInfo
     *
     * Allows you to create a new chart of accounts
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Account $account Request of type Account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountAsyncWithHttpInfo($account)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Accounts';
        $request = $this->createAccountRequest($account);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAccount'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Account $account Request of type Account (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createAccountRequest($account)
    {
        // verify the required parameter 'account' is set
        if ($account === null || (is_array($account) && count($account) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account when calling createAccount'
            );
        }

        $resourcePath = '/Accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($account)) {
            $_tempBody = $account;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createAccountAttachmentByFileName
     *
     * Allows you to create Attachment on Account
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createAccountAttachmentByFileName($accountID, $fileName, $body)
    {
        list($response) = $this->createAccountAttachmentByFileNameWithHttpInfo($accountID, $fileName, $body);
        return $response;
    }

    /**
     * Operation createAccountAttachmentByFileNameWithHttpInfo
     *
     * Allows you to create Attachment on Account
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountAttachmentByFileNameWithHttpInfo($accountID, $fileName, $body)
    {
        $request = $this->createAccountAttachmentByFileNameRequest($accountID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAccountAttachmentByFileNameAsync
     *
     * Allows you to create Attachment on Account
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountAttachmentByFileNameAsync($accountID, $fileName, $body)
    {
        return $this->createAccountAttachmentByFileNameAsyncWithHttpInfo($accountID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAccountAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to create Attachment on Account
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountAttachmentByFileNameAsyncWithHttpInfo($accountID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->createAccountAttachmentByFileNameRequest($accountID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAccountAttachmentByFileName'
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createAccountAttachmentByFileNameRequest($accountID, $fileName, $body)
    {
        // verify the required parameter 'accountID' is set
        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountID when calling createAccountAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling createAccountAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createAccountAttachmentByFileName'
            );
        }

        $resourcePath = '/Accounts/{AccountID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBankTransaction
     *
     * Allows you to create a spend or receive money transaction
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransactions $bankTransactions bankTransactions (required)
     * @param  bool $summarizeErrors response format that shows validation errors for each bank transaction (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\BankTransactions|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createBankTransaction($bankTransactions, $summarizeErrors = null)
    {
        list($response) = $this->createBankTransactionWithHttpInfo($bankTransactions, $summarizeErrors);
        return $response;
    }

    /**
     * Operation createBankTransactionWithHttpInfo
     *
     * Allows you to create a spend or receive money transaction
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransactions $bankTransactions (required)
     * @param  bool $summarizeErrors response format that shows validation errors for each bank transaction (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\BankTransactions|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBankTransactionWithHttpInfo($bankTransactions, $summarizeErrors = null)
    {
        $request = $this->createBankTransactionRequest($bankTransactions, $summarizeErrors);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\BankTransactions' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\BankTransactions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransactions';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\BankTransactions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBankTransactionAsync
     *
     * Allows you to create a spend or receive money transaction
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransactions $bankTransactions (required)
     * @param  bool $summarizeErrors response format that shows validation errors for each bank transaction (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBankTransactionAsync($bankTransactions, $summarizeErrors = null)
    {
        return $this->createBankTransactionAsyncWithHttpInfo($bankTransactions, $summarizeErrors)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBankTransactionAsyncWithHttpInfo
     *
     * Allows you to create a spend or receive money transaction
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransactions $bankTransactions (required)
     * @param  bool $summarizeErrors response format that shows validation errors for each bank transaction (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBankTransactionAsyncWithHttpInfo($bankTransactions, $summarizeErrors = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransactions';
        $request = $this->createBankTransactionRequest($bankTransactions, $summarizeErrors);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBankTransaction'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransactions $bankTransactions (required)
     * @param  bool $summarizeErrors response format that shows validation errors for each bank transaction (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createBankTransactionRequest($bankTransactions, $summarizeErrors = null)
    {
        // verify the required parameter 'bankTransactions' is set
        if ($bankTransactions === null || (is_array($bankTransactions) && count($bankTransactions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransactions when calling createBankTransaction'
            );
        }

        $resourcePath = '/BankTransactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($summarizeErrors !== null) {
            $queryParams['SummarizeErrors'] = ObjectSerializer::toQueryValue($summarizeErrors);
        }


        // body params
        $_tempBody = null;
        if (isset($bankTransactions)) {
            $_tempBody = $bankTransactions;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBankTransactionAttachmentByFileName
     *
     * Allows you to createa an Attachment on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createBankTransactionAttachmentByFileName($bankTransactionID, $fileName, $body)
    {
        list($response) = $this->createBankTransactionAttachmentByFileNameWithHttpInfo($bankTransactionID, $fileName, $body);
        return $response;
    }

    /**
     * Operation createBankTransactionAttachmentByFileNameWithHttpInfo
     *
     * Allows you to createa an Attachment on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBankTransactionAttachmentByFileNameWithHttpInfo($bankTransactionID, $fileName, $body)
    {
        $request = $this->createBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBankTransactionAttachmentByFileNameAsync
     *
     * Allows you to createa an Attachment on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBankTransactionAttachmentByFileNameAsync($bankTransactionID, $fileName, $body)
    {
        return $this->createBankTransactionAttachmentByFileNameAsyncWithHttpInfo($bankTransactionID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBankTransactionAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to createa an Attachment on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBankTransactionAttachmentByFileNameAsyncWithHttpInfo($bankTransactionID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->createBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBankTransactionAttachmentByFileName'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $body)
    {
        // verify the required parameter 'bankTransactionID' is set
        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransactionID when calling createBankTransactionAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling createBankTransactionAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createBankTransactionAttachmentByFileName'
            );
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBankTransactionHistoryRecord
     *
     * Allows you to create history record for a bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createBankTransactionHistoryRecord($bankTransactionID, $historyRecords)
    {
        list($response) = $this->createBankTransactionHistoryRecordWithHttpInfo($bankTransactionID, $historyRecords);
        return $response;
    }

    /**
     * Operation createBankTransactionHistoryRecordWithHttpInfo
     *
     * Allows you to create history record for a bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBankTransactionHistoryRecordWithHttpInfo($bankTransactionID, $historyRecords)
    {
        $request = $this->createBankTransactionHistoryRecordRequest($bankTransactionID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBankTransactionHistoryRecordAsync
     *
     * Allows you to create history record for a bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBankTransactionHistoryRecordAsync($bankTransactionID, $historyRecords)
    {
        return $this->createBankTransactionHistoryRecordAsyncWithHttpInfo($bankTransactionID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBankTransactionHistoryRecordAsyncWithHttpInfo
     *
     * Allows you to create history record for a bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBankTransactionHistoryRecordAsyncWithHttpInfo($bankTransactionID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createBankTransactionHistoryRecordRequest($bankTransactionID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBankTransactionHistoryRecord'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createBankTransactionHistoryRecordRequest($bankTransactionID, $historyRecords)
    {
        // verify the required parameter 'bankTransactionID' is set
        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransactionID when calling createBankTransactionHistoryRecord'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createBankTransactionHistoryRecord'
            );
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBankTransfer
     *
     * Allows you to create a bank transfers
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransfers $bankTransfers bankTransfers (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\BankTransfers|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createBankTransfer($bankTransfers)
    {
        list($response) = $this->createBankTransferWithHttpInfo($bankTransfers);
        return $response;
    }

    /**
     * Operation createBankTransferWithHttpInfo
     *
     * Allows you to create a bank transfers
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransfers $bankTransfers (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\BankTransfers|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBankTransferWithHttpInfo($bankTransfers)
    {
        $request = $this->createBankTransferRequest($bankTransfers);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\BankTransfers' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\BankTransfers', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransfers';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\BankTransfers',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBankTransferAsync
     *
     * Allows you to create a bank transfers
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransfers $bankTransfers (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBankTransferAsync($bankTransfers)
    {
        return $this->createBankTransferAsyncWithHttpInfo($bankTransfers)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBankTransferAsyncWithHttpInfo
     *
     * Allows you to create a bank transfers
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransfers $bankTransfers (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBankTransferAsyncWithHttpInfo($bankTransfers)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransfers';
        $request = $this->createBankTransferRequest($bankTransfers);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBankTransfer'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransfers $bankTransfers (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createBankTransferRequest($bankTransfers)
    {
        // verify the required parameter 'bankTransfers' is set
        if ($bankTransfers === null || (is_array($bankTransfers) && count($bankTransfers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransfers when calling createBankTransfer'
            );
        }

        $resourcePath = '/BankTransfers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($bankTransfers)) {
            $_tempBody = $bankTransfers;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBankTransferAttachmentByFileName
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createBankTransferAttachmentByFileName($bankTransferID, $fileName, $body)
    {
        list($response) = $this->createBankTransferAttachmentByFileNameWithHttpInfo($bankTransferID, $fileName, $body);
        return $response;
    }

    /**
     * Operation createBankTransferAttachmentByFileNameWithHttpInfo
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBankTransferAttachmentByFileNameWithHttpInfo($bankTransferID, $fileName, $body)
    {
        $request = $this->createBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBankTransferAttachmentByFileNameAsync
     *
     * 
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBankTransferAttachmentByFileNameAsync($bankTransferID, $fileName, $body)
    {
        return $this->createBankTransferAttachmentByFileNameAsyncWithHttpInfo($bankTransferID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBankTransferAttachmentByFileNameAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBankTransferAttachmentByFileNameAsyncWithHttpInfo($bankTransferID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->createBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBankTransferAttachmentByFileName'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $body)
    {
        // verify the required parameter 'bankTransferID' is set
        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransferID when calling createBankTransferAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling createBankTransferAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createBankTransferAttachmentByFileName'
            );
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBankTransferHistoryRecord
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createBankTransferHistoryRecord($bankTransferID, $historyRecords)
    {
        list($response) = $this->createBankTransferHistoryRecordWithHttpInfo($bankTransferID, $historyRecords);
        return $response;
    }

    /**
     * Operation createBankTransferHistoryRecordWithHttpInfo
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBankTransferHistoryRecordWithHttpInfo($bankTransferID, $historyRecords)
    {
        $request = $this->createBankTransferHistoryRecordRequest($bankTransferID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBankTransferHistoryRecordAsync
     *
     * 
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBankTransferHistoryRecordAsync($bankTransferID, $historyRecords)
    {
        return $this->createBankTransferHistoryRecordAsyncWithHttpInfo($bankTransferID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBankTransferHistoryRecordAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBankTransferHistoryRecordAsyncWithHttpInfo($bankTransferID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createBankTransferHistoryRecordRequest($bankTransferID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBankTransferHistoryRecord'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createBankTransferHistoryRecordRequest($bankTransferID, $historyRecords)
    {
        // verify the required parameter 'bankTransferID' is set
        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransferID when calling createBankTransferHistoryRecord'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createBankTransferHistoryRecord'
            );
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBatchPayment
     *
     * Create one or many BatchPayments for invoices
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BatchPayments $batchPayments Request of type BatchPayments containing a Payments array with one or more Payment objects (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\BatchPayments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createBatchPayment($batchPayments)
    {
        list($response) = $this->createBatchPaymentWithHttpInfo($batchPayments);
        return $response;
    }

    /**
     * Operation createBatchPaymentWithHttpInfo
     *
     * Create one or many BatchPayments for invoices
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BatchPayments $batchPayments Request of type BatchPayments containing a Payments array with one or more Payment objects (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\BatchPayments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBatchPaymentWithHttpInfo($batchPayments)
    {
        $request = $this->createBatchPaymentRequest($batchPayments);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\BatchPayments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\BatchPayments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\BatchPayments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\BatchPayments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBatchPaymentAsync
     *
     * Create one or many BatchPayments for invoices
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BatchPayments $batchPayments Request of type BatchPayments containing a Payments array with one or more Payment objects (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBatchPaymentAsync($batchPayments)
    {
        return $this->createBatchPaymentAsyncWithHttpInfo($batchPayments)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBatchPaymentAsyncWithHttpInfo
     *
     * Create one or many BatchPayments for invoices
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BatchPayments $batchPayments Request of type BatchPayments containing a Payments array with one or more Payment objects (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBatchPaymentAsyncWithHttpInfo($batchPayments)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\BatchPayments';
        $request = $this->createBatchPaymentRequest($batchPayments);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBatchPayment'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\BatchPayments $batchPayments Request of type BatchPayments containing a Payments array with one or more Payment objects (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createBatchPaymentRequest($batchPayments)
    {
        // verify the required parameter 'batchPayments' is set
        if ($batchPayments === null || (is_array($batchPayments) && count($batchPayments) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batchPayments when calling createBatchPayment'
            );
        }

        $resourcePath = '/BatchPayments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($batchPayments)) {
            $_tempBody = $batchPayments;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBatchPaymentHistoryRecord
     *
     * Allows you to create a history record for a Batch Payment
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createBatchPaymentHistoryRecord($batchPaymentID, $historyRecords)
    {
        list($response) = $this->createBatchPaymentHistoryRecordWithHttpInfo($batchPaymentID, $historyRecords);
        return $response;
    }

    /**
     * Operation createBatchPaymentHistoryRecordWithHttpInfo
     *
     * Allows you to create a history record for a Batch Payment
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBatchPaymentHistoryRecordWithHttpInfo($batchPaymentID, $historyRecords)
    {
        $request = $this->createBatchPaymentHistoryRecordRequest($batchPaymentID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBatchPaymentHistoryRecordAsync
     *
     * Allows you to create a history record for a Batch Payment
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBatchPaymentHistoryRecordAsync($batchPaymentID, $historyRecords)
    {
        return $this->createBatchPaymentHistoryRecordAsyncWithHttpInfo($batchPaymentID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBatchPaymentHistoryRecordAsyncWithHttpInfo
     *
     * Allows you to create a history record for a Batch Payment
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBatchPaymentHistoryRecordAsyncWithHttpInfo($batchPaymentID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createBatchPaymentHistoryRecordRequest($batchPaymentID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBatchPaymentHistoryRecord'
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createBatchPaymentHistoryRecordRequest($batchPaymentID, $historyRecords)
    {
        // verify the required parameter 'batchPaymentID' is set
        if ($batchPaymentID === null || (is_array($batchPaymentID) && count($batchPaymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batchPaymentID when calling createBatchPaymentHistoryRecord'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createBatchPaymentHistoryRecord'
            );
        }

        $resourcePath = '/BatchPayments/{BatchPaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($batchPaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'BatchPaymentID' . '}',
                ObjectSerializer::toPathValue($batchPaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBrandingThemePaymentServices
     *
     * Allow for the creation of new custom payment service for specified Branding Theme
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\PaymentService $paymentService paymentService (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\PaymentServices|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createBrandingThemePaymentServices($brandingThemeID, $paymentService)
    {
        list($response) = $this->createBrandingThemePaymentServicesWithHttpInfo($brandingThemeID, $paymentService);
        return $response;
    }

    /**
     * Operation createBrandingThemePaymentServicesWithHttpInfo
     *
     * Allow for the creation of new custom payment service for specified Branding Theme
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\PaymentService $paymentService (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\PaymentServices|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBrandingThemePaymentServicesWithHttpInfo($brandingThemeID, $paymentService)
    {
        $request = $this->createBrandingThemePaymentServicesRequest($brandingThemeID, $paymentService);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\PaymentServices' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\PaymentServices', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\PaymentServices';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\PaymentServices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBrandingThemePaymentServicesAsync
     *
     * Allow for the creation of new custom payment service for specified Branding Theme
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\PaymentService $paymentService (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBrandingThemePaymentServicesAsync($brandingThemeID, $paymentService)
    {
        return $this->createBrandingThemePaymentServicesAsyncWithHttpInfo($brandingThemeID, $paymentService)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBrandingThemePaymentServicesAsyncWithHttpInfo
     *
     * Allow for the creation of new custom payment service for specified Branding Theme
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\PaymentService $paymentService (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBrandingThemePaymentServicesAsyncWithHttpInfo($brandingThemeID, $paymentService)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\PaymentServices';
        $request = $this->createBrandingThemePaymentServicesRequest($brandingThemeID, $paymentService);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBrandingThemePaymentServices'
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\PaymentService $paymentService (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createBrandingThemePaymentServicesRequest($brandingThemeID, $paymentService)
    {
        // verify the required parameter 'brandingThemeID' is set
        if ($brandingThemeID === null || (is_array($brandingThemeID) && count($brandingThemeID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $brandingThemeID when calling createBrandingThemePaymentServices'
            );
        }
        // verify the required parameter 'paymentService' is set
        if ($paymentService === null || (is_array($paymentService) && count($paymentService) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $paymentService when calling createBrandingThemePaymentServices'
            );
        }

        $resourcePath = '/BrandingThemes/{BrandingThemeID}/PaymentServices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($brandingThemeID !== null) {
            $resourcePath = str_replace(
                '{' . 'BrandingThemeID' . '}',
                ObjectSerializer::toPathValue($brandingThemeID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($paymentService)) {
            $_tempBody = $paymentService;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createContact
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contact $contact contact (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Contacts|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createContact($contact)
    {
        list($response) = $this->createContactWithHttpInfo($contact);
        return $response;
    }

    /**
     * Operation createContactWithHttpInfo
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contact $contact (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Contacts|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContactWithHttpInfo($contact)
    {
        $request = $this->createContactRequest($contact);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Contacts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Contacts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Contacts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Contacts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createContactAsync
     *
     * 
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contact $contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactAsync($contact)
    {
        return $this->createContactAsyncWithHttpInfo($contact)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createContactAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contact $contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactAsyncWithHttpInfo($contact)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Contacts';
        $request = $this->createContactRequest($contact);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createContact'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contact $contact (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createContactRequest($contact)
    {
        // verify the required parameter 'contact' is set
        if ($contact === null || (is_array($contact) && count($contact) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact when calling createContact'
            );
        }

        $resourcePath = '/Contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($contact)) {
            $_tempBody = $contact;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createContactAttachmentByFileName
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createContactAttachmentByFileName($contactID, $fileName, $body)
    {
        list($response) = $this->createContactAttachmentByFileNameWithHttpInfo($contactID, $fileName, $body);
        return $response;
    }

    /**
     * Operation createContactAttachmentByFileNameWithHttpInfo
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContactAttachmentByFileNameWithHttpInfo($contactID, $fileName, $body)
    {
        $request = $this->createContactAttachmentByFileNameRequest($contactID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createContactAttachmentByFileNameAsync
     *
     * 
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactAttachmentByFileNameAsync($contactID, $fileName, $body)
    {
        return $this->createContactAttachmentByFileNameAsyncWithHttpInfo($contactID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createContactAttachmentByFileNameAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactAttachmentByFileNameAsyncWithHttpInfo($contactID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->createContactAttachmentByFileNameRequest($contactID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createContactAttachmentByFileName'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createContactAttachmentByFileNameRequest($contactID, $fileName, $body)
    {
        // verify the required parameter 'contactID' is set
        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactID when calling createContactAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling createContactAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createContactAttachmentByFileName'
            );
        }

        $resourcePath = '/Contacts/{ContactID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createContactGroup
     *
     * Allows you to create a contact group
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ContactGroups $contactGroups contactGroups (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ContactGroups|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createContactGroup($contactGroups = null)
    {
        list($response) = $this->createContactGroupWithHttpInfo($contactGroups);
        return $response;
    }

    /**
     * Operation createContactGroupWithHttpInfo
     *
     * Allows you to create a contact group
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ContactGroups $contactGroups (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ContactGroups|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContactGroupWithHttpInfo($contactGroups = null)
    {
        $request = $this->createContactGroupRequest($contactGroups);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ContactGroups' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ContactGroups', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ContactGroups';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ContactGroups',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createContactGroupAsync
     *
     * Allows you to create a contact group
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ContactGroups $contactGroups (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactGroupAsync($contactGroups = null)
    {
        return $this->createContactGroupAsyncWithHttpInfo($contactGroups)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createContactGroupAsyncWithHttpInfo
     *
     * Allows you to create a contact group
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ContactGroups $contactGroups (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactGroupAsyncWithHttpInfo($contactGroups = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ContactGroups';
        $request = $this->createContactGroupRequest($contactGroups);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createContactGroup'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ContactGroups $contactGroups (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createContactGroupRequest($contactGroups = null)
    {

        $resourcePath = '/ContactGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($contactGroups)) {
            $_tempBody = $contactGroups;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createContactGroupContacts
     *
     * Allows you to add Contacts to a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contacts $contacts contacts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Contacts|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createContactGroupContacts($contactGroupID, $contacts = null)
    {
        list($response) = $this->createContactGroupContactsWithHttpInfo($contactGroupID, $contacts);
        return $response;
    }

    /**
     * Operation createContactGroupContactsWithHttpInfo
     *
     * Allows you to add Contacts to a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contacts $contacts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Contacts|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContactGroupContactsWithHttpInfo($contactGroupID, $contacts = null)
    {
        $request = $this->createContactGroupContactsRequest($contactGroupID, $contacts);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Contacts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Contacts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Contacts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Contacts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createContactGroupContactsAsync
     *
     * Allows you to add Contacts to a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contacts $contacts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactGroupContactsAsync($contactGroupID, $contacts = null)
    {
        return $this->createContactGroupContactsAsyncWithHttpInfo($contactGroupID, $contacts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createContactGroupContactsAsyncWithHttpInfo
     *
     * Allows you to add Contacts to a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contacts $contacts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactGroupContactsAsyncWithHttpInfo($contactGroupID, $contacts = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Contacts';
        $request = $this->createContactGroupContactsRequest($contactGroupID, $contacts);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createContactGroupContacts'
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contacts $contacts (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createContactGroupContactsRequest($contactGroupID, $contacts = null)
    {
        // verify the required parameter 'contactGroupID' is set
        if ($contactGroupID === null || (is_array($contactGroupID) && count($contactGroupID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactGroupID when calling createContactGroupContacts'
            );
        }

        $resourcePath = '/ContactGroups/{ContactGroupID}/Contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactGroupID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactGroupID' . '}',
                ObjectSerializer::toPathValue($contactGroupID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($contacts)) {
            $_tempBody = $contacts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createContactHistory
     *
     * Allows you to retrieve a history records of an Contact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createContactHistory($contactID, $historyRecords)
    {
        list($response) = $this->createContactHistoryWithHttpInfo($contactID, $historyRecords);
        return $response;
    }

    /**
     * Operation createContactHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an Contact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContactHistoryWithHttpInfo($contactID, $historyRecords)
    {
        $request = $this->createContactHistoryRequest($contactID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createContactHistoryAsync
     *
     * Allows you to retrieve a history records of an Contact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactHistoryAsync($contactID, $historyRecords)
    {
        return $this->createContactHistoryAsyncWithHttpInfo($contactID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createContactHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve a history records of an Contact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContactHistoryAsyncWithHttpInfo($contactID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createContactHistoryRequest($contactID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createContactHistory'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createContactHistoryRequest($contactID, $historyRecords)
    {
        // verify the required parameter 'contactID' is set
        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactID when calling createContactHistory'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createContactHistory'
            );
        }

        $resourcePath = '/Contacts/{ContactID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createCreditNote
     *
     * Allows you to create a credit note
     *
     * @param  bool $summarizeErrors shows validation errors for each credit note (optional)
     * @param  \Consilience\XeroAccounting\Sdk\Model\CreditNotes $creditNotes creditNotes (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\CreditNotes|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createCreditNote($summarizeErrors = null, $creditNotes = null)
    {
        list($response) = $this->createCreditNoteWithHttpInfo($summarizeErrors, $creditNotes);
        return $response;
    }

    /**
     * Operation createCreditNoteWithHttpInfo
     *
     * Allows you to create a credit note
     *
     * @param  bool $summarizeErrors shows validation errors for each credit note (optional)
     * @param  \Consilience\XeroAccounting\Sdk\Model\CreditNotes $creditNotes (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\CreditNotes|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCreditNoteWithHttpInfo($summarizeErrors = null, $creditNotes = null)
    {
        $request = $this->createCreditNoteRequest($summarizeErrors, $creditNotes);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\CreditNotes' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\CreditNotes', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\CreditNotes';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\CreditNotes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCreditNoteAsync
     *
     * Allows you to create a credit note
     *
     * @param  bool $summarizeErrors shows validation errors for each credit note (optional)
     * @param  \Consilience\XeroAccounting\Sdk\Model\CreditNotes $creditNotes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCreditNoteAsync($summarizeErrors = null, $creditNotes = null)
    {
        return $this->createCreditNoteAsyncWithHttpInfo($summarizeErrors, $creditNotes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCreditNoteAsyncWithHttpInfo
     *
     * Allows you to create a credit note
     *
     * @param  bool $summarizeErrors shows validation errors for each credit note (optional)
     * @param  \Consilience\XeroAccounting\Sdk\Model\CreditNotes $creditNotes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCreditNoteAsyncWithHttpInfo($summarizeErrors = null, $creditNotes = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\CreditNotes';
        $request = $this->createCreditNoteRequest($summarizeErrors, $creditNotes);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCreditNote'
     *
     * @param  bool $summarizeErrors shows validation errors for each credit note (optional)
     * @param  \Consilience\XeroAccounting\Sdk\Model\CreditNotes $creditNotes (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createCreditNoteRequest($summarizeErrors = null, $creditNotes = null)
    {

        $resourcePath = '/CreditNotes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($summarizeErrors !== null) {
            $queryParams['SummarizeErrors'] = ObjectSerializer::toQueryValue($summarizeErrors);
        }


        // body params
        $_tempBody = null;
        if (isset($creditNotes)) {
            $_tempBody = $creditNotes;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createCreditNoteAllocation
     *
     * Allows you to create Allocation on CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations allocations (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Allocations|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createCreditNoteAllocation($creditNoteID, $allocations = null)
    {
        list($response) = $this->createCreditNoteAllocationWithHttpInfo($creditNoteID, $allocations);
        return $response;
    }

    /**
     * Operation createCreditNoteAllocationWithHttpInfo
     *
     * Allows you to create Allocation on CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Allocations|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCreditNoteAllocationWithHttpInfo($creditNoteID, $allocations = null)
    {
        $request = $this->createCreditNoteAllocationRequest($creditNoteID, $allocations);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Allocations' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Allocations', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Allocations';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Allocations',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCreditNoteAllocationAsync
     *
     * Allows you to create Allocation on CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCreditNoteAllocationAsync($creditNoteID, $allocations = null)
    {
        return $this->createCreditNoteAllocationAsyncWithHttpInfo($creditNoteID, $allocations)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCreditNoteAllocationAsyncWithHttpInfo
     *
     * Allows you to create Allocation on CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCreditNoteAllocationAsyncWithHttpInfo($creditNoteID, $allocations = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Allocations';
        $request = $this->createCreditNoteAllocationRequest($creditNoteID, $allocations);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCreditNoteAllocation'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createCreditNoteAllocationRequest($creditNoteID, $allocations = null)
    {
        // verify the required parameter 'creditNoteID' is set
        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $creditNoteID when calling createCreditNoteAllocation'
            );
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/Allocations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($allocations)) {
            $_tempBody = $allocations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createCreditNoteAttachmentByFileName
     *
     * Allows you to create Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createCreditNoteAttachmentByFileName($creditNoteID, $fileName, $body)
    {
        list($response) = $this->createCreditNoteAttachmentByFileNameWithHttpInfo($creditNoteID, $fileName, $body);
        return $response;
    }

    /**
     * Operation createCreditNoteAttachmentByFileNameWithHttpInfo
     *
     * Allows you to create Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCreditNoteAttachmentByFileNameWithHttpInfo($creditNoteID, $fileName, $body)
    {
        $request = $this->createCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCreditNoteAttachmentByFileNameAsync
     *
     * Allows you to create Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCreditNoteAttachmentByFileNameAsync($creditNoteID, $fileName, $body)
    {
        return $this->createCreditNoteAttachmentByFileNameAsyncWithHttpInfo($creditNoteID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCreditNoteAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to create Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCreditNoteAttachmentByFileNameAsyncWithHttpInfo($creditNoteID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->createCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCreditNoteAttachmentByFileName'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $body)
    {
        // verify the required parameter 'creditNoteID' is set
        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $creditNoteID when calling createCreditNoteAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling createCreditNoteAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createCreditNoteAttachmentByFileName'
            );
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createCreditNoteHistory
     *
     * Allows you to retrieve a history records of an CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createCreditNoteHistory($creditNoteID, $historyRecords)
    {
        list($response) = $this->createCreditNoteHistoryWithHttpInfo($creditNoteID, $historyRecords);
        return $response;
    }

    /**
     * Operation createCreditNoteHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCreditNoteHistoryWithHttpInfo($creditNoteID, $historyRecords)
    {
        $request = $this->createCreditNoteHistoryRequest($creditNoteID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCreditNoteHistoryAsync
     *
     * Allows you to retrieve a history records of an CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCreditNoteHistoryAsync($creditNoteID, $historyRecords)
    {
        return $this->createCreditNoteHistoryAsyncWithHttpInfo($creditNoteID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCreditNoteHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve a history records of an CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCreditNoteHistoryAsyncWithHttpInfo($creditNoteID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createCreditNoteHistoryRequest($creditNoteID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCreditNoteHistory'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createCreditNoteHistoryRequest($creditNoteID, $historyRecords)
    {
        // verify the required parameter 'creditNoteID' is set
        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $creditNoteID when calling createCreditNoteHistory'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createCreditNoteHistory'
            );
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createCurrency
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Currencies $currencies currencies (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Currencies
     */
    public function createCurrency($currencies)
    {
        list($response) = $this->createCurrencyWithHttpInfo($currencies);
        return $response;
    }

    /**
     * Operation createCurrencyWithHttpInfo
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Currencies $currencies (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Currencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCurrencyWithHttpInfo($currencies)
    {
        $request = $this->createCurrencyRequest($currencies);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Currencies' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Currencies', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Currencies';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Currencies',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCurrencyAsync
     *
     * 
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Currencies $currencies (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCurrencyAsync($currencies)
    {
        return $this->createCurrencyAsyncWithHttpInfo($currencies)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCurrencyAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Currencies $currencies (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCurrencyAsyncWithHttpInfo($currencies)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Currencies';
        $request = $this->createCurrencyRequest($currencies);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCurrency'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Currencies $currencies (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createCurrencyRequest($currencies)
    {
        // verify the required parameter 'currencies' is set
        if ($currencies === null || (is_array($currencies) && count($currencies) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currencies when calling createCurrency'
            );
        }

        $resourcePath = '/Currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($currencies)) {
            $_tempBody = $currencies;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createEmployee
     *
     * Allows you to create new employees used in Xero payrun
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Employees $employees employees (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Employees|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createEmployee($employees)
    {
        list($response) = $this->createEmployeeWithHttpInfo($employees);
        return $response;
    }

    /**
     * Operation createEmployeeWithHttpInfo
     *
     * Allows you to create new employees used in Xero payrun
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Employees $employees (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Employees|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEmployeeWithHttpInfo($employees)
    {
        $request = $this->createEmployeeRequest($employees);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Employees' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Employees', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Employees';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Employees',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createEmployeeAsync
     *
     * Allows you to create new employees used in Xero payrun
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Employees $employees (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEmployeeAsync($employees)
    {
        return $this->createEmployeeAsyncWithHttpInfo($employees)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEmployeeAsyncWithHttpInfo
     *
     * Allows you to create new employees used in Xero payrun
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Employees $employees (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEmployeeAsyncWithHttpInfo($employees)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Employees';
        $request = $this->createEmployeeRequest($employees);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEmployee'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Employees $employees (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createEmployeeRequest($employees)
    {
        // verify the required parameter 'employees' is set
        if ($employees === null || (is_array($employees) && count($employees) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employees when calling createEmployee'
            );
        }

        $resourcePath = '/Employees';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($employees)) {
            $_tempBody = $employees;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createExpenseClaim
     *
     * Allows you to retrieve expense claims
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims $expenseClaims expenseClaims (required)
     * @param  bool $summarizeErrors shows validation errors for each expense claim (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createExpenseClaim($expenseClaims, $summarizeErrors = null)
    {
        list($response) = $this->createExpenseClaimWithHttpInfo($expenseClaims, $summarizeErrors);
        return $response;
    }

    /**
     * Operation createExpenseClaimWithHttpInfo
     *
     * Allows you to retrieve expense claims
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims $expenseClaims (required)
     * @param  bool $summarizeErrors shows validation errors for each expense claim (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createExpenseClaimWithHttpInfo($expenseClaims, $summarizeErrors = null)
    {
        $request = $this->createExpenseClaimRequest($expenseClaims, $summarizeErrors);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createExpenseClaimAsync
     *
     * Allows you to retrieve expense claims
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims $expenseClaims (required)
     * @param  bool $summarizeErrors shows validation errors for each expense claim (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExpenseClaimAsync($expenseClaims, $summarizeErrors = null)
    {
        return $this->createExpenseClaimAsyncWithHttpInfo($expenseClaims, $summarizeErrors)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createExpenseClaimAsyncWithHttpInfo
     *
     * Allows you to retrieve expense claims
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims $expenseClaims (required)
     * @param  bool $summarizeErrors shows validation errors for each expense claim (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExpenseClaimAsyncWithHttpInfo($expenseClaims, $summarizeErrors = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims';
        $request = $this->createExpenseClaimRequest($expenseClaims, $summarizeErrors);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createExpenseClaim'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims $expenseClaims (required)
     * @param  bool $summarizeErrors shows validation errors for each expense claim (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createExpenseClaimRequest($expenseClaims, $summarizeErrors = null)
    {
        // verify the required parameter 'expenseClaims' is set
        if ($expenseClaims === null || (is_array($expenseClaims) && count($expenseClaims) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $expenseClaims when calling createExpenseClaim'
            );
        }

        $resourcePath = '/ExpenseClaims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($summarizeErrors !== null) {
            $queryParams['SummarizeErrors'] = ObjectSerializer::toQueryValue($summarizeErrors);
        }


        // body params
        $_tempBody = null;
        if (isset($expenseClaims)) {
            $_tempBody = $expenseClaims;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createExpenseClaimHistory
     *
     * Allows you to create a history records of an ExpenseClaim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function createExpenseClaimHistory($expenseClaimID, $historyRecords)
    {
        list($response) = $this->createExpenseClaimHistoryWithHttpInfo($expenseClaimID, $historyRecords);
        return $response;
    }

    /**
     * Operation createExpenseClaimHistoryWithHttpInfo
     *
     * Allows you to create a history records of an ExpenseClaim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function createExpenseClaimHistoryWithHttpInfo($expenseClaimID, $historyRecords)
    {
        $request = $this->createExpenseClaimHistoryRequest($expenseClaimID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createExpenseClaimHistoryAsync
     *
     * Allows you to create a history records of an ExpenseClaim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExpenseClaimHistoryAsync($expenseClaimID, $historyRecords)
    {
        return $this->createExpenseClaimHistoryAsyncWithHttpInfo($expenseClaimID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createExpenseClaimHistoryAsyncWithHttpInfo
     *
     * Allows you to create a history records of an ExpenseClaim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExpenseClaimHistoryAsyncWithHttpInfo($expenseClaimID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createExpenseClaimHistoryRequest($expenseClaimID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createExpenseClaimHistory'
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createExpenseClaimHistoryRequest($expenseClaimID, $historyRecords)
    {
        // verify the required parameter 'expenseClaimID' is set
        if ($expenseClaimID === null || (is_array($expenseClaimID) && count($expenseClaimID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $expenseClaimID when calling createExpenseClaimHistory'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createExpenseClaimHistory'
            );
        }

        $resourcePath = '/ExpenseClaims/{ExpenseClaimID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($expenseClaimID !== null) {
            $resourcePath = str_replace(
                '{' . 'ExpenseClaimID' . '}',
                ObjectSerializer::toPathValue($expenseClaimID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createInvoice
     *
     * Allows you to create any sales invoices or purchase bills
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Invoices $invoices invoices (required)
     * @param  bool $summarizeErrors shows validation errors for each invoice (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Invoices|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createInvoice($invoices, $summarizeErrors = null)
    {
        list($response) = $this->createInvoiceWithHttpInfo($invoices, $summarizeErrors);
        return $response;
    }

    /**
     * Operation createInvoiceWithHttpInfo
     *
     * Allows you to create any sales invoices or purchase bills
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Invoices $invoices (required)
     * @param  bool $summarizeErrors shows validation errors for each invoice (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Invoices|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createInvoiceWithHttpInfo($invoices, $summarizeErrors = null)
    {
        $request = $this->createInvoiceRequest($invoices, $summarizeErrors);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Invoices' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Invoices', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Invoices';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Invoices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createInvoiceAsync
     *
     * Allows you to create any sales invoices or purchase bills
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Invoices $invoices (required)
     * @param  bool $summarizeErrors shows validation errors for each invoice (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceAsync($invoices, $summarizeErrors = null)
    {
        return $this->createInvoiceAsyncWithHttpInfo($invoices, $summarizeErrors)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInvoiceAsyncWithHttpInfo
     *
     * Allows you to create any sales invoices or purchase bills
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Invoices $invoices (required)
     * @param  bool $summarizeErrors shows validation errors for each invoice (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceAsyncWithHttpInfo($invoices, $summarizeErrors = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Invoices';
        $request = $this->createInvoiceRequest($invoices, $summarizeErrors);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInvoice'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Invoices $invoices (required)
     * @param  bool $summarizeErrors shows validation errors for each invoice (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createInvoiceRequest($invoices, $summarizeErrors = null)
    {
        // verify the required parameter 'invoices' is set
        if ($invoices === null || (is_array($invoices) && count($invoices) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoices when calling createInvoice'
            );
        }

        $resourcePath = '/Invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($summarizeErrors !== null) {
            $queryParams['SummarizeErrors'] = ObjectSerializer::toQueryValue($summarizeErrors);
        }


        // body params
        $_tempBody = null;
        if (isset($invoices)) {
            $_tempBody = $invoices;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createInvoiceAttachmentByFileName
     *
     * Allows you to create an Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createInvoiceAttachmentByFileName($invoiceID, $fileName, $body)
    {
        list($response) = $this->createInvoiceAttachmentByFileNameWithHttpInfo($invoiceID, $fileName, $body);
        return $response;
    }

    /**
     * Operation createInvoiceAttachmentByFileNameWithHttpInfo
     *
     * Allows you to create an Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createInvoiceAttachmentByFileNameWithHttpInfo($invoiceID, $fileName, $body)
    {
        $request = $this->createInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createInvoiceAttachmentByFileNameAsync
     *
     * Allows you to create an Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceAttachmentByFileNameAsync($invoiceID, $fileName, $body)
    {
        return $this->createInvoiceAttachmentByFileNameAsyncWithHttpInfo($invoiceID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInvoiceAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to create an Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceAttachmentByFileNameAsyncWithHttpInfo($invoiceID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->createInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInvoiceAttachmentByFileName'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $body)
    {
        // verify the required parameter 'invoiceID' is set
        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceID when calling createInvoiceAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling createInvoiceAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createInvoiceAttachmentByFileName'
            );
        }

        $resourcePath = '/Invoices/{InvoiceID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createInvoiceHistory
     *
     * Allows you to retrieve a history records of an invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createInvoiceHistory($invoiceID, $historyRecords)
    {
        list($response) = $this->createInvoiceHistoryWithHttpInfo($invoiceID, $historyRecords);
        return $response;
    }

    /**
     * Operation createInvoiceHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createInvoiceHistoryWithHttpInfo($invoiceID, $historyRecords)
    {
        $request = $this->createInvoiceHistoryRequest($invoiceID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createInvoiceHistoryAsync
     *
     * Allows you to retrieve a history records of an invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceHistoryAsync($invoiceID, $historyRecords)
    {
        return $this->createInvoiceHistoryAsyncWithHttpInfo($invoiceID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInvoiceHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve a history records of an invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceHistoryAsyncWithHttpInfo($invoiceID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createInvoiceHistoryRequest($invoiceID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInvoiceHistory'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createInvoiceHistoryRequest($invoiceID, $historyRecords)
    {
        // verify the required parameter 'invoiceID' is set
        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceID when calling createInvoiceHistory'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createInvoiceHistory'
            );
        }

        $resourcePath = '/Invoices/{InvoiceID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createItem
     *
     * Allows you to create an item
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Items $items items (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Items|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createItem($items)
    {
        list($response) = $this->createItemWithHttpInfo($items);
        return $response;
    }

    /**
     * Operation createItemWithHttpInfo
     *
     * Allows you to create an item
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Items $items (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Items|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createItemWithHttpInfo($items)
    {
        $request = $this->createItemRequest($items);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Items' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Items', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Items';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Items',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createItemAsync
     *
     * Allows you to create an item
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Items $items (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createItemAsync($items)
    {
        return $this->createItemAsyncWithHttpInfo($items)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createItemAsyncWithHttpInfo
     *
     * Allows you to create an item
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Items $items (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createItemAsyncWithHttpInfo($items)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Items';
        $request = $this->createItemRequest($items);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createItem'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Items $items (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createItemRequest($items)
    {
        // verify the required parameter 'items' is set
        if ($items === null || (is_array($items) && count($items) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $items when calling createItem'
            );
        }

        $resourcePath = '/Items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($items)) {
            $_tempBody = $items;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createItemHistory
     *
     * Allows you to create a history record for items
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function createItemHistory($itemID, $historyRecords)
    {
        list($response) = $this->createItemHistoryWithHttpInfo($itemID, $historyRecords);
        return $response;
    }

    /**
     * Operation createItemHistoryWithHttpInfo
     *
     * Allows you to create a history record for items
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function createItemHistoryWithHttpInfo($itemID, $historyRecords)
    {
        $request = $this->createItemHistoryRequest($itemID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createItemHistoryAsync
     *
     * Allows you to create a history record for items
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createItemHistoryAsync($itemID, $historyRecords)
    {
        return $this->createItemHistoryAsyncWithHttpInfo($itemID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createItemHistoryAsyncWithHttpInfo
     *
     * Allows you to create a history record for items
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createItemHistoryAsyncWithHttpInfo($itemID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createItemHistoryRequest($itemID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createItemHistory'
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createItemHistoryRequest($itemID, $historyRecords)
    {
        // verify the required parameter 'itemID' is set
        if ($itemID === null || (is_array($itemID) && count($itemID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $itemID when calling createItemHistory'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createItemHistory'
            );
        }

        $resourcePath = '/Items/{ItemID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($itemID !== null) {
            $resourcePath = str_replace(
                '{' . 'ItemID' . '}',
                ObjectSerializer::toPathValue($itemID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createLinkedTransaction
     *
     * Allows you to create linked transactions (billable expenses)
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions $linkedTransactions linkedTransactions (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createLinkedTransaction($linkedTransactions)
    {
        list($response) = $this->createLinkedTransactionWithHttpInfo($linkedTransactions);
        return $response;
    }

    /**
     * Operation createLinkedTransactionWithHttpInfo
     *
     * Allows you to create linked transactions (billable expenses)
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions $linkedTransactions (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createLinkedTransactionWithHttpInfo($linkedTransactions)
    {
        $request = $this->createLinkedTransactionRequest($linkedTransactions);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createLinkedTransactionAsync
     *
     * Allows you to create linked transactions (billable expenses)
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions $linkedTransactions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createLinkedTransactionAsync($linkedTransactions)
    {
        return $this->createLinkedTransactionAsyncWithHttpInfo($linkedTransactions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createLinkedTransactionAsyncWithHttpInfo
     *
     * Allows you to create linked transactions (billable expenses)
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions $linkedTransactions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createLinkedTransactionAsyncWithHttpInfo($linkedTransactions)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions';
        $request = $this->createLinkedTransactionRequest($linkedTransactions);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createLinkedTransaction'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions $linkedTransactions (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createLinkedTransactionRequest($linkedTransactions)
    {
        // verify the required parameter 'linkedTransactions' is set
        if ($linkedTransactions === null || (is_array($linkedTransactions) && count($linkedTransactions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $linkedTransactions when calling createLinkedTransaction'
            );
        }

        $resourcePath = '/LinkedTransactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($linkedTransactions)) {
            $_tempBody = $linkedTransactions;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createManualJournal
     *
     * Allows you to create a manual journal
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ManualJournals $manualJournals manualJournals (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ManualJournals|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createManualJournal($manualJournals)
    {
        list($response) = $this->createManualJournalWithHttpInfo($manualJournals);
        return $response;
    }

    /**
     * Operation createManualJournalWithHttpInfo
     *
     * Allows you to create a manual journal
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ManualJournals $manualJournals (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ManualJournals|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createManualJournalWithHttpInfo($manualJournals)
    {
        $request = $this->createManualJournalRequest($manualJournals);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ManualJournals' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ManualJournals', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ManualJournals';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ManualJournals',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createManualJournalAsync
     *
     * Allows you to create a manual journal
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ManualJournals $manualJournals (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createManualJournalAsync($manualJournals)
    {
        return $this->createManualJournalAsyncWithHttpInfo($manualJournals)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createManualJournalAsyncWithHttpInfo
     *
     * Allows you to create a manual journal
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ManualJournals $manualJournals (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createManualJournalAsyncWithHttpInfo($manualJournals)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ManualJournals';
        $request = $this->createManualJournalRequest($manualJournals);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createManualJournal'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\ManualJournals $manualJournals (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createManualJournalRequest($manualJournals)
    {
        // verify the required parameter 'manualJournals' is set
        if ($manualJournals === null || (is_array($manualJournals) && count($manualJournals) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $manualJournals when calling createManualJournal'
            );
        }

        $resourcePath = '/ManualJournals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($manualJournals)) {
            $_tempBody = $manualJournals;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createManualJournalAttachmentByFileName
     *
     * Allows you to create a specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createManualJournalAttachmentByFileName($manualJournalID, $fileName, $body)
    {
        list($response) = $this->createManualJournalAttachmentByFileNameWithHttpInfo($manualJournalID, $fileName, $body);
        return $response;
    }

    /**
     * Operation createManualJournalAttachmentByFileNameWithHttpInfo
     *
     * Allows you to create a specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createManualJournalAttachmentByFileNameWithHttpInfo($manualJournalID, $fileName, $body)
    {
        $request = $this->createManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createManualJournalAttachmentByFileNameAsync
     *
     * Allows you to create a specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createManualJournalAttachmentByFileNameAsync($manualJournalID, $fileName, $body)
    {
        return $this->createManualJournalAttachmentByFileNameAsyncWithHttpInfo($manualJournalID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createManualJournalAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to create a specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createManualJournalAttachmentByFileNameAsyncWithHttpInfo($manualJournalID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->createManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createManualJournalAttachmentByFileName'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $body)
    {
        // verify the required parameter 'manualJournalID' is set
        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $manualJournalID when calling createManualJournalAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling createManualJournalAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createManualJournalAttachmentByFileName'
            );
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createOverpaymentAllocation
     *
     * Allows you to retrieve Allocations for overpayments
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations allocations (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Allocations|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createOverpaymentAllocation($overpaymentID, $allocations)
    {
        list($response) = $this->createOverpaymentAllocationWithHttpInfo($overpaymentID, $allocations);
        return $response;
    }

    /**
     * Operation createOverpaymentAllocationWithHttpInfo
     *
     * Allows you to retrieve Allocations for overpayments
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Allocations|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOverpaymentAllocationWithHttpInfo($overpaymentID, $allocations)
    {
        $request = $this->createOverpaymentAllocationRequest($overpaymentID, $allocations);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Allocations' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Allocations', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Allocations';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Allocations',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOverpaymentAllocationAsync
     *
     * Allows you to retrieve Allocations for overpayments
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOverpaymentAllocationAsync($overpaymentID, $allocations)
    {
        return $this->createOverpaymentAllocationAsyncWithHttpInfo($overpaymentID, $allocations)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOverpaymentAllocationAsyncWithHttpInfo
     *
     * Allows you to retrieve Allocations for overpayments
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOverpaymentAllocationAsyncWithHttpInfo($overpaymentID, $allocations)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Allocations';
        $request = $this->createOverpaymentAllocationRequest($overpaymentID, $allocations);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOverpaymentAllocation'
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createOverpaymentAllocationRequest($overpaymentID, $allocations)
    {
        // verify the required parameter 'overpaymentID' is set
        if ($overpaymentID === null || (is_array($overpaymentID) && count($overpaymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overpaymentID when calling createOverpaymentAllocation'
            );
        }
        // verify the required parameter 'allocations' is set
        if ($allocations === null || (is_array($allocations) && count($allocations) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $allocations when calling createOverpaymentAllocation'
            );
        }

        $resourcePath = '/Overpayments/{OverpaymentID}/Allocations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($overpaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'OverpaymentID' . '}',
                ObjectSerializer::toPathValue($overpaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($allocations)) {
            $_tempBody = $allocations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createOverpaymentHistory
     *
     * Allows you to create history records of an Overpayment
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createOverpaymentHistory($overpaymentID, $historyRecords)
    {
        list($response) = $this->createOverpaymentHistoryWithHttpInfo($overpaymentID, $historyRecords);
        return $response;
    }

    /**
     * Operation createOverpaymentHistoryWithHttpInfo
     *
     * Allows you to create history records of an Overpayment
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOverpaymentHistoryWithHttpInfo($overpaymentID, $historyRecords)
    {
        $request = $this->createOverpaymentHistoryRequest($overpaymentID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOverpaymentHistoryAsync
     *
     * Allows you to create history records of an Overpayment
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOverpaymentHistoryAsync($overpaymentID, $historyRecords)
    {
        return $this->createOverpaymentHistoryAsyncWithHttpInfo($overpaymentID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOverpaymentHistoryAsyncWithHttpInfo
     *
     * Allows you to create history records of an Overpayment
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOverpaymentHistoryAsyncWithHttpInfo($overpaymentID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createOverpaymentHistoryRequest($overpaymentID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOverpaymentHistory'
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createOverpaymentHistoryRequest($overpaymentID, $historyRecords)
    {
        // verify the required parameter 'overpaymentID' is set
        if ($overpaymentID === null || (is_array($overpaymentID) && count($overpaymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overpaymentID when calling createOverpaymentHistory'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createOverpaymentHistory'
            );
        }

        $resourcePath = '/Overpayments/{OverpaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($overpaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'OverpaymentID' . '}',
                ObjectSerializer::toPathValue($overpaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPayment
     *
     * Allows you to create payments for invoices and credit notes
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Payments $payments payments (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Payments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createPayment($payments)
    {
        list($response) = $this->createPaymentWithHttpInfo($payments);
        return $response;
    }

    /**
     * Operation createPaymentWithHttpInfo
     *
     * Allows you to create payments for invoices and credit notes
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Payments $payments (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Payments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPaymentWithHttpInfo($payments)
    {
        $request = $this->createPaymentRequest($payments);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Payments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Payments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Payments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Payments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPaymentAsync
     *
     * Allows you to create payments for invoices and credit notes
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Payments $payments (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPaymentAsync($payments)
    {
        return $this->createPaymentAsyncWithHttpInfo($payments)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPaymentAsyncWithHttpInfo
     *
     * Allows you to create payments for invoices and credit notes
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Payments $payments (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPaymentAsyncWithHttpInfo($payments)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Payments';
        $request = $this->createPaymentRequest($payments);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPayment'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Payments $payments (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createPaymentRequest($payments)
    {
        // verify the required parameter 'payments' is set
        if ($payments === null || (is_array($payments) && count($payments) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payments when calling createPayment'
            );
        }

        $resourcePath = '/Payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($payments)) {
            $_tempBody = $payments;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPaymentHistory
     *
     * Allows you to create a history record for a payment
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createPaymentHistory($paymentID, $historyRecords)
    {
        list($response) = $this->createPaymentHistoryWithHttpInfo($paymentID, $historyRecords);
        return $response;
    }

    /**
     * Operation createPaymentHistoryWithHttpInfo
     *
     * Allows you to create a history record for a payment
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPaymentHistoryWithHttpInfo($paymentID, $historyRecords)
    {
        $request = $this->createPaymentHistoryRequest($paymentID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPaymentHistoryAsync
     *
     * Allows you to create a history record for a payment
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPaymentHistoryAsync($paymentID, $historyRecords)
    {
        return $this->createPaymentHistoryAsyncWithHttpInfo($paymentID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPaymentHistoryAsyncWithHttpInfo
     *
     * Allows you to create a history record for a payment
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPaymentHistoryAsyncWithHttpInfo($paymentID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createPaymentHistoryRequest($paymentID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPaymentHistory'
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createPaymentHistoryRequest($paymentID, $historyRecords)
    {
        // verify the required parameter 'paymentID' is set
        if ($paymentID === null || (is_array($paymentID) && count($paymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $paymentID when calling createPaymentHistory'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createPaymentHistory'
            );
        }

        $resourcePath = '/Payments/{PaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($paymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PaymentID' . '}',
                ObjectSerializer::toPathValue($paymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPaymentService
     *
     * Allows you to create payment services
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\PaymentServices $paymentServices paymentServices (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\PaymentServices|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createPaymentService($paymentServices)
    {
        list($response) = $this->createPaymentServiceWithHttpInfo($paymentServices);
        return $response;
    }

    /**
     * Operation createPaymentServiceWithHttpInfo
     *
     * Allows you to create payment services
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\PaymentServices $paymentServices (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\PaymentServices|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPaymentServiceWithHttpInfo($paymentServices)
    {
        $request = $this->createPaymentServiceRequest($paymentServices);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\PaymentServices' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\PaymentServices', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\PaymentServices';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\PaymentServices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPaymentServiceAsync
     *
     * Allows you to create payment services
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\PaymentServices $paymentServices (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPaymentServiceAsync($paymentServices)
    {
        return $this->createPaymentServiceAsyncWithHttpInfo($paymentServices)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPaymentServiceAsyncWithHttpInfo
     *
     * Allows you to create payment services
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\PaymentServices $paymentServices (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPaymentServiceAsyncWithHttpInfo($paymentServices)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\PaymentServices';
        $request = $this->createPaymentServiceRequest($paymentServices);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPaymentService'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\PaymentServices $paymentServices (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createPaymentServiceRequest($paymentServices)
    {
        // verify the required parameter 'paymentServices' is set
        if ($paymentServices === null || (is_array($paymentServices) && count($paymentServices) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $paymentServices when calling createPaymentService'
            );
        }

        $resourcePath = '/PaymentServices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($paymentServices)) {
            $_tempBody = $paymentServices;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPrepaymentAllocation
     *
     * Allows you to create an Allocation for prepayments
     *
     * @param  string $prepaymentID prepaymentID (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations allocations (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Allocations|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createPrepaymentAllocation($prepaymentID, $allocations)
    {
        list($response) = $this->createPrepaymentAllocationWithHttpInfo($prepaymentID, $allocations);
        return $response;
    }

    /**
     * Operation createPrepaymentAllocationWithHttpInfo
     *
     * Allows you to create an Allocation for prepayments
     *
     * @param  string $prepaymentID (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Allocations|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPrepaymentAllocationWithHttpInfo($prepaymentID, $allocations)
    {
        $request = $this->createPrepaymentAllocationRequest($prepaymentID, $allocations);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Allocations' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Allocations', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Allocations';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Allocations',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPrepaymentAllocationAsync
     *
     * Allows you to create an Allocation for prepayments
     *
     * @param  string $prepaymentID (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPrepaymentAllocationAsync($prepaymentID, $allocations)
    {
        return $this->createPrepaymentAllocationAsyncWithHttpInfo($prepaymentID, $allocations)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPrepaymentAllocationAsyncWithHttpInfo
     *
     * Allows you to create an Allocation for prepayments
     *
     * @param  string $prepaymentID (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPrepaymentAllocationAsyncWithHttpInfo($prepaymentID, $allocations)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Allocations';
        $request = $this->createPrepaymentAllocationRequest($prepaymentID, $allocations);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPrepaymentAllocation'
     *
     * @param  string $prepaymentID (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Allocations $allocations (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createPrepaymentAllocationRequest($prepaymentID, $allocations)
    {
        // verify the required parameter 'prepaymentID' is set
        if ($prepaymentID === null || (is_array($prepaymentID) && count($prepaymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prepaymentID when calling createPrepaymentAllocation'
            );
        }
        // verify the required parameter 'allocations' is set
        if ($allocations === null || (is_array($allocations) && count($allocations) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $allocations when calling createPrepaymentAllocation'
            );
        }

        $resourcePath = '/Prepayments/{PrepaymentID}/Allocations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($prepaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PrepaymentID' . '}',
                ObjectSerializer::toPathValue($prepaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($allocations)) {
            $_tempBody = $allocations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPrepaymentHistory
     *
     * Allows you to create a history record for an Prepayment
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createPrepaymentHistory($prepaymentID, $historyRecords)
    {
        list($response) = $this->createPrepaymentHistoryWithHttpInfo($prepaymentID, $historyRecords);
        return $response;
    }

    /**
     * Operation createPrepaymentHistoryWithHttpInfo
     *
     * Allows you to create a history record for an Prepayment
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPrepaymentHistoryWithHttpInfo($prepaymentID, $historyRecords)
    {
        $request = $this->createPrepaymentHistoryRequest($prepaymentID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPrepaymentHistoryAsync
     *
     * Allows you to create a history record for an Prepayment
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPrepaymentHistoryAsync($prepaymentID, $historyRecords)
    {
        return $this->createPrepaymentHistoryAsyncWithHttpInfo($prepaymentID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPrepaymentHistoryAsyncWithHttpInfo
     *
     * Allows you to create a history record for an Prepayment
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPrepaymentHistoryAsyncWithHttpInfo($prepaymentID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createPrepaymentHistoryRequest($prepaymentID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPrepaymentHistory'
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createPrepaymentHistoryRequest($prepaymentID, $historyRecords)
    {
        // verify the required parameter 'prepaymentID' is set
        if ($prepaymentID === null || (is_array($prepaymentID) && count($prepaymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prepaymentID when calling createPrepaymentHistory'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createPrepaymentHistory'
            );
        }

        $resourcePath = '/Prepayments/{PrepaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($prepaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PrepaymentID' . '}',
                ObjectSerializer::toPathValue($prepaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPurchaseOrder
     *
     * Allows you to create purchase orders
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders $purchaseOrders purchaseOrders (required)
     * @param  bool $summarizeErrors shows validation errors for each purchase order. (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createPurchaseOrder($purchaseOrders, $summarizeErrors = null)
    {
        list($response) = $this->createPurchaseOrderWithHttpInfo($purchaseOrders, $summarizeErrors);
        return $response;
    }

    /**
     * Operation createPurchaseOrderWithHttpInfo
     *
     * Allows you to create purchase orders
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders $purchaseOrders (required)
     * @param  bool $summarizeErrors shows validation errors for each purchase order. (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPurchaseOrderWithHttpInfo($purchaseOrders, $summarizeErrors = null)
    {
        $request = $this->createPurchaseOrderRequest($purchaseOrders, $summarizeErrors);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPurchaseOrderAsync
     *
     * Allows you to create purchase orders
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders $purchaseOrders (required)
     * @param  bool $summarizeErrors shows validation errors for each purchase order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPurchaseOrderAsync($purchaseOrders, $summarizeErrors = null)
    {
        return $this->createPurchaseOrderAsyncWithHttpInfo($purchaseOrders, $summarizeErrors)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPurchaseOrderAsyncWithHttpInfo
     *
     * Allows you to create purchase orders
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders $purchaseOrders (required)
     * @param  bool $summarizeErrors shows validation errors for each purchase order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPurchaseOrderAsyncWithHttpInfo($purchaseOrders, $summarizeErrors = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders';
        $request = $this->createPurchaseOrderRequest($purchaseOrders, $summarizeErrors);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPurchaseOrder'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders $purchaseOrders (required)
     * @param  bool $summarizeErrors shows validation errors for each purchase order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createPurchaseOrderRequest($purchaseOrders, $summarizeErrors = null)
    {
        // verify the required parameter 'purchaseOrders' is set
        if ($purchaseOrders === null || (is_array($purchaseOrders) && count($purchaseOrders) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purchaseOrders when calling createPurchaseOrder'
            );
        }

        $resourcePath = '/PurchaseOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($summarizeErrors !== null) {
            $queryParams['SummarizeErrors'] = ObjectSerializer::toQueryValue($summarizeErrors);
        }


        // body params
        $_tempBody = null;
        if (isset($purchaseOrders)) {
            $_tempBody = $purchaseOrders;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPurchaseOrderHistory
     *
     * Allows you to create HistoryRecord for purchase orders
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createPurchaseOrderHistory($purchaseOrderID, $historyRecords)
    {
        list($response) = $this->createPurchaseOrderHistoryWithHttpInfo($purchaseOrderID, $historyRecords);
        return $response;
    }

    /**
     * Operation createPurchaseOrderHistoryWithHttpInfo
     *
     * Allows you to create HistoryRecord for purchase orders
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPurchaseOrderHistoryWithHttpInfo($purchaseOrderID, $historyRecords)
    {
        $request = $this->createPurchaseOrderHistoryRequest($purchaseOrderID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPurchaseOrderHistoryAsync
     *
     * Allows you to create HistoryRecord for purchase orders
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPurchaseOrderHistoryAsync($purchaseOrderID, $historyRecords)
    {
        return $this->createPurchaseOrderHistoryAsyncWithHttpInfo($purchaseOrderID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPurchaseOrderHistoryAsyncWithHttpInfo
     *
     * Allows you to create HistoryRecord for purchase orders
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPurchaseOrderHistoryAsyncWithHttpInfo($purchaseOrderID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createPurchaseOrderHistoryRequest($purchaseOrderID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPurchaseOrderHistory'
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createPurchaseOrderHistoryRequest($purchaseOrderID, $historyRecords)
    {
        // verify the required parameter 'purchaseOrderID' is set
        if ($purchaseOrderID === null || (is_array($purchaseOrderID) && count($purchaseOrderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purchaseOrderID when calling createPurchaseOrderHistory'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createPurchaseOrderHistory'
            );
        }

        $resourcePath = '/PurchaseOrders/{PurchaseOrderID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($purchaseOrderID !== null) {
            $resourcePath = str_replace(
                '{' . 'PurchaseOrderID' . '}',
                ObjectSerializer::toPathValue($purchaseOrderID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createReceipt
     *
     * Allows you to create draft expense claim receipts for any user
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Receipts $receipts receipts (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Receipts|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createReceipt($receipts)
    {
        list($response) = $this->createReceiptWithHttpInfo($receipts);
        return $response;
    }

    /**
     * Operation createReceiptWithHttpInfo
     *
     * Allows you to create draft expense claim receipts for any user
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Receipts $receipts (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Receipts|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createReceiptWithHttpInfo($receipts)
    {
        $request = $this->createReceiptRequest($receipts);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Receipts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Receipts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Receipts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Receipts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createReceiptAsync
     *
     * Allows you to create draft expense claim receipts for any user
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Receipts $receipts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createReceiptAsync($receipts)
    {
        return $this->createReceiptAsyncWithHttpInfo($receipts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createReceiptAsyncWithHttpInfo
     *
     * Allows you to create draft expense claim receipts for any user
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Receipts $receipts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createReceiptAsyncWithHttpInfo($receipts)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Receipts';
        $request = $this->createReceiptRequest($receipts);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createReceipt'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Receipts $receipts (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createReceiptRequest($receipts)
    {
        // verify the required parameter 'receipts' is set
        if ($receipts === null || (is_array($receipts) && count($receipts) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receipts when calling createReceipt'
            );
        }

        $resourcePath = '/Receipts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($receipts)) {
            $_tempBody = $receipts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createReceiptAttachmentByFileName
     *
     * Allows you to create Attachment on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createReceiptAttachmentByFileName($receiptID, $fileName, $body)
    {
        list($response) = $this->createReceiptAttachmentByFileNameWithHttpInfo($receiptID, $fileName, $body);
        return $response;
    }

    /**
     * Operation createReceiptAttachmentByFileNameWithHttpInfo
     *
     * Allows you to create Attachment on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createReceiptAttachmentByFileNameWithHttpInfo($receiptID, $fileName, $body)
    {
        $request = $this->createReceiptAttachmentByFileNameRequest($receiptID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createReceiptAttachmentByFileNameAsync
     *
     * Allows you to create Attachment on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createReceiptAttachmentByFileNameAsync($receiptID, $fileName, $body)
    {
        return $this->createReceiptAttachmentByFileNameAsyncWithHttpInfo($receiptID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createReceiptAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to create Attachment on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createReceiptAttachmentByFileNameAsyncWithHttpInfo($receiptID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->createReceiptAttachmentByFileNameRequest($receiptID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createReceiptAttachmentByFileName'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createReceiptAttachmentByFileNameRequest($receiptID, $fileName, $body)
    {
        // verify the required parameter 'receiptID' is set
        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receiptID when calling createReceiptAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling createReceiptAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createReceiptAttachmentByFileName'
            );
        }

        $resourcePath = '/Receipts/{ReceiptID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createReceiptHistory
     *
     * Allows you to retrieve a history records of an Receipt
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createReceiptHistory($receiptID, $historyRecords)
    {
        list($response) = $this->createReceiptHistoryWithHttpInfo($receiptID, $historyRecords);
        return $response;
    }

    /**
     * Operation createReceiptHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an Receipt
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createReceiptHistoryWithHttpInfo($receiptID, $historyRecords)
    {
        $request = $this->createReceiptHistoryRequest($receiptID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createReceiptHistoryAsync
     *
     * Allows you to retrieve a history records of an Receipt
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createReceiptHistoryAsync($receiptID, $historyRecords)
    {
        return $this->createReceiptHistoryAsyncWithHttpInfo($receiptID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createReceiptHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve a history records of an Receipt
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createReceiptHistoryAsyncWithHttpInfo($receiptID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createReceiptHistoryRequest($receiptID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createReceiptHistory'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createReceiptHistoryRequest($receiptID, $historyRecords)
    {
        // verify the required parameter 'receiptID' is set
        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receiptID when calling createReceiptHistory'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createReceiptHistory'
            );
        }

        $resourcePath = '/Receipts/{ReceiptID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createRepeatingInvoiceAttachmentByFileName
     *
     * Allows you to create attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createRepeatingInvoiceAttachmentByFileName($repeatingInvoiceID, $fileName, $body)
    {
        list($response) = $this->createRepeatingInvoiceAttachmentByFileNameWithHttpInfo($repeatingInvoiceID, $fileName, $body);
        return $response;
    }

    /**
     * Operation createRepeatingInvoiceAttachmentByFileNameWithHttpInfo
     *
     * Allows you to create attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRepeatingInvoiceAttachmentByFileNameWithHttpInfo($repeatingInvoiceID, $fileName, $body)
    {
        $request = $this->createRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRepeatingInvoiceAttachmentByFileNameAsync
     *
     * Allows you to create attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRepeatingInvoiceAttachmentByFileNameAsync($repeatingInvoiceID, $fileName, $body)
    {
        return $this->createRepeatingInvoiceAttachmentByFileNameAsyncWithHttpInfo($repeatingInvoiceID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRepeatingInvoiceAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to create attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRepeatingInvoiceAttachmentByFileNameAsyncWithHttpInfo($repeatingInvoiceID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->createRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRepeatingInvoiceAttachmentByFileName'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $body)
    {
        // verify the required parameter 'repeatingInvoiceID' is set
        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repeatingInvoiceID when calling createRepeatingInvoiceAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling createRepeatingInvoiceAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createRepeatingInvoiceAttachmentByFileName'
            );
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createRepeatingInvoiceHistory
     *
     * Allows you to create history for a repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createRepeatingInvoiceHistory($repeatingInvoiceID, $historyRecords)
    {
        list($response) = $this->createRepeatingInvoiceHistoryWithHttpInfo($repeatingInvoiceID, $historyRecords);
        return $response;
    }

    /**
     * Operation createRepeatingInvoiceHistoryWithHttpInfo
     *
     * Allows you to create history for a repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRepeatingInvoiceHistoryWithHttpInfo($repeatingInvoiceID, $historyRecords)
    {
        $request = $this->createRepeatingInvoiceHistoryRequest($repeatingInvoiceID, $historyRecords);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRepeatingInvoiceHistoryAsync
     *
     * Allows you to create history for a repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRepeatingInvoiceHistoryAsync($repeatingInvoiceID, $historyRecords)
    {
        return $this->createRepeatingInvoiceHistoryAsyncWithHttpInfo($repeatingInvoiceID, $historyRecords)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRepeatingInvoiceHistoryAsyncWithHttpInfo
     *
     * Allows you to create history for a repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRepeatingInvoiceHistoryAsyncWithHttpInfo($repeatingInvoiceID, $historyRecords)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->createRepeatingInvoiceHistoryRequest($repeatingInvoiceID, $historyRecords);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRepeatingInvoiceHistory'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createRepeatingInvoiceHistoryRequest($repeatingInvoiceID, $historyRecords)
    {
        // verify the required parameter 'repeatingInvoiceID' is set
        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repeatingInvoiceID when calling createRepeatingInvoiceHistory'
            );
        }
        // verify the required parameter 'historyRecords' is set
        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $historyRecords when calling createRepeatingInvoiceHistory'
            );
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createTaxRate
     *
     * Allows you to create Tax Rates
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TaxRates $taxRates taxRates (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\TaxRates|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createTaxRate($taxRates)
    {
        list($response) = $this->createTaxRateWithHttpInfo($taxRates);
        return $response;
    }

    /**
     * Operation createTaxRateWithHttpInfo
     *
     * Allows you to create Tax Rates
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TaxRates $taxRates (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\TaxRates|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTaxRateWithHttpInfo($taxRates)
    {
        $request = $this->createTaxRateRequest($taxRates);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\TaxRates' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\TaxRates', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\TaxRates';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\TaxRates',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTaxRateAsync
     *
     * Allows you to create Tax Rates
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TaxRates $taxRates (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaxRateAsync($taxRates)
    {
        return $this->createTaxRateAsyncWithHttpInfo($taxRates)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTaxRateAsyncWithHttpInfo
     *
     * Allows you to create Tax Rates
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TaxRates $taxRates (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaxRateAsyncWithHttpInfo($taxRates)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\TaxRates';
        $request = $this->createTaxRateRequest($taxRates);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTaxRate'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TaxRates $taxRates (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createTaxRateRequest($taxRates)
    {
        // verify the required parameter 'taxRates' is set
        if ($taxRates === null || (is_array($taxRates) && count($taxRates) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taxRates when calling createTaxRate'
            );
        }

        $resourcePath = '/TaxRates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($taxRates)) {
            $_tempBody = $taxRates;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createTrackingCategory
     *
     * Allows you to create tracking categories
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingCategory $trackingCategory trackingCategory (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\TrackingCategories|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createTrackingCategory($trackingCategory)
    {
        list($response) = $this->createTrackingCategoryWithHttpInfo($trackingCategory);
        return $response;
    }

    /**
     * Operation createTrackingCategoryWithHttpInfo
     *
     * Allows you to create tracking categories
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingCategory $trackingCategory (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\TrackingCategories|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTrackingCategoryWithHttpInfo($trackingCategory)
    {
        $request = $this->createTrackingCategoryRequest($trackingCategory);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\TrackingCategories' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTrackingCategoryAsync
     *
     * Allows you to create tracking categories
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingCategory $trackingCategory (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTrackingCategoryAsync($trackingCategory)
    {
        return $this->createTrackingCategoryAsyncWithHttpInfo($trackingCategory)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTrackingCategoryAsyncWithHttpInfo
     *
     * Allows you to create tracking categories
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingCategory $trackingCategory (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTrackingCategoryAsyncWithHttpInfo($trackingCategory)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories';
        $request = $this->createTrackingCategoryRequest($trackingCategory);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTrackingCategory'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingCategory $trackingCategory (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createTrackingCategoryRequest($trackingCategory)
    {
        // verify the required parameter 'trackingCategory' is set
        if ($trackingCategory === null || (is_array($trackingCategory) && count($trackingCategory) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trackingCategory when calling createTrackingCategory'
            );
        }

        $resourcePath = '/TrackingCategories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($trackingCategory)) {
            $_tempBody = $trackingCategory;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createTrackingOptions
     *
     * Allows you to create options for a specified tracking category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingOption $trackingOption trackingOption (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\TrackingOptions|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function createTrackingOptions($trackingCategoryID, $trackingOption)
    {
        list($response) = $this->createTrackingOptionsWithHttpInfo($trackingCategoryID, $trackingOption);
        return $response;
    }

    /**
     * Operation createTrackingOptionsWithHttpInfo
     *
     * Allows you to create options for a specified tracking category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingOption $trackingOption (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\TrackingOptions|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTrackingOptionsWithHttpInfo($trackingCategoryID, $trackingOption)
    {
        $request = $this->createTrackingOptionsRequest($trackingCategoryID, $trackingOption);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\TrackingOptions' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\TrackingOptions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingOptions';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\TrackingOptions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTrackingOptionsAsync
     *
     * Allows you to create options for a specified tracking category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingOption $trackingOption (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTrackingOptionsAsync($trackingCategoryID, $trackingOption)
    {
        return $this->createTrackingOptionsAsyncWithHttpInfo($trackingCategoryID, $trackingOption)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTrackingOptionsAsyncWithHttpInfo
     *
     * Allows you to create options for a specified tracking category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingOption $trackingOption (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTrackingOptionsAsyncWithHttpInfo($trackingCategoryID, $trackingOption)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingOptions';
        $request = $this->createTrackingOptionsRequest($trackingCategoryID, $trackingOption);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTrackingOptions'
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingOption $trackingOption (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createTrackingOptionsRequest($trackingCategoryID, $trackingOption)
    {
        // verify the required parameter 'trackingCategoryID' is set
        if ($trackingCategoryID === null || (is_array($trackingCategoryID) && count($trackingCategoryID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trackingCategoryID when calling createTrackingOptions'
            );
        }
        // verify the required parameter 'trackingOption' is set
        if ($trackingOption === null || (is_array($trackingOption) && count($trackingOption) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trackingOption when calling createTrackingOptions'
            );
        }

        $resourcePath = '/TrackingCategories/{TrackingCategoryID}/Options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($trackingCategoryID !== null) {
            $resourcePath = str_replace(
                '{' . 'TrackingCategoryID' . '}',
                ObjectSerializer::toPathValue($trackingCategoryID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($trackingOption)) {
            $_tempBody = $trackingOption;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteAccount
     *
     * Allows you to delete a chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Accounts|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function deleteAccount($accountID)
    {
        list($response) = $this->deleteAccountWithHttpInfo($accountID);
        return $response;
    }

    /**
     * Operation deleteAccountWithHttpInfo
     *
     * Allows you to delete a chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Accounts|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAccountWithHttpInfo($accountID)
    {
        $request = $this->deleteAccountRequest($accountID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Accounts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Accounts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Accounts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Accounts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAccountAsync
     *
     * Allows you to delete a chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAccountAsync($accountID)
    {
        return $this->deleteAccountAsyncWithHttpInfo($accountID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAccountAsyncWithHttpInfo
     *
     * Allows you to delete a chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAccountAsyncWithHttpInfo($accountID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Accounts';
        $request = $this->deleteAccountRequest($accountID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAccount'
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function deleteAccountRequest($accountID)
    {
        // verify the required parameter 'accountID' is set
        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountID when calling deleteAccount'
            );
        }

        $resourcePath = '/Accounts/{AccountID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteContactGroupContact
     *
     * Allows you to delete a specific Contact from a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteContactGroupContact($contactGroupID, $contactID)
    {
        $this->deleteContactGroupContactWithHttpInfo($contactGroupID, $contactID);
    }

    /**
     * Operation deleteContactGroupContactWithHttpInfo
     *
     * Allows you to delete a specific Contact from a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContactGroupContactWithHttpInfo($contactGroupID, $contactID)
    {
        $request = $this->deleteContactGroupContactRequest($contactGroupID, $contactID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteContactGroupContactAsync
     *
     * Allows you to delete a specific Contact from a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactGroupContactAsync($contactGroupID, $contactID)
    {
        return $this->deleteContactGroupContactAsyncWithHttpInfo($contactGroupID, $contactID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteContactGroupContactAsyncWithHttpInfo
     *
     * Allows you to delete a specific Contact from a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactGroupContactAsyncWithHttpInfo($contactGroupID, $contactID)
    {
        $returnType = '';
        $request = $this->deleteContactGroupContactRequest($contactGroupID, $contactID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteContactGroupContact'
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function deleteContactGroupContactRequest($contactGroupID, $contactID)
    {
        // verify the required parameter 'contactGroupID' is set
        if ($contactGroupID === null || (is_array($contactGroupID) && count($contactGroupID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactGroupID when calling deleteContactGroupContact'
            );
        }
        // verify the required parameter 'contactID' is set
        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactID when calling deleteContactGroupContact'
            );
        }

        $resourcePath = '/ContactGroups/{ContactGroupID}/Contacts/{ContactID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactGroupID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactGroupID' . '}',
                ObjectSerializer::toPathValue($contactGroupID),
                $resourcePath
            );
        }
        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteContactGroupContacts
     *
     * Allows you to delete  all Contacts from a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteContactGroupContacts($contactGroupID)
    {
        $this->deleteContactGroupContactsWithHttpInfo($contactGroupID);
    }

    /**
     * Operation deleteContactGroupContactsWithHttpInfo
     *
     * Allows you to delete  all Contacts from a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContactGroupContactsWithHttpInfo($contactGroupID)
    {
        $request = $this->deleteContactGroupContactsRequest($contactGroupID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteContactGroupContactsAsync
     *
     * Allows you to delete  all Contacts from a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactGroupContactsAsync($contactGroupID)
    {
        return $this->deleteContactGroupContactsAsyncWithHttpInfo($contactGroupID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteContactGroupContactsAsyncWithHttpInfo
     *
     * Allows you to delete  all Contacts from a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContactGroupContactsAsyncWithHttpInfo($contactGroupID)
    {
        $returnType = '';
        $request = $this->deleteContactGroupContactsRequest($contactGroupID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteContactGroupContacts'
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function deleteContactGroupContactsRequest($contactGroupID)
    {
        // verify the required parameter 'contactGroupID' is set
        if ($contactGroupID === null || (is_array($contactGroupID) && count($contactGroupID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactGroupID when calling deleteContactGroupContacts'
            );
        }

        $resourcePath = '/ContactGroups/{ContactGroupID}/Contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactGroupID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactGroupID' . '}',
                ObjectSerializer::toPathValue($contactGroupID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteItem
     *
     * Allows you to delete a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteItem($itemID)
    {
        $this->deleteItemWithHttpInfo($itemID);
    }

    /**
     * Operation deleteItemWithHttpInfo
     *
     * Allows you to delete a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteItemWithHttpInfo($itemID)
    {
        $request = $this->deleteItemRequest($itemID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteItemAsync
     *
     * Allows you to delete a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteItemAsync($itemID)
    {
        return $this->deleteItemAsyncWithHttpInfo($itemID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteItemAsyncWithHttpInfo
     *
     * Allows you to delete a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteItemAsyncWithHttpInfo($itemID)
    {
        $returnType = '';
        $request = $this->deleteItemRequest($itemID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteItem'
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function deleteItemRequest($itemID)
    {
        // verify the required parameter 'itemID' is set
        if ($itemID === null || (is_array($itemID) && count($itemID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $itemID when calling deleteItem'
            );
        }

        $resourcePath = '/Items/{ItemID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($itemID !== null) {
            $resourcePath = str_replace(
                '{' . 'ItemID' . '}',
                ObjectSerializer::toPathValue($itemID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteLinkedTransaction
     *
     * Allows you to delete a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteLinkedTransaction($linkedTransactionID)
    {
        $this->deleteLinkedTransactionWithHttpInfo($linkedTransactionID);
    }

    /**
     * Operation deleteLinkedTransactionWithHttpInfo
     *
     * Allows you to delete a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteLinkedTransactionWithHttpInfo($linkedTransactionID)
    {
        $request = $this->deleteLinkedTransactionRequest($linkedTransactionID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteLinkedTransactionAsync
     *
     * Allows you to delete a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLinkedTransactionAsync($linkedTransactionID)
    {
        return $this->deleteLinkedTransactionAsyncWithHttpInfo($linkedTransactionID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteLinkedTransactionAsyncWithHttpInfo
     *
     * Allows you to delete a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLinkedTransactionAsyncWithHttpInfo($linkedTransactionID)
    {
        $returnType = '';
        $request = $this->deleteLinkedTransactionRequest($linkedTransactionID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteLinkedTransaction'
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function deleteLinkedTransactionRequest($linkedTransactionID)
    {
        // verify the required parameter 'linkedTransactionID' is set
        if ($linkedTransactionID === null || (is_array($linkedTransactionID) && count($linkedTransactionID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $linkedTransactionID when calling deleteLinkedTransaction'
            );
        }

        $resourcePath = '/LinkedTransactions/{LinkedTransactionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($linkedTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'LinkedTransactionID' . '}',
                ObjectSerializer::toPathValue($linkedTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deletePayment
     *
     * Allows you to update a specified payment for invoices and credit notes
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Payments $payments payments (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Payments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function deletePayment($paymentID, $payments)
    {
        list($response) = $this->deletePaymentWithHttpInfo($paymentID, $payments);
        return $response;
    }

    /**
     * Operation deletePaymentWithHttpInfo
     *
     * Allows you to update a specified payment for invoices and credit notes
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Payments $payments (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Payments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePaymentWithHttpInfo($paymentID, $payments)
    {
        $request = $this->deletePaymentRequest($paymentID, $payments);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Payments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Payments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Payments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Payments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePaymentAsync
     *
     * Allows you to update a specified payment for invoices and credit notes
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Payments $payments (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePaymentAsync($paymentID, $payments)
    {
        return $this->deletePaymentAsyncWithHttpInfo($paymentID, $payments)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePaymentAsyncWithHttpInfo
     *
     * Allows you to update a specified payment for invoices and credit notes
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Payments $payments (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePaymentAsyncWithHttpInfo($paymentID, $payments)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Payments';
        $request = $this->deletePaymentRequest($paymentID, $payments);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePayment'
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Payments $payments (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function deletePaymentRequest($paymentID, $payments)
    {
        // verify the required parameter 'paymentID' is set
        if ($paymentID === null || (is_array($paymentID) && count($paymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $paymentID when calling deletePayment'
            );
        }
        // verify the required parameter 'payments' is set
        if ($payments === null || (is_array($payments) && count($payments) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payments when calling deletePayment'
            );
        }

        $resourcePath = '/Payments/{PaymentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($paymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PaymentID' . '}',
                ObjectSerializer::toPathValue($paymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($payments)) {
            $_tempBody = $payments;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteTrackingCategory
     *
     * Allows you to delete tracking categories
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\TrackingCategories|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function deleteTrackingCategory($trackingCategoryID)
    {
        list($response) = $this->deleteTrackingCategoryWithHttpInfo($trackingCategoryID);
        return $response;
    }

    /**
     * Operation deleteTrackingCategoryWithHttpInfo
     *
     * Allows you to delete tracking categories
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\TrackingCategories|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTrackingCategoryWithHttpInfo($trackingCategoryID)
    {
        $request = $this->deleteTrackingCategoryRequest($trackingCategoryID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\TrackingCategories' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTrackingCategoryAsync
     *
     * Allows you to delete tracking categories
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTrackingCategoryAsync($trackingCategoryID)
    {
        return $this->deleteTrackingCategoryAsyncWithHttpInfo($trackingCategoryID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTrackingCategoryAsyncWithHttpInfo
     *
     * Allows you to delete tracking categories
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTrackingCategoryAsyncWithHttpInfo($trackingCategoryID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories';
        $request = $this->deleteTrackingCategoryRequest($trackingCategoryID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTrackingCategory'
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function deleteTrackingCategoryRequest($trackingCategoryID)
    {
        // verify the required parameter 'trackingCategoryID' is set
        if ($trackingCategoryID === null || (is_array($trackingCategoryID) && count($trackingCategoryID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trackingCategoryID when calling deleteTrackingCategory'
            );
        }

        $resourcePath = '/TrackingCategories/{TrackingCategoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($trackingCategoryID !== null) {
            $resourcePath = str_replace(
                '{' . 'TrackingCategoryID' . '}',
                ObjectSerializer::toPathValue($trackingCategoryID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteTrackingOptions
     *
     * Allows you to delete a specified option for a specified tracking category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  string $trackingOptionID Unique identifier for a Tracking Option (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\TrackingOptions|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function deleteTrackingOptions($trackingCategoryID, $trackingOptionID)
    {
        list($response) = $this->deleteTrackingOptionsWithHttpInfo($trackingCategoryID, $trackingOptionID);
        return $response;
    }

    /**
     * Operation deleteTrackingOptionsWithHttpInfo
     *
     * Allows you to delete a specified option for a specified tracking category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  string $trackingOptionID Unique identifier for a Tracking Option (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\TrackingOptions|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTrackingOptionsWithHttpInfo($trackingCategoryID, $trackingOptionID)
    {
        $request = $this->deleteTrackingOptionsRequest($trackingCategoryID, $trackingOptionID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\TrackingOptions' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\TrackingOptions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingOptions';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\TrackingOptions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTrackingOptionsAsync
     *
     * Allows you to delete a specified option for a specified tracking category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  string $trackingOptionID Unique identifier for a Tracking Option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTrackingOptionsAsync($trackingCategoryID, $trackingOptionID)
    {
        return $this->deleteTrackingOptionsAsyncWithHttpInfo($trackingCategoryID, $trackingOptionID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTrackingOptionsAsyncWithHttpInfo
     *
     * Allows you to delete a specified option for a specified tracking category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  string $trackingOptionID Unique identifier for a Tracking Option (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTrackingOptionsAsyncWithHttpInfo($trackingCategoryID, $trackingOptionID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingOptions';
        $request = $this->deleteTrackingOptionsRequest($trackingCategoryID, $trackingOptionID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTrackingOptions'
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  string $trackingOptionID Unique identifier for a Tracking Option (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function deleteTrackingOptionsRequest($trackingCategoryID, $trackingOptionID)
    {
        // verify the required parameter 'trackingCategoryID' is set
        if ($trackingCategoryID === null || (is_array($trackingCategoryID) && count($trackingCategoryID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trackingCategoryID when calling deleteTrackingOptions'
            );
        }
        // verify the required parameter 'trackingOptionID' is set
        if ($trackingOptionID === null || (is_array($trackingOptionID) && count($trackingOptionID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trackingOptionID when calling deleteTrackingOptions'
            );
        }

        $resourcePath = '/TrackingCategories/{TrackingCategoryID}/Options/{TrackingOptionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($trackingCategoryID !== null) {
            $resourcePath = str_replace(
                '{' . 'TrackingCategoryID' . '}',
                ObjectSerializer::toPathValue($trackingCategoryID),
                $resourcePath
            );
        }
        // path params
        if ($trackingOptionID !== null) {
            $resourcePath = str_replace(
                '{' . 'TrackingOptionID' . '}',
                ObjectSerializer::toPathValue($trackingOptionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation emailInvoice
     *
     * Allows you to email a copy of invoice to related Contact
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\RequestEmpty $requestEmpty requestEmpty (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function emailInvoice($invoiceID, $requestEmpty)
    {
        $this->emailInvoiceWithHttpInfo($invoiceID, $requestEmpty);
    }

    /**
     * Operation emailInvoiceWithHttpInfo
     *
     * Allows you to email a copy of invoice to related Contact
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\RequestEmpty $requestEmpty (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function emailInvoiceWithHttpInfo($invoiceID, $requestEmpty)
    {
        $request = $this->emailInvoiceRequest($invoiceID, $requestEmpty);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation emailInvoiceAsync
     *
     * Allows you to email a copy of invoice to related Contact
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\RequestEmpty $requestEmpty (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function emailInvoiceAsync($invoiceID, $requestEmpty)
    {
        return $this->emailInvoiceAsyncWithHttpInfo($invoiceID, $requestEmpty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation emailInvoiceAsyncWithHttpInfo
     *
     * Allows you to email a copy of invoice to related Contact
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\RequestEmpty $requestEmpty (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function emailInvoiceAsyncWithHttpInfo($invoiceID, $requestEmpty)
    {
        $returnType = '';
        $request = $this->emailInvoiceRequest($invoiceID, $requestEmpty);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'emailInvoice'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\RequestEmpty $requestEmpty (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function emailInvoiceRequest($invoiceID, $requestEmpty)
    {
        // verify the required parameter 'invoiceID' is set
        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceID when calling emailInvoice'
            );
        }
        // verify the required parameter 'requestEmpty' is set
        if ($requestEmpty === null || (is_array($requestEmpty) && count($requestEmpty) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $requestEmpty when calling emailInvoice'
            );
        }

        $resourcePath = '/Invoices/{InvoiceID}/Email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($requestEmpty)) {
            $_tempBody = $requestEmpty;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getAccount
     *
     * Allows you to retrieve a single chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Accounts
     */
    public function getAccount($accountID)
    {
        list($response) = $this->getAccountWithHttpInfo($accountID);
        return $response;
    }

    /**
     * Operation getAccountWithHttpInfo
     *
     * Allows you to retrieve a single chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Accounts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountWithHttpInfo($accountID)
    {
        $request = $this->getAccountRequest($accountID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Accounts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Accounts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Accounts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Accounts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountAsync
     *
     * Allows you to retrieve a single chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAsync($accountID)
    {
        return $this->getAccountAsyncWithHttpInfo($accountID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountAsyncWithHttpInfo
     *
     * Allows you to retrieve a single chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAsyncWithHttpInfo($accountID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Accounts';
        $request = $this->getAccountRequest($accountID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccount'
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getAccountRequest($accountID)
    {
        // verify the required parameter 'accountID' is set
        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountID when calling getAccount'
            );
        }

        $resourcePath = '/Accounts/{AccountID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getAccountAttachmentByFileName
     *
     * Allows you to retrieve Attachment on Account by Filename
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getAccountAttachmentByFileName($accountID, $fileName, $contentType)
    {
        list($response) = $this->getAccountAttachmentByFileNameWithHttpInfo($accountID, $fileName, $contentType);
        return $response;
    }

    /**
     * Operation getAccountAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachment on Account by Filename
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountAttachmentByFileNameWithHttpInfo($accountID, $fileName, $contentType)
    {
        $request = $this->getAccountAttachmentByFileNameRequest($accountID, $fileName, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountAttachmentByFileNameAsync
     *
     * Allows you to retrieve Attachment on Account by Filename
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAttachmentByFileNameAsync($accountID, $fileName, $contentType)
    {
        return $this->getAccountAttachmentByFileNameAsyncWithHttpInfo($accountID, $fileName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachment on Account by Filename
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAttachmentByFileNameAsyncWithHttpInfo($accountID, $fileName, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getAccountAttachmentByFileNameRequest($accountID, $fileName, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountAttachmentByFileName'
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getAccountAttachmentByFileNameRequest($accountID, $fileName, $contentType)
    {
        // verify the required parameter 'accountID' is set
        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountID when calling getAccountAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling getAccountAttachmentByFileName'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getAccountAttachmentByFileName'
            );
        }

        $resourcePath = '/Accounts/{AccountID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getAccountAttachmentById
     *
     * Allows you to retrieve specific Attachment on Account
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $attachmentID Unique identifier for Attachment object (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getAccountAttachmentById($accountID, $attachmentID, $contentType)
    {
        list($response) = $this->getAccountAttachmentByIdWithHttpInfo($accountID, $attachmentID, $contentType);
        return $response;
    }

    /**
     * Operation getAccountAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve specific Attachment on Account
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $attachmentID Unique identifier for Attachment object (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountAttachmentByIdWithHttpInfo($accountID, $attachmentID, $contentType)
    {
        $request = $this->getAccountAttachmentByIdRequest($accountID, $attachmentID, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountAttachmentByIdAsync
     *
     * Allows you to retrieve specific Attachment on Account
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $attachmentID Unique identifier for Attachment object (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAttachmentByIdAsync($accountID, $attachmentID, $contentType)
    {
        return $this->getAccountAttachmentByIdAsyncWithHttpInfo($accountID, $attachmentID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountAttachmentByIdAsyncWithHttpInfo
     *
     * Allows you to retrieve specific Attachment on Account
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $attachmentID Unique identifier for Attachment object (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAttachmentByIdAsyncWithHttpInfo($accountID, $attachmentID, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getAccountAttachmentByIdRequest($accountID, $attachmentID, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountAttachmentById'
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $attachmentID Unique identifier for Attachment object (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getAccountAttachmentByIdRequest($accountID, $attachmentID, $contentType)
    {
        // verify the required parameter 'accountID' is set
        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountID when calling getAccountAttachmentById'
            );
        }
        // verify the required parameter 'attachmentID' is set
        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachmentID when calling getAccountAttachmentById'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getAccountAttachmentById'
            );
        }

        $resourcePath = '/Accounts/{AccountID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getAccountAttachments
     *
     * Allows you to retrieve Attachments for accounts
     *
     * @param  string $accountID Unique identifier for Account object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments
     */
    public function getAccountAttachments($accountID)
    {
        list($response) = $this->getAccountAttachmentsWithHttpInfo($accountID);
        return $response;
    }

    /**
     * Operation getAccountAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachments for accounts
     *
     * @param  string $accountID Unique identifier for Account object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountAttachmentsWithHttpInfo($accountID)
    {
        $request = $this->getAccountAttachmentsRequest($accountID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountAttachmentsAsync
     *
     * Allows you to retrieve Attachments for accounts
     *
     * @param  string $accountID Unique identifier for Account object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAttachmentsAsync($accountID)
    {
        return $this->getAccountAttachmentsAsyncWithHttpInfo($accountID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountAttachmentsAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments for accounts
     *
     * @param  string $accountID Unique identifier for Account object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountAttachmentsAsyncWithHttpInfo($accountID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->getAccountAttachmentsRequest($accountID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountAttachments'
     *
     * @param  string $accountID Unique identifier for Account object (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getAccountAttachmentsRequest($accountID)
    {
        // verify the required parameter 'accountID' is set
        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountID when calling getAccountAttachments'
            );
        }

        $resourcePath = '/Accounts/{AccountID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getAccounts
     *
     * Allows you to retrieve the full chart of accounts
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Accounts
     */
    public function getAccounts($ifModifiedSince = null, $where = null, $order = null)
    {
        list($response) = $this->getAccountsWithHttpInfo($ifModifiedSince, $where, $order);
        return $response;
    }

    /**
     * Operation getAccountsWithHttpInfo
     *
     * Allows you to retrieve the full chart of accounts
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Accounts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getAccountsRequest($ifModifiedSince, $where, $order);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Accounts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Accounts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Accounts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Accounts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountsAsync
     *
     * Allows you to retrieve the full chart of accounts
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountsAsync($ifModifiedSince = null, $where = null, $order = null)
    {
        return $this->getAccountsAsyncWithHttpInfo($ifModifiedSince, $where, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountsAsyncWithHttpInfo
     *
     * Allows you to retrieve the full chart of accounts
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountsAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Accounts';
        $request = $this->getAccountsRequest($ifModifiedSince, $where, $order);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccounts'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getAccountsRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/Accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransaction
     *
     * Allows you to retrieve a single spend or receive money transaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\BankTransactions
     */
    public function getBankTransaction($bankTransactionID)
    {
        list($response) = $this->getBankTransactionWithHttpInfo($bankTransactionID);
        return $response;
    }

    /**
     * Operation getBankTransactionWithHttpInfo
     *
     * Allows you to retrieve a single spend or receive money transaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\BankTransactions, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransactionWithHttpInfo($bankTransactionID)
    {
        $request = $this->getBankTransactionRequest($bankTransactionID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\BankTransactions' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\BankTransactions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransactions';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\BankTransactions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBankTransactionAsync
     *
     * Allows you to retrieve a single spend or receive money transaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransactionAsync($bankTransactionID)
    {
        return $this->getBankTransactionAsyncWithHttpInfo($bankTransactionID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBankTransactionAsyncWithHttpInfo
     *
     * Allows you to retrieve a single spend or receive money transaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransactionAsyncWithHttpInfo($bankTransactionID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransactions';
        $request = $this->getBankTransactionRequest($bankTransactionID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBankTransaction'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBankTransactionRequest($bankTransactionID)
    {
        // verify the required parameter 'bankTransactionID' is set
        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransactionID when calling getBankTransaction'
            );
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransactionAttachmentByFileName
     *
     * Allows you to retrieve Attachments on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getBankTransactionAttachmentByFileName($bankTransactionID, $fileName, $contentType)
    {
        list($response) = $this->getBankTransactionAttachmentByFileNameWithHttpInfo($bankTransactionID, $fileName, $contentType);
        return $response;
    }

    /**
     * Operation getBankTransactionAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachments on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransactionAttachmentByFileNameWithHttpInfo($bankTransactionID, $fileName, $contentType)
    {
        $request = $this->getBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBankTransactionAttachmentByFileNameAsync
     *
     * Allows you to retrieve Attachments on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransactionAttachmentByFileNameAsync($bankTransactionID, $fileName, $contentType)
    {
        return $this->getBankTransactionAttachmentByFileNameAsyncWithHttpInfo($bankTransactionID, $fileName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBankTransactionAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransactionAttachmentByFileNameAsyncWithHttpInfo($bankTransactionID, $fileName, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBankTransactionAttachmentByFileName'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $contentType)
    {
        // verify the required parameter 'bankTransactionID' is set
        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransactionID when calling getBankTransactionAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling getBankTransactionAttachmentByFileName'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getBankTransactionAttachmentByFileName'
            );
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransactionAttachmentById
     *
     * Allows you to retrieve Attachments on a specific BankTransaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $attachmentID Xero generated unique identifier for an attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getBankTransactionAttachmentById($bankTransactionID, $attachmentID, $contentType)
    {
        list($response) = $this->getBankTransactionAttachmentByIdWithHttpInfo($bankTransactionID, $attachmentID, $contentType);
        return $response;
    }

    /**
     * Operation getBankTransactionAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve Attachments on a specific BankTransaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $attachmentID Xero generated unique identifier for an attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransactionAttachmentByIdWithHttpInfo($bankTransactionID, $attachmentID, $contentType)
    {
        $request = $this->getBankTransactionAttachmentByIdRequest($bankTransactionID, $attachmentID, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBankTransactionAttachmentByIdAsync
     *
     * Allows you to retrieve Attachments on a specific BankTransaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $attachmentID Xero generated unique identifier for an attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransactionAttachmentByIdAsync($bankTransactionID, $attachmentID, $contentType)
    {
        return $this->getBankTransactionAttachmentByIdAsyncWithHttpInfo($bankTransactionID, $attachmentID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBankTransactionAttachmentByIdAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments on a specific BankTransaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $attachmentID Xero generated unique identifier for an attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransactionAttachmentByIdAsyncWithHttpInfo($bankTransactionID, $attachmentID, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getBankTransactionAttachmentByIdRequest($bankTransactionID, $attachmentID, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBankTransactionAttachmentById'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $attachmentID Xero generated unique identifier for an attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBankTransactionAttachmentByIdRequest($bankTransactionID, $attachmentID, $contentType)
    {
        // verify the required parameter 'bankTransactionID' is set
        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransactionID when calling getBankTransactionAttachmentById'
            );
        }
        // verify the required parameter 'attachmentID' is set
        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachmentID when calling getBankTransactionAttachmentById'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getBankTransactionAttachmentById'
            );
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransactionAttachments
     *
     * Allows you to retrieve any attachments to bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments
     */
    public function getBankTransactionAttachments($bankTransactionID)
    {
        list($response) = $this->getBankTransactionAttachmentsWithHttpInfo($bankTransactionID);
        return $response;
    }

    /**
     * Operation getBankTransactionAttachmentsWithHttpInfo
     *
     * Allows you to retrieve any attachments to bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransactionAttachmentsWithHttpInfo($bankTransactionID)
    {
        $request = $this->getBankTransactionAttachmentsRequest($bankTransactionID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBankTransactionAttachmentsAsync
     *
     * Allows you to retrieve any attachments to bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransactionAttachmentsAsync($bankTransactionID)
    {
        return $this->getBankTransactionAttachmentsAsyncWithHttpInfo($bankTransactionID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBankTransactionAttachmentsAsyncWithHttpInfo
     *
     * Allows you to retrieve any attachments to bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransactionAttachmentsAsyncWithHttpInfo($bankTransactionID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->getBankTransactionAttachmentsRequest($bankTransactionID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBankTransactionAttachments'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBankTransactionAttachmentsRequest($bankTransactionID)
    {
        // verify the required parameter 'bankTransactionID' is set
        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransactionID when calling getBankTransactionAttachments'
            );
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransactions
     *
     * Allows you to retrieve any spend or receive money transactions
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 bank transactions will be returned in a single API call with line items shown for each bank transaction (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\BankTransactions
     */
    public function getBankTransactions($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        list($response) = $this->getBankTransactionsWithHttpInfo($ifModifiedSince, $where, $order, $page, $unitdp);
        return $response;
    }

    /**
     * Operation getBankTransactionsWithHttpInfo
     *
     * Allows you to retrieve any spend or receive money transactions
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 bank transactions will be returned in a single API call with line items shown for each bank transaction (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\BankTransactions, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransactionsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        $request = $this->getBankTransactionsRequest($ifModifiedSince, $where, $order, $page, $unitdp);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\BankTransactions' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\BankTransactions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransactions';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\BankTransactions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBankTransactionsAsync
     *
     * Allows you to retrieve any spend or receive money transactions
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 bank transactions will be returned in a single API call with line items shown for each bank transaction (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransactionsAsync($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        return $this->getBankTransactionsAsyncWithHttpInfo($ifModifiedSince, $where, $order, $page, $unitdp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBankTransactionsAsyncWithHttpInfo
     *
     * Allows you to retrieve any spend or receive money transactions
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 bank transactions will be returned in a single API call with line items shown for each bank transaction (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransactionsAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransactions';
        $request = $this->getBankTransactionsRequest($ifModifiedSince, $where, $order, $page, $unitdp);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBankTransactions'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 bank transactions will be returned in a single API call with line items shown for each bank transaction (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBankTransactionsRequest($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {

        $resourcePath = '/BankTransactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($unitdp !== null) {
            $queryParams['unitdp'] = ObjectSerializer::toQueryValue($unitdp);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransactionsHistory
     *
     * Allows you to retrieve history from a bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getBankTransactionsHistory($bankTransactionID)
    {
        list($response) = $this->getBankTransactionsHistoryWithHttpInfo($bankTransactionID);
        return $response;
    }

    /**
     * Operation getBankTransactionsHistoryWithHttpInfo
     *
     * Allows you to retrieve history from a bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransactionsHistoryWithHttpInfo($bankTransactionID)
    {
        $request = $this->getBankTransactionsHistoryRequest($bankTransactionID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBankTransactionsHistoryAsync
     *
     * Allows you to retrieve history from a bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransactionsHistoryAsync($bankTransactionID)
    {
        return $this->getBankTransactionsHistoryAsyncWithHttpInfo($bankTransactionID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBankTransactionsHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve history from a bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransactionsHistoryAsyncWithHttpInfo($bankTransactionID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getBankTransactionsHistoryRequest($bankTransactionID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBankTransactionsHistory'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBankTransactionsHistoryRequest($bankTransactionID)
    {
        // verify the required parameter 'bankTransactionID' is set
        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransactionID when calling getBankTransactionsHistory'
            );
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransfer
     *
     * Allows you to retrieve any bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\BankTransfers
     */
    public function getBankTransfer($bankTransferID)
    {
        list($response) = $this->getBankTransferWithHttpInfo($bankTransferID);
        return $response;
    }

    /**
     * Operation getBankTransferWithHttpInfo
     *
     * Allows you to retrieve any bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\BankTransfers, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransferWithHttpInfo($bankTransferID)
    {
        $request = $this->getBankTransferRequest($bankTransferID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\BankTransfers' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\BankTransfers', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransfers';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\BankTransfers',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBankTransferAsync
     *
     * Allows you to retrieve any bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransferAsync($bankTransferID)
    {
        return $this->getBankTransferAsyncWithHttpInfo($bankTransferID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBankTransferAsyncWithHttpInfo
     *
     * Allows you to retrieve any bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransferAsyncWithHttpInfo($bankTransferID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransfers';
        $request = $this->getBankTransferRequest($bankTransferID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBankTransfer'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBankTransferRequest($bankTransferID)
    {
        // verify the required parameter 'bankTransferID' is set
        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransferID when calling getBankTransfer'
            );
        }

        $resourcePath = '/BankTransfers/{BankTransferID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransferAttachmentByFileName
     *
     * Allows you to retrieve Attachments on BankTransfer by file name
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getBankTransferAttachmentByFileName($bankTransferID, $fileName, $contentType)
    {
        list($response) = $this->getBankTransferAttachmentByFileNameWithHttpInfo($bankTransferID, $fileName, $contentType);
        return $response;
    }

    /**
     * Operation getBankTransferAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachments on BankTransfer by file name
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransferAttachmentByFileNameWithHttpInfo($bankTransferID, $fileName, $contentType)
    {
        $request = $this->getBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBankTransferAttachmentByFileNameAsync
     *
     * Allows you to retrieve Attachments on BankTransfer by file name
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransferAttachmentByFileNameAsync($bankTransferID, $fileName, $contentType)
    {
        return $this->getBankTransferAttachmentByFileNameAsyncWithHttpInfo($bankTransferID, $fileName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBankTransferAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments on BankTransfer by file name
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransferAttachmentByFileNameAsyncWithHttpInfo($bankTransferID, $fileName, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBankTransferAttachmentByFileName'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $contentType)
    {
        // verify the required parameter 'bankTransferID' is set
        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransferID when calling getBankTransferAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling getBankTransferAttachmentByFileName'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getBankTransferAttachmentByFileName'
            );
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransferAttachmentById
     *
     * Allows you to retrieve Attachments on BankTransfer
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $attachmentID Xero generated unique identifier for an Attachment to a bank transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getBankTransferAttachmentById($bankTransferID, $attachmentID, $contentType)
    {
        list($response) = $this->getBankTransferAttachmentByIdWithHttpInfo($bankTransferID, $attachmentID, $contentType);
        return $response;
    }

    /**
     * Operation getBankTransferAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve Attachments on BankTransfer
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $attachmentID Xero generated unique identifier for an Attachment to a bank transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransferAttachmentByIdWithHttpInfo($bankTransferID, $attachmentID, $contentType)
    {
        $request = $this->getBankTransferAttachmentByIdRequest($bankTransferID, $attachmentID, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBankTransferAttachmentByIdAsync
     *
     * Allows you to retrieve Attachments on BankTransfer
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $attachmentID Xero generated unique identifier for an Attachment to a bank transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransferAttachmentByIdAsync($bankTransferID, $attachmentID, $contentType)
    {
        return $this->getBankTransferAttachmentByIdAsyncWithHttpInfo($bankTransferID, $attachmentID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBankTransferAttachmentByIdAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments on BankTransfer
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $attachmentID Xero generated unique identifier for an Attachment to a bank transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransferAttachmentByIdAsyncWithHttpInfo($bankTransferID, $attachmentID, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getBankTransferAttachmentByIdRequest($bankTransferID, $attachmentID, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBankTransferAttachmentById'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $attachmentID Xero generated unique identifier for an Attachment to a bank transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBankTransferAttachmentByIdRequest($bankTransferID, $attachmentID, $contentType)
    {
        // verify the required parameter 'bankTransferID' is set
        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransferID when calling getBankTransferAttachmentById'
            );
        }
        // verify the required parameter 'attachmentID' is set
        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachmentID when calling getBankTransferAttachmentById'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getBankTransferAttachmentById'
            );
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransferAttachments
     *
     * Allows you to retrieve Attachments from  bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments
     */
    public function getBankTransferAttachments($bankTransferID)
    {
        list($response) = $this->getBankTransferAttachmentsWithHttpInfo($bankTransferID);
        return $response;
    }

    /**
     * Operation getBankTransferAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachments from  bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransferAttachmentsWithHttpInfo($bankTransferID)
    {
        $request = $this->getBankTransferAttachmentsRequest($bankTransferID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBankTransferAttachmentsAsync
     *
     * Allows you to retrieve Attachments from  bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransferAttachmentsAsync($bankTransferID)
    {
        return $this->getBankTransferAttachmentsAsyncWithHttpInfo($bankTransferID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBankTransferAttachmentsAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments from  bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransferAttachmentsAsyncWithHttpInfo($bankTransferID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->getBankTransferAttachmentsRequest($bankTransferID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBankTransferAttachments'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBankTransferAttachmentsRequest($bankTransferID)
    {
        // verify the required parameter 'bankTransferID' is set
        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransferID when calling getBankTransferAttachments'
            );
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransferHistory
     *
     * Allows you to retrieve history from a bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getBankTransferHistory($bankTransferID)
    {
        list($response) = $this->getBankTransferHistoryWithHttpInfo($bankTransferID);
        return $response;
    }

    /**
     * Operation getBankTransferHistoryWithHttpInfo
     *
     * Allows you to retrieve history from a bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransferHistoryWithHttpInfo($bankTransferID)
    {
        $request = $this->getBankTransferHistoryRequest($bankTransferID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBankTransferHistoryAsync
     *
     * Allows you to retrieve history from a bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransferHistoryAsync($bankTransferID)
    {
        return $this->getBankTransferHistoryAsyncWithHttpInfo($bankTransferID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBankTransferHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve history from a bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransferHistoryAsyncWithHttpInfo($bankTransferID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getBankTransferHistoryRequest($bankTransferID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBankTransferHistory'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBankTransferHistoryRequest($bankTransferID)
    {
        // verify the required parameter 'bankTransferID' is set
        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransferID when calling getBankTransferHistory'
            );
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransfers
     *
     * Allows you to retrieve all bank transfers
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\BankTransfers
     */
    public function getBankTransfers($ifModifiedSince = null, $where = null, $order = null)
    {
        list($response) = $this->getBankTransfersWithHttpInfo($ifModifiedSince, $where, $order);
        return $response;
    }

    /**
     * Operation getBankTransfersWithHttpInfo
     *
     * Allows you to retrieve all bank transfers
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\BankTransfers, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransfersWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getBankTransfersRequest($ifModifiedSince, $where, $order);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\BankTransfers' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\BankTransfers', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransfers';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\BankTransfers',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBankTransfersAsync
     *
     * Allows you to retrieve all bank transfers
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransfersAsync($ifModifiedSince = null, $where = null, $order = null)
    {
        return $this->getBankTransfersAsyncWithHttpInfo($ifModifiedSince, $where, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBankTransfersAsyncWithHttpInfo
     *
     * Allows you to retrieve all bank transfers
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBankTransfersAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransfers';
        $request = $this->getBankTransfersRequest($ifModifiedSince, $where, $order);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBankTransfers'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBankTransfersRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/BankTransfers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBatchPaymentHistory
     *
     * Allows you to retrieve history from a Batch Payment
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getBatchPaymentHistory($batchPaymentID)
    {
        list($response) = $this->getBatchPaymentHistoryWithHttpInfo($batchPaymentID);
        return $response;
    }

    /**
     * Operation getBatchPaymentHistoryWithHttpInfo
     *
     * Allows you to retrieve history from a Batch Payment
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBatchPaymentHistoryWithHttpInfo($batchPaymentID)
    {
        $request = $this->getBatchPaymentHistoryRequest($batchPaymentID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBatchPaymentHistoryAsync
     *
     * Allows you to retrieve history from a Batch Payment
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBatchPaymentHistoryAsync($batchPaymentID)
    {
        return $this->getBatchPaymentHistoryAsyncWithHttpInfo($batchPaymentID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBatchPaymentHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve history from a Batch Payment
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBatchPaymentHistoryAsyncWithHttpInfo($batchPaymentID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getBatchPaymentHistoryRequest($batchPaymentID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBatchPaymentHistory'
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBatchPaymentHistoryRequest($batchPaymentID)
    {
        // verify the required parameter 'batchPaymentID' is set
        if ($batchPaymentID === null || (is_array($batchPaymentID) && count($batchPaymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batchPaymentID when calling getBatchPaymentHistory'
            );
        }

        $resourcePath = '/BatchPayments/{BatchPaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($batchPaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'BatchPaymentID' . '}',
                ObjectSerializer::toPathValue($batchPaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBatchPayments
     *
     * Retrieve either one or many BatchPayments for invoices
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\BatchPayments
     */
    public function getBatchPayments($ifModifiedSince = null, $where = null, $order = null)
    {
        list($response) = $this->getBatchPaymentsWithHttpInfo($ifModifiedSince, $where, $order);
        return $response;
    }

    /**
     * Operation getBatchPaymentsWithHttpInfo
     *
     * Retrieve either one or many BatchPayments for invoices
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\BatchPayments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBatchPaymentsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getBatchPaymentsRequest($ifModifiedSince, $where, $order);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\BatchPayments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\BatchPayments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\BatchPayments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\BatchPayments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBatchPaymentsAsync
     *
     * Retrieve either one or many BatchPayments for invoices
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBatchPaymentsAsync($ifModifiedSince = null, $where = null, $order = null)
    {
        return $this->getBatchPaymentsAsyncWithHttpInfo($ifModifiedSince, $where, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBatchPaymentsAsyncWithHttpInfo
     *
     * Retrieve either one or many BatchPayments for invoices
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBatchPaymentsAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\BatchPayments';
        $request = $this->getBatchPaymentsRequest($ifModifiedSince, $where, $order);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBatchPayments'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBatchPaymentsRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/BatchPayments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBrandingTheme
     *
     * Allows you to retrieve a specific BrandingThemes
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\BrandingThemes
     */
    public function getBrandingTheme($brandingThemeID)
    {
        list($response) = $this->getBrandingThemeWithHttpInfo($brandingThemeID);
        return $response;
    }

    /**
     * Operation getBrandingThemeWithHttpInfo
     *
     * Allows you to retrieve a specific BrandingThemes
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\BrandingThemes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandingThemeWithHttpInfo($brandingThemeID)
    {
        $request = $this->getBrandingThemeRequest($brandingThemeID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\BrandingThemes' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\BrandingThemes', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\BrandingThemes';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\BrandingThemes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBrandingThemeAsync
     *
     * Allows you to retrieve a specific BrandingThemes
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandingThemeAsync($brandingThemeID)
    {
        return $this->getBrandingThemeAsyncWithHttpInfo($brandingThemeID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBrandingThemeAsyncWithHttpInfo
     *
     * Allows you to retrieve a specific BrandingThemes
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandingThemeAsyncWithHttpInfo($brandingThemeID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\BrandingThemes';
        $request = $this->getBrandingThemeRequest($brandingThemeID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBrandingTheme'
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBrandingThemeRequest($brandingThemeID)
    {
        // verify the required parameter 'brandingThemeID' is set
        if ($brandingThemeID === null || (is_array($brandingThemeID) && count($brandingThemeID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $brandingThemeID when calling getBrandingTheme'
            );
        }

        $resourcePath = '/BrandingThemes/{BrandingThemeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($brandingThemeID !== null) {
            $resourcePath = str_replace(
                '{' . 'BrandingThemeID' . '}',
                ObjectSerializer::toPathValue($brandingThemeID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBrandingThemePaymentServices
     *
     * Allows you to retrieve the Payment services for a Branding Theme
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\PaymentServices
     */
    public function getBrandingThemePaymentServices($brandingThemeID)
    {
        list($response) = $this->getBrandingThemePaymentServicesWithHttpInfo($brandingThemeID);
        return $response;
    }

    /**
     * Operation getBrandingThemePaymentServicesWithHttpInfo
     *
     * Allows you to retrieve the Payment services for a Branding Theme
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\PaymentServices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandingThemePaymentServicesWithHttpInfo($brandingThemeID)
    {
        $request = $this->getBrandingThemePaymentServicesRequest($brandingThemeID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\PaymentServices' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\PaymentServices', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\PaymentServices';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\PaymentServices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBrandingThemePaymentServicesAsync
     *
     * Allows you to retrieve the Payment services for a Branding Theme
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandingThemePaymentServicesAsync($brandingThemeID)
    {
        return $this->getBrandingThemePaymentServicesAsyncWithHttpInfo($brandingThemeID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBrandingThemePaymentServicesAsyncWithHttpInfo
     *
     * Allows you to retrieve the Payment services for a Branding Theme
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandingThemePaymentServicesAsyncWithHttpInfo($brandingThemeID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\PaymentServices';
        $request = $this->getBrandingThemePaymentServicesRequest($brandingThemeID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBrandingThemePaymentServices'
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBrandingThemePaymentServicesRequest($brandingThemeID)
    {
        // verify the required parameter 'brandingThemeID' is set
        if ($brandingThemeID === null || (is_array($brandingThemeID) && count($brandingThemeID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $brandingThemeID when calling getBrandingThemePaymentServices'
            );
        }

        $resourcePath = '/BrandingThemes/{BrandingThemeID}/PaymentServices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($brandingThemeID !== null) {
            $resourcePath = str_replace(
                '{' . 'BrandingThemeID' . '}',
                ObjectSerializer::toPathValue($brandingThemeID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBrandingThemes
     *
     * Allows you to retrieve all the BrandingThemes
     *
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\BrandingThemes
     */
    public function getBrandingThemes()
    {
        list($response) = $this->getBrandingThemesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getBrandingThemesWithHttpInfo
     *
     * Allows you to retrieve all the BrandingThemes
     *
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\BrandingThemes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandingThemesWithHttpInfo()
    {
        $request = $this->getBrandingThemesRequest();

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\BrandingThemes' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\BrandingThemes', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\BrandingThemes';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\BrandingThemes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBrandingThemesAsync
     *
     * Allows you to retrieve all the BrandingThemes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandingThemesAsync()
    {
        return $this->getBrandingThemesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBrandingThemesAsyncWithHttpInfo
     *
     * Allows you to retrieve all the BrandingThemes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandingThemesAsyncWithHttpInfo()
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\BrandingThemes';
        $request = $this->getBrandingThemesRequest();

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBrandingThemes'
     *
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getBrandingThemesRequest()
    {

        $resourcePath = '/BrandingThemes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContact
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Contacts
     */
    public function getContact($contactID)
    {
        list($response) = $this->getContactWithHttpInfo($contactID);
        return $response;
    }

    /**
     * Operation getContactWithHttpInfo
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Contacts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactWithHttpInfo($contactID)
    {
        $request = $this->getContactRequest($contactID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Contacts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Contacts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Contacts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Contacts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAsync
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactAsync($contactID)
    {
        return $this->getContactAsyncWithHttpInfo($contactID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAsyncWithHttpInfo
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactAsyncWithHttpInfo($contactID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Contacts';
        $request = $this->getContactRequest($contactID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContact'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getContactRequest($contactID)
    {
        // verify the required parameter 'contactID' is set
        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactID when calling getContact'
            );
        }

        $resourcePath = '/Contacts/{ContactID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactAttachmentByFileName
     *
     * Allows you to retrieve Attachments on Contacts by file name
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getContactAttachmentByFileName($contactID, $fileName, $contentType)
    {
        list($response) = $this->getContactAttachmentByFileNameWithHttpInfo($contactID, $fileName, $contentType);
        return $response;
    }

    /**
     * Operation getContactAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachments on Contacts by file name
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAttachmentByFileNameWithHttpInfo($contactID, $fileName, $contentType)
    {
        $request = $this->getContactAttachmentByFileNameRequest($contactID, $fileName, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAttachmentByFileNameAsync
     *
     * Allows you to retrieve Attachments on Contacts by file name
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactAttachmentByFileNameAsync($contactID, $fileName, $contentType)
    {
        return $this->getContactAttachmentByFileNameAsyncWithHttpInfo($contactID, $fileName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments on Contacts by file name
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactAttachmentByFileNameAsyncWithHttpInfo($contactID, $fileName, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getContactAttachmentByFileNameRequest($contactID, $fileName, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactAttachmentByFileName'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getContactAttachmentByFileNameRequest($contactID, $fileName, $contentType)
    {
        // verify the required parameter 'contactID' is set
        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactID when calling getContactAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling getContactAttachmentByFileName'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getContactAttachmentByFileName'
            );
        }

        $resourcePath = '/Contacts/{ContactID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactAttachmentById
     *
     * Allows you to retrieve Attachments on Contacts
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getContactAttachmentById($contactID, $attachmentID, $contentType)
    {
        list($response) = $this->getContactAttachmentByIdWithHttpInfo($contactID, $attachmentID, $contentType);
        return $response;
    }

    /**
     * Operation getContactAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve Attachments on Contacts
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAttachmentByIdWithHttpInfo($contactID, $attachmentID, $contentType)
    {
        $request = $this->getContactAttachmentByIdRequest($contactID, $attachmentID, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAttachmentByIdAsync
     *
     * Allows you to retrieve Attachments on Contacts
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactAttachmentByIdAsync($contactID, $attachmentID, $contentType)
    {
        return $this->getContactAttachmentByIdAsyncWithHttpInfo($contactID, $attachmentID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAttachmentByIdAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments on Contacts
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactAttachmentByIdAsyncWithHttpInfo($contactID, $attachmentID, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getContactAttachmentByIdRequest($contactID, $attachmentID, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactAttachmentById'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getContactAttachmentByIdRequest($contactID, $attachmentID, $contentType)
    {
        // verify the required parameter 'contactID' is set
        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactID when calling getContactAttachmentById'
            );
        }
        // verify the required parameter 'attachmentID' is set
        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachmentID when calling getContactAttachmentById'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getContactAttachmentById'
            );
        }

        $resourcePath = '/Contacts/{ContactID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactAttachments
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments
     */
    public function getContactAttachments($contactID)
    {
        list($response) = $this->getContactAttachmentsWithHttpInfo($contactID);
        return $response;
    }

    /**
     * Operation getContactAttachmentsWithHttpInfo
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAttachmentsWithHttpInfo($contactID)
    {
        $request = $this->getContactAttachmentsRequest($contactID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAttachmentsAsync
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactAttachmentsAsync($contactID)
    {
        return $this->getContactAttachmentsAsyncWithHttpInfo($contactID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAttachmentsAsyncWithHttpInfo
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactAttachmentsAsyncWithHttpInfo($contactID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->getContactAttachmentsRequest($contactID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactAttachments'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getContactAttachmentsRequest($contactID)
    {
        // verify the required parameter 'contactID' is set
        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactID when calling getContactAttachments'
            );
        }

        $resourcePath = '/Contacts/{ContactID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactCISSettings
     *
     * Allows you to retrieve CISSettings for a contact in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\CISSettings
     */
    public function getContactCISSettings($contactID)
    {
        list($response) = $this->getContactCISSettingsWithHttpInfo($contactID);
        return $response;
    }

    /**
     * Operation getContactCISSettingsWithHttpInfo
     *
     * Allows you to retrieve CISSettings for a contact in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\CISSettings, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactCISSettingsWithHttpInfo($contactID)
    {
        $request = $this->getContactCISSettingsRequest($contactID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\CISSettings' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\CISSettings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\CISSettings';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\CISSettings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactCISSettingsAsync
     *
     * Allows you to retrieve CISSettings for a contact in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactCISSettingsAsync($contactID)
    {
        return $this->getContactCISSettingsAsyncWithHttpInfo($contactID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactCISSettingsAsyncWithHttpInfo
     *
     * Allows you to retrieve CISSettings for a contact in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactCISSettingsAsyncWithHttpInfo($contactID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\CISSettings';
        $request = $this->getContactCISSettingsRequest($contactID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactCISSettings'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getContactCISSettingsRequest($contactID)
    {
        // verify the required parameter 'contactID' is set
        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactID when calling getContactCISSettings'
            );
        }

        $resourcePath = '/Contacts/{ContactID}/CISSettings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactGroup
     *
     * Allows you to retrieve a unique Contract Group by ID
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ContactGroups
     */
    public function getContactGroup($contactGroupID)
    {
        list($response) = $this->getContactGroupWithHttpInfo($contactGroupID);
        return $response;
    }

    /**
     * Operation getContactGroupWithHttpInfo
     *
     * Allows you to retrieve a unique Contract Group by ID
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ContactGroups, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactGroupWithHttpInfo($contactGroupID)
    {
        $request = $this->getContactGroupRequest($contactGroupID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ContactGroups' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ContactGroups', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ContactGroups';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ContactGroups',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactGroupAsync
     *
     * Allows you to retrieve a unique Contract Group by ID
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactGroupAsync($contactGroupID)
    {
        return $this->getContactGroupAsyncWithHttpInfo($contactGroupID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactGroupAsyncWithHttpInfo
     *
     * Allows you to retrieve a unique Contract Group by ID
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactGroupAsyncWithHttpInfo($contactGroupID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ContactGroups';
        $request = $this->getContactGroupRequest($contactGroupID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactGroup'
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getContactGroupRequest($contactGroupID)
    {
        // verify the required parameter 'contactGroupID' is set
        if ($contactGroupID === null || (is_array($contactGroupID) && count($contactGroupID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactGroupID when calling getContactGroup'
            );
        }

        $resourcePath = '/ContactGroups/{ContactGroupID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactGroupID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactGroupID' . '}',
                ObjectSerializer::toPathValue($contactGroupID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactGroups
     *
     * Allows you to retrieve the ContactID and Name of all the contacts in a contact group
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ContactGroups
     */
    public function getContactGroups($where = null, $order = null)
    {
        list($response) = $this->getContactGroupsWithHttpInfo($where, $order);
        return $response;
    }

    /**
     * Operation getContactGroupsWithHttpInfo
     *
     * Allows you to retrieve the ContactID and Name of all the contacts in a contact group
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ContactGroups, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactGroupsWithHttpInfo($where = null, $order = null)
    {
        $request = $this->getContactGroupsRequest($where, $order);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ContactGroups' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ContactGroups', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ContactGroups';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ContactGroups',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactGroupsAsync
     *
     * Allows you to retrieve the ContactID and Name of all the contacts in a contact group
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactGroupsAsync($where = null, $order = null)
    {
        return $this->getContactGroupsAsyncWithHttpInfo($where, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactGroupsAsyncWithHttpInfo
     *
     * Allows you to retrieve the ContactID and Name of all the contacts in a contact group
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactGroupsAsyncWithHttpInfo($where = null, $order = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ContactGroups';
        $request = $this->getContactGroupsRequest($where, $order);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactGroups'
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getContactGroupsRequest($where = null, $order = null)
    {

        $resourcePath = '/ContactGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactHistory
     *
     * Allows you to retrieve a history records of an Contact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getContactHistory($contactID)
    {
        list($response) = $this->getContactHistoryWithHttpInfo($contactID);
        return $response;
    }

    /**
     * Operation getContactHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an Contact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactHistoryWithHttpInfo($contactID)
    {
        $request = $this->getContactHistoryRequest($contactID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactHistoryAsync
     *
     * Allows you to retrieve a history records of an Contact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactHistoryAsync($contactID)
    {
        return $this->getContactHistoryAsyncWithHttpInfo($contactID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve a history records of an Contact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactHistoryAsyncWithHttpInfo($contactID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getContactHistoryRequest($contactID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactHistory'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getContactHistoryRequest($contactID)
    {
        // verify the required parameter 'contactID' is set
        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactID when calling getContactHistory'
            );
        }

        $resourcePath = '/Contacts/{ContactID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContacts
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call. (optional)
     * @param  int $page e.g. page&#x3D;1 - Up to 100 contacts will be returned in a single API call. (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Contacts
     */
    public function getContacts($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $page = null, $includeArchived = null)
    {
        list($response) = $this->getContactsWithHttpInfo($ifModifiedSince, $where, $order, $iDs, $page, $includeArchived);
        return $response;
    }

    /**
     * Operation getContactsWithHttpInfo
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call. (optional)
     * @param  int $page e.g. page&#x3D;1 - Up to 100 contacts will be returned in a single API call. (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Contacts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $page = null, $includeArchived = null)
    {
        $request = $this->getContactsRequest($ifModifiedSince, $where, $order, $iDs, $page, $includeArchived);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Contacts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Contacts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Contacts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Contacts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactsAsync
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call. (optional)
     * @param  int $page e.g. page&#x3D;1 - Up to 100 contacts will be returned in a single API call. (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactsAsync($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $page = null, $includeArchived = null)
    {
        return $this->getContactsAsyncWithHttpInfo($ifModifiedSince, $where, $order, $iDs, $page, $includeArchived)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactsAsyncWithHttpInfo
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call. (optional)
     * @param  int $page e.g. page&#x3D;1 - Up to 100 contacts will be returned in a single API call. (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContactsAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $page = null, $includeArchived = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Contacts';
        $request = $this->getContactsRequest($ifModifiedSince, $where, $order, $iDs, $page, $includeArchived);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContacts'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call. (optional)
     * @param  int $page e.g. page&#x3D;1 - Up to 100 contacts will be returned in a single API call. (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getContactsRequest($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $page = null, $includeArchived = null)
    {

        $resourcePath = '/Contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($iDs !== null) {
            $queryParams['IDs'] = ObjectSerializer::toQueryValue($iDs);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($includeArchived !== null) {
            $queryParams['includeArchived'] = ObjectSerializer::toQueryValue($includeArchived);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNote
     *
     * Allows you to retrieve a specific credit note
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\CreditNotes
     */
    public function getCreditNote($creditNoteID)
    {
        list($response) = $this->getCreditNoteWithHttpInfo($creditNoteID);
        return $response;
    }

    /**
     * Operation getCreditNoteWithHttpInfo
     *
     * Allows you to retrieve a specific credit note
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\CreditNotes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNoteWithHttpInfo($creditNoteID)
    {
        $request = $this->getCreditNoteRequest($creditNoteID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\CreditNotes' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\CreditNotes', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\CreditNotes';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\CreditNotes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCreditNoteAsync
     *
     * Allows you to retrieve a specific credit note
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteAsync($creditNoteID)
    {
        return $this->getCreditNoteAsyncWithHttpInfo($creditNoteID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCreditNoteAsyncWithHttpInfo
     *
     * Allows you to retrieve a specific credit note
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteAsyncWithHttpInfo($creditNoteID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\CreditNotes';
        $request = $this->getCreditNoteRequest($creditNoteID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCreditNote'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getCreditNoteRequest($creditNoteID)
    {
        // verify the required parameter 'creditNoteID' is set
        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $creditNoteID when calling getCreditNote'
            );
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNoteAsPdf
     *
     * Allows you to retrieve Credit Note as PDF files
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getCreditNoteAsPdf($creditNoteID, $contentType)
    {
        list($response) = $this->getCreditNoteAsPdfWithHttpInfo($creditNoteID, $contentType);
        return $response;
    }

    /**
     * Operation getCreditNoteAsPdfWithHttpInfo
     *
     * Allows you to retrieve Credit Note as PDF files
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNoteAsPdfWithHttpInfo($creditNoteID, $contentType)
    {
        $request = $this->getCreditNoteAsPdfRequest($creditNoteID, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCreditNoteAsPdfAsync
     *
     * Allows you to retrieve Credit Note as PDF files
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteAsPdfAsync($creditNoteID, $contentType)
    {
        return $this->getCreditNoteAsPdfAsyncWithHttpInfo($creditNoteID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCreditNoteAsPdfAsyncWithHttpInfo
     *
     * Allows you to retrieve Credit Note as PDF files
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteAsPdfAsyncWithHttpInfo($creditNoteID, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getCreditNoteAsPdfRequest($creditNoteID, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCreditNoteAsPdf'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getCreditNoteAsPdfRequest($creditNoteID, $contentType)
    {
        // verify the required parameter 'creditNoteID' is set
        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $creditNoteID when calling getCreditNoteAsPdf'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getCreditNoteAsPdf'
            );
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNoteAttachmentByFileName
     *
     * Allows you to retrieve Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getCreditNoteAttachmentByFileName($creditNoteID, $fileName, $contentType)
    {
        list($response) = $this->getCreditNoteAttachmentByFileNameWithHttpInfo($creditNoteID, $fileName, $contentType);
        return $response;
    }

    /**
     * Operation getCreditNoteAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNoteAttachmentByFileNameWithHttpInfo($creditNoteID, $fileName, $contentType)
    {
        $request = $this->getCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCreditNoteAttachmentByFileNameAsync
     *
     * Allows you to retrieve Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteAttachmentByFileNameAsync($creditNoteID, $fileName, $contentType)
    {
        return $this->getCreditNoteAttachmentByFileNameAsyncWithHttpInfo($creditNoteID, $fileName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCreditNoteAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteAttachmentByFileNameAsyncWithHttpInfo($creditNoteID, $fileName, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCreditNoteAttachmentByFileName'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $contentType)
    {
        // verify the required parameter 'creditNoteID' is set
        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $creditNoteID when calling getCreditNoteAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling getCreditNoteAttachmentByFileName'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getCreditNoteAttachmentByFileName'
            );
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNoteAttachmentById
     *
     * Allows you to retrieve Attachments on CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getCreditNoteAttachmentById($creditNoteID, $attachmentID, $contentType)
    {
        list($response) = $this->getCreditNoteAttachmentByIdWithHttpInfo($creditNoteID, $attachmentID, $contentType);
        return $response;
    }

    /**
     * Operation getCreditNoteAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve Attachments on CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNoteAttachmentByIdWithHttpInfo($creditNoteID, $attachmentID, $contentType)
    {
        $request = $this->getCreditNoteAttachmentByIdRequest($creditNoteID, $attachmentID, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCreditNoteAttachmentByIdAsync
     *
     * Allows you to retrieve Attachments on CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteAttachmentByIdAsync($creditNoteID, $attachmentID, $contentType)
    {
        return $this->getCreditNoteAttachmentByIdAsyncWithHttpInfo($creditNoteID, $attachmentID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCreditNoteAttachmentByIdAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments on CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteAttachmentByIdAsyncWithHttpInfo($creditNoteID, $attachmentID, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getCreditNoteAttachmentByIdRequest($creditNoteID, $attachmentID, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCreditNoteAttachmentById'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getCreditNoteAttachmentByIdRequest($creditNoteID, $attachmentID, $contentType)
    {
        // verify the required parameter 'creditNoteID' is set
        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $creditNoteID when calling getCreditNoteAttachmentById'
            );
        }
        // verify the required parameter 'attachmentID' is set
        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachmentID when calling getCreditNoteAttachmentById'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getCreditNoteAttachmentById'
            );
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNoteAttachments
     *
     * Allows you to retrieve Attachments for credit notes
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments
     */
    public function getCreditNoteAttachments($creditNoteID)
    {
        list($response) = $this->getCreditNoteAttachmentsWithHttpInfo($creditNoteID);
        return $response;
    }

    /**
     * Operation getCreditNoteAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachments for credit notes
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNoteAttachmentsWithHttpInfo($creditNoteID)
    {
        $request = $this->getCreditNoteAttachmentsRequest($creditNoteID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCreditNoteAttachmentsAsync
     *
     * Allows you to retrieve Attachments for credit notes
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteAttachmentsAsync($creditNoteID)
    {
        return $this->getCreditNoteAttachmentsAsyncWithHttpInfo($creditNoteID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCreditNoteAttachmentsAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments for credit notes
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteAttachmentsAsyncWithHttpInfo($creditNoteID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->getCreditNoteAttachmentsRequest($creditNoteID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCreditNoteAttachments'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getCreditNoteAttachmentsRequest($creditNoteID)
    {
        // verify the required parameter 'creditNoteID' is set
        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $creditNoteID when calling getCreditNoteAttachments'
            );
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNoteHistory
     *
     * Allows you to retrieve a history records of an CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getCreditNoteHistory($creditNoteID)
    {
        list($response) = $this->getCreditNoteHistoryWithHttpInfo($creditNoteID);
        return $response;
    }

    /**
     * Operation getCreditNoteHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNoteHistoryWithHttpInfo($creditNoteID)
    {
        $request = $this->getCreditNoteHistoryRequest($creditNoteID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCreditNoteHistoryAsync
     *
     * Allows you to retrieve a history records of an CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteHistoryAsync($creditNoteID)
    {
        return $this->getCreditNoteHistoryAsyncWithHttpInfo($creditNoteID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCreditNoteHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve a history records of an CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteHistoryAsyncWithHttpInfo($creditNoteID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getCreditNoteHistoryRequest($creditNoteID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCreditNoteHistory'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getCreditNoteHistoryRequest($creditNoteID)
    {
        // verify the required parameter 'creditNoteID' is set
        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $creditNoteID when calling getCreditNoteHistory'
            );
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNotes
     *
     * Allows you to retrieve any credit notes
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 credit notes will be returned in a single API call with line items shown for each credit note (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\CreditNotes
     */
    public function getCreditNotes($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {
        list($response) = $this->getCreditNotesWithHttpInfo($ifModifiedSince, $where, $order, $page);
        return $response;
    }

    /**
     * Operation getCreditNotesWithHttpInfo
     *
     * Allows you to retrieve any credit notes
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 credit notes will be returned in a single API call with line items shown for each credit note (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\CreditNotes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNotesWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {
        $request = $this->getCreditNotesRequest($ifModifiedSince, $where, $order, $page);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\CreditNotes' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\CreditNotes', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\CreditNotes';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\CreditNotes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCreditNotesAsync
     *
     * Allows you to retrieve any credit notes
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 credit notes will be returned in a single API call with line items shown for each credit note (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNotesAsync($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {
        return $this->getCreditNotesAsyncWithHttpInfo($ifModifiedSince, $where, $order, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCreditNotesAsyncWithHttpInfo
     *
     * Allows you to retrieve any credit notes
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 credit notes will be returned in a single API call with line items shown for each credit note (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNotesAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\CreditNotes';
        $request = $this->getCreditNotesRequest($ifModifiedSince, $where, $order, $page);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCreditNotes'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 credit notes will be returned in a single API call with line items shown for each credit note (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getCreditNotesRequest($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {

        $resourcePath = '/CreditNotes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCurrencies
     *
     * Allows you to retrieve currencies for your organisation
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Currencies
     */
    public function getCurrencies($where = null, $order = null)
    {
        list($response) = $this->getCurrenciesWithHttpInfo($where, $order);
        return $response;
    }

    /**
     * Operation getCurrenciesWithHttpInfo
     *
     * Allows you to retrieve currencies for your organisation
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Currencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrenciesWithHttpInfo($where = null, $order = null)
    {
        $request = $this->getCurrenciesRequest($where, $order);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Currencies' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Currencies', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Currencies';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Currencies',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCurrenciesAsync
     *
     * Allows you to retrieve currencies for your organisation
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrenciesAsync($where = null, $order = null)
    {
        return $this->getCurrenciesAsyncWithHttpInfo($where, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrenciesAsyncWithHttpInfo
     *
     * Allows you to retrieve currencies for your organisation
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrenciesAsyncWithHttpInfo($where = null, $order = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Currencies';
        $request = $this->getCurrenciesRequest($where, $order);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrencies'
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getCurrenciesRequest($where = null, $order = null)
    {

        $resourcePath = '/Currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getEmployee
     *
     * Allows you to retrieve a specific employee used in Xero payrun
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Employees
     */
    public function getEmployee($employeeID)
    {
        list($response) = $this->getEmployeeWithHttpInfo($employeeID);
        return $response;
    }

    /**
     * Operation getEmployeeWithHttpInfo
     *
     * Allows you to retrieve a specific employee used in Xero payrun
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Employees, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmployeeWithHttpInfo($employeeID)
    {
        $request = $this->getEmployeeRequest($employeeID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Employees' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Employees', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Employees';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Employees',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmployeeAsync
     *
     * Allows you to retrieve a specific employee used in Xero payrun
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmployeeAsync($employeeID)
    {
        return $this->getEmployeeAsyncWithHttpInfo($employeeID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmployeeAsyncWithHttpInfo
     *
     * Allows you to retrieve a specific employee used in Xero payrun
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmployeeAsyncWithHttpInfo($employeeID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Employees';
        $request = $this->getEmployeeRequest($employeeID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmployee'
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getEmployeeRequest($employeeID)
    {
        // verify the required parameter 'employeeID' is set
        if ($employeeID === null || (is_array($employeeID) && count($employeeID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employeeID when calling getEmployee'
            );
        }

        $resourcePath = '/Employees/{EmployeeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($employeeID !== null) {
            $resourcePath = str_replace(
                '{' . 'EmployeeID' . '}',
                ObjectSerializer::toPathValue($employeeID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getEmployees
     *
     * Allows you to retrieve employees used in Xero payrun
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Employees
     */
    public function getEmployees($ifModifiedSince = null, $where = null, $order = null)
    {
        list($response) = $this->getEmployeesWithHttpInfo($ifModifiedSince, $where, $order);
        return $response;
    }

    /**
     * Operation getEmployeesWithHttpInfo
     *
     * Allows you to retrieve employees used in Xero payrun
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Employees, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmployeesWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getEmployeesRequest($ifModifiedSince, $where, $order);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Employees' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Employees', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Employees';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Employees',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmployeesAsync
     *
     * Allows you to retrieve employees used in Xero payrun
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmployeesAsync($ifModifiedSince = null, $where = null, $order = null)
    {
        return $this->getEmployeesAsyncWithHttpInfo($ifModifiedSince, $where, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmployeesAsyncWithHttpInfo
     *
     * Allows you to retrieve employees used in Xero payrun
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmployeesAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Employees';
        $request = $this->getEmployeesRequest($ifModifiedSince, $where, $order);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmployees'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getEmployeesRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/Employees';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getExpenseClaim
     *
     * Allows you to retrieve a specified expense claim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims
     */
    public function getExpenseClaim($expenseClaimID)
    {
        list($response) = $this->getExpenseClaimWithHttpInfo($expenseClaimID);
        return $response;
    }

    /**
     * Operation getExpenseClaimWithHttpInfo
     *
     * Allows you to retrieve a specified expense claim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExpenseClaimWithHttpInfo($expenseClaimID)
    {
        $request = $this->getExpenseClaimRequest($expenseClaimID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExpenseClaimAsync
     *
     * Allows you to retrieve a specified expense claim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExpenseClaimAsync($expenseClaimID)
    {
        return $this->getExpenseClaimAsyncWithHttpInfo($expenseClaimID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExpenseClaimAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified expense claim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExpenseClaimAsyncWithHttpInfo($expenseClaimID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims';
        $request = $this->getExpenseClaimRequest($expenseClaimID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExpenseClaim'
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getExpenseClaimRequest($expenseClaimID)
    {
        // verify the required parameter 'expenseClaimID' is set
        if ($expenseClaimID === null || (is_array($expenseClaimID) && count($expenseClaimID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $expenseClaimID when calling getExpenseClaim'
            );
        }

        $resourcePath = '/ExpenseClaims/{ExpenseClaimID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($expenseClaimID !== null) {
            $resourcePath = str_replace(
                '{' . 'ExpenseClaimID' . '}',
                ObjectSerializer::toPathValue($expenseClaimID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getExpenseClaimHistory
     *
     * Allows you to retrieve a history records of an ExpenseClaim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getExpenseClaimHistory($expenseClaimID)
    {
        list($response) = $this->getExpenseClaimHistoryWithHttpInfo($expenseClaimID);
        return $response;
    }

    /**
     * Operation getExpenseClaimHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an ExpenseClaim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExpenseClaimHistoryWithHttpInfo($expenseClaimID)
    {
        $request = $this->getExpenseClaimHistoryRequest($expenseClaimID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExpenseClaimHistoryAsync
     *
     * Allows you to retrieve a history records of an ExpenseClaim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExpenseClaimHistoryAsync($expenseClaimID)
    {
        return $this->getExpenseClaimHistoryAsyncWithHttpInfo($expenseClaimID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExpenseClaimHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve a history records of an ExpenseClaim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExpenseClaimHistoryAsyncWithHttpInfo($expenseClaimID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getExpenseClaimHistoryRequest($expenseClaimID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExpenseClaimHistory'
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getExpenseClaimHistoryRequest($expenseClaimID)
    {
        // verify the required parameter 'expenseClaimID' is set
        if ($expenseClaimID === null || (is_array($expenseClaimID) && count($expenseClaimID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $expenseClaimID when calling getExpenseClaimHistory'
            );
        }

        $resourcePath = '/ExpenseClaims/{ExpenseClaimID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($expenseClaimID !== null) {
            $resourcePath = str_replace(
                '{' . 'ExpenseClaimID' . '}',
                ObjectSerializer::toPathValue($expenseClaimID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getExpenseClaims
     *
     * Allows you to retrieve expense claims
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims
     */
    public function getExpenseClaims($ifModifiedSince = null, $where = null, $order = null)
    {
        list($response) = $this->getExpenseClaimsWithHttpInfo($ifModifiedSince, $where, $order);
        return $response;
    }

    /**
     * Operation getExpenseClaimsWithHttpInfo
     *
     * Allows you to retrieve expense claims
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExpenseClaimsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getExpenseClaimsRequest($ifModifiedSince, $where, $order);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExpenseClaimsAsync
     *
     * Allows you to retrieve expense claims
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExpenseClaimsAsync($ifModifiedSince = null, $where = null, $order = null)
    {
        return $this->getExpenseClaimsAsyncWithHttpInfo($ifModifiedSince, $where, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExpenseClaimsAsyncWithHttpInfo
     *
     * Allows you to retrieve expense claims
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExpenseClaimsAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims';
        $request = $this->getExpenseClaimsRequest($ifModifiedSince, $where, $order);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExpenseClaims'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getExpenseClaimsRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/ExpenseClaims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoice
     *
     * Allows you to retrieve a specified sales invoice or purchase bill
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Invoices
     */
    public function getInvoice($invoiceID)
    {
        list($response) = $this->getInvoiceWithHttpInfo($invoiceID);
        return $response;
    }

    /**
     * Operation getInvoiceWithHttpInfo
     *
     * Allows you to retrieve a specified sales invoice or purchase bill
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Invoices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceWithHttpInfo($invoiceID)
    {
        $request = $this->getInvoiceRequest($invoiceID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Invoices' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Invoices', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Invoices';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Invoices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceAsync
     *
     * Allows you to retrieve a specified sales invoice or purchase bill
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAsync($invoiceID)
    {
        return $this->getInvoiceAsyncWithHttpInfo($invoiceID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified sales invoice or purchase bill
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAsyncWithHttpInfo($invoiceID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Invoices';
        $request = $this->getInvoiceRequest($invoiceID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoice'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getInvoiceRequest($invoiceID)
    {
        // verify the required parameter 'invoiceID' is set
        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceID when calling getInvoice'
            );
        }

        $resourcePath = '/Invoices/{InvoiceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoiceAsPdf
     *
     * Allows you to retrieve invoices or purchase bills as PDF files
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getInvoiceAsPdf($invoiceID, $contentType)
    {
        list($response) = $this->getInvoiceAsPdfWithHttpInfo($invoiceID, $contentType);
        return $response;
    }

    /**
     * Operation getInvoiceAsPdfWithHttpInfo
     *
     * Allows you to retrieve invoices or purchase bills as PDF files
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceAsPdfWithHttpInfo($invoiceID, $contentType)
    {
        $request = $this->getInvoiceAsPdfRequest($invoiceID, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceAsPdfAsync
     *
     * Allows you to retrieve invoices or purchase bills as PDF files
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAsPdfAsync($invoiceID, $contentType)
    {
        return $this->getInvoiceAsPdfAsyncWithHttpInfo($invoiceID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceAsPdfAsyncWithHttpInfo
     *
     * Allows you to retrieve invoices or purchase bills as PDF files
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAsPdfAsyncWithHttpInfo($invoiceID, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getInvoiceAsPdfRequest($invoiceID, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceAsPdf'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getInvoiceAsPdfRequest($invoiceID, $contentType)
    {
        // verify the required parameter 'invoiceID' is set
        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceID when calling getInvoiceAsPdf'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getInvoiceAsPdf'
            );
        }

        $resourcePath = '/Invoices/{InvoiceID}/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoiceAttachmentByFileName
     *
     * Allows you to retrieve Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getInvoiceAttachmentByFileName($invoiceID, $fileName, $contentType)
    {
        list($response) = $this->getInvoiceAttachmentByFileNameWithHttpInfo($invoiceID, $fileName, $contentType);
        return $response;
    }

    /**
     * Operation getInvoiceAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceAttachmentByFileNameWithHttpInfo($invoiceID, $fileName, $contentType)
    {
        $request = $this->getInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceAttachmentByFileNameAsync
     *
     * Allows you to retrieve Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAttachmentByFileNameAsync($invoiceID, $fileName, $contentType)
    {
        return $this->getInvoiceAttachmentByFileNameAsyncWithHttpInfo($invoiceID, $fileName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAttachmentByFileNameAsyncWithHttpInfo($invoiceID, $fileName, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceAttachmentByFileName'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $contentType)
    {
        // verify the required parameter 'invoiceID' is set
        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceID when calling getInvoiceAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling getInvoiceAttachmentByFileName'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getInvoiceAttachmentByFileName'
            );
        }

        $resourcePath = '/Invoices/{InvoiceID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoiceAttachmentById
     *
     * Allows you to retrieve a specified Attachment on invoices or purchase bills by it's ID
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $attachmentID Unique identifier for an Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getInvoiceAttachmentById($invoiceID, $attachmentID, $contentType)
    {
        list($response) = $this->getInvoiceAttachmentByIdWithHttpInfo($invoiceID, $attachmentID, $contentType);
        return $response;
    }

    /**
     * Operation getInvoiceAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve a specified Attachment on invoices or purchase bills by it's ID
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $attachmentID Unique identifier for an Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceAttachmentByIdWithHttpInfo($invoiceID, $attachmentID, $contentType)
    {
        $request = $this->getInvoiceAttachmentByIdRequest($invoiceID, $attachmentID, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceAttachmentByIdAsync
     *
     * Allows you to retrieve a specified Attachment on invoices or purchase bills by it's ID
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $attachmentID Unique identifier for an Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAttachmentByIdAsync($invoiceID, $attachmentID, $contentType)
    {
        return $this->getInvoiceAttachmentByIdAsyncWithHttpInfo($invoiceID, $attachmentID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceAttachmentByIdAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified Attachment on invoices or purchase bills by it's ID
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $attachmentID Unique identifier for an Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAttachmentByIdAsyncWithHttpInfo($invoiceID, $attachmentID, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getInvoiceAttachmentByIdRequest($invoiceID, $attachmentID, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceAttachmentById'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $attachmentID Unique identifier for an Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getInvoiceAttachmentByIdRequest($invoiceID, $attachmentID, $contentType)
    {
        // verify the required parameter 'invoiceID' is set
        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceID when calling getInvoiceAttachmentById'
            );
        }
        // verify the required parameter 'attachmentID' is set
        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachmentID when calling getInvoiceAttachmentById'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getInvoiceAttachmentById'
            );
        }

        $resourcePath = '/Invoices/{InvoiceID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoiceAttachments
     *
     * Allows you to retrieve Attachments on invoices or purchase bills
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments
     */
    public function getInvoiceAttachments($invoiceID)
    {
        list($response) = $this->getInvoiceAttachmentsWithHttpInfo($invoiceID);
        return $response;
    }

    /**
     * Operation getInvoiceAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachments on invoices or purchase bills
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceAttachmentsWithHttpInfo($invoiceID)
    {
        $request = $this->getInvoiceAttachmentsRequest($invoiceID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceAttachmentsAsync
     *
     * Allows you to retrieve Attachments on invoices or purchase bills
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAttachmentsAsync($invoiceID)
    {
        return $this->getInvoiceAttachmentsAsyncWithHttpInfo($invoiceID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceAttachmentsAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments on invoices or purchase bills
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAttachmentsAsyncWithHttpInfo($invoiceID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->getInvoiceAttachmentsRequest($invoiceID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceAttachments'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getInvoiceAttachmentsRequest($invoiceID)
    {
        // verify the required parameter 'invoiceID' is set
        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceID when calling getInvoiceAttachments'
            );
        }

        $resourcePath = '/Invoices/{InvoiceID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoiceHistory
     *
     * Allows you to retrieve a history records of an invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getInvoiceHistory($invoiceID)
    {
        list($response) = $this->getInvoiceHistoryWithHttpInfo($invoiceID);
        return $response;
    }

    /**
     * Operation getInvoiceHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceHistoryWithHttpInfo($invoiceID)
    {
        $request = $this->getInvoiceHistoryRequest($invoiceID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceHistoryAsync
     *
     * Allows you to retrieve a history records of an invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceHistoryAsync($invoiceID)
    {
        return $this->getInvoiceHistoryAsyncWithHttpInfo($invoiceID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve a history records of an invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceHistoryAsyncWithHttpInfo($invoiceID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getInvoiceHistoryRequest($invoiceID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceHistory'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getInvoiceHistoryRequest($invoiceID)
    {
        // verify the required parameter 'invoiceID' is set
        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceID when calling getInvoiceHistory'
            );
        }

        $resourcePath = '/Invoices/{InvoiceID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoiceReminders
     *
     * Allows you to retrieve invoice reminder settings
     *
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\InvoiceReminders
     */
    public function getInvoiceReminders()
    {
        list($response) = $this->getInvoiceRemindersWithHttpInfo();
        return $response;
    }

    /**
     * Operation getInvoiceRemindersWithHttpInfo
     *
     * Allows you to retrieve invoice reminder settings
     *
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\InvoiceReminders, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceRemindersWithHttpInfo()
    {
        $request = $this->getInvoiceRemindersRequest();

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\InvoiceReminders' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\InvoiceReminders', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\InvoiceReminders';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\InvoiceReminders',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceRemindersAsync
     *
     * Allows you to retrieve invoice reminder settings
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceRemindersAsync()
    {
        return $this->getInvoiceRemindersAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceRemindersAsyncWithHttpInfo
     *
     * Allows you to retrieve invoice reminder settings
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceRemindersAsyncWithHttpInfo()
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\InvoiceReminders';
        $request = $this->getInvoiceRemindersRequest();

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceReminders'
     *
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getInvoiceRemindersRequest()
    {

        $resourcePath = '/InvoiceReminders/Settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoices
     *
     * Allows you to retrieve any sales invoices or purchase bills
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma-separated list of InvoicesIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $invoiceNumbers Filter by a comma-separated list of InvoiceNumbers. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $contactIDs Filter by a comma-separated list of ContactIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $statuses Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 invoices will be returned in a single API call with line items shown for each invoice (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     * @param  bool $createdByMyApp When set to true you&#39;ll only retrieve Invoices created by your app (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Invoices
     */
    public function getInvoices($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $invoiceNumbers = null, $contactIDs = null, $statuses = null, $page = null, $includeArchived = null, $createdByMyApp = null, $unitdp = null)
    {
        list($response) = $this->getInvoicesWithHttpInfo($ifModifiedSince, $where, $order, $iDs, $invoiceNumbers, $contactIDs, $statuses, $page, $includeArchived, $createdByMyApp, $unitdp);
        return $response;
    }

    /**
     * Operation getInvoicesWithHttpInfo
     *
     * Allows you to retrieve any sales invoices or purchase bills
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma-separated list of InvoicesIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $invoiceNumbers Filter by a comma-separated list of InvoiceNumbers. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $contactIDs Filter by a comma-separated list of ContactIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $statuses Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 invoices will be returned in a single API call with line items shown for each invoice (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     * @param  bool $createdByMyApp When set to true you&#39;ll only retrieve Invoices created by your app (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Invoices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoicesWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $invoiceNumbers = null, $contactIDs = null, $statuses = null, $page = null, $includeArchived = null, $createdByMyApp = null, $unitdp = null)
    {
        $request = $this->getInvoicesRequest($ifModifiedSince, $where, $order, $iDs, $invoiceNumbers, $contactIDs, $statuses, $page, $includeArchived, $createdByMyApp, $unitdp);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Invoices' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Invoices', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Invoices';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Invoices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoicesAsync
     *
     * Allows you to retrieve any sales invoices or purchase bills
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma-separated list of InvoicesIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $invoiceNumbers Filter by a comma-separated list of InvoiceNumbers. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $contactIDs Filter by a comma-separated list of ContactIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $statuses Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 invoices will be returned in a single API call with line items shown for each invoice (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     * @param  bool $createdByMyApp When set to true you&#39;ll only retrieve Invoices created by your app (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoicesAsync($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $invoiceNumbers = null, $contactIDs = null, $statuses = null, $page = null, $includeArchived = null, $createdByMyApp = null, $unitdp = null)
    {
        return $this->getInvoicesAsyncWithHttpInfo($ifModifiedSince, $where, $order, $iDs, $invoiceNumbers, $contactIDs, $statuses, $page, $includeArchived, $createdByMyApp, $unitdp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoicesAsyncWithHttpInfo
     *
     * Allows you to retrieve any sales invoices or purchase bills
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma-separated list of InvoicesIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $invoiceNumbers Filter by a comma-separated list of InvoiceNumbers. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $contactIDs Filter by a comma-separated list of ContactIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $statuses Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 invoices will be returned in a single API call with line items shown for each invoice (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     * @param  bool $createdByMyApp When set to true you&#39;ll only retrieve Invoices created by your app (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoicesAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $invoiceNumbers = null, $contactIDs = null, $statuses = null, $page = null, $includeArchived = null, $createdByMyApp = null, $unitdp = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Invoices';
        $request = $this->getInvoicesRequest($ifModifiedSince, $where, $order, $iDs, $invoiceNumbers, $contactIDs, $statuses, $page, $includeArchived, $createdByMyApp, $unitdp);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoices'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma-separated list of InvoicesIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $invoiceNumbers Filter by a comma-separated list of InvoiceNumbers. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $contactIDs Filter by a comma-separated list of ContactIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $statuses Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 invoices will be returned in a single API call with line items shown for each invoice (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     * @param  bool $createdByMyApp When set to true you&#39;ll only retrieve Invoices created by your app (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getInvoicesRequest($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $invoiceNumbers = null, $contactIDs = null, $statuses = null, $page = null, $includeArchived = null, $createdByMyApp = null, $unitdp = null)
    {

        $resourcePath = '/Invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($iDs !== null) {
            $queryParams['IDs'] = ObjectSerializer::toQueryValue($iDs);
        }
        // query params
        if ($invoiceNumbers !== null) {
            $queryParams['InvoiceNumbers'] = ObjectSerializer::toQueryValue($invoiceNumbers);
        }
        // query params
        if ($contactIDs !== null) {
            $queryParams['ContactIDs'] = ObjectSerializer::toQueryValue($contactIDs);
        }
        // query params
        if ($statuses !== null) {
            $queryParams['Statuses'] = ObjectSerializer::toQueryValue($statuses);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($includeArchived !== null) {
            $queryParams['includeArchived'] = ObjectSerializer::toQueryValue($includeArchived);
        }
        // query params
        if ($createdByMyApp !== null) {
            $queryParams['createdByMyApp'] = ObjectSerializer::toQueryValue($createdByMyApp);
        }
        // query params
        if ($unitdp !== null) {
            $queryParams['unitdp'] = ObjectSerializer::toQueryValue($unitdp);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getItem
     *
     * Allows you to retrieve a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Items
     */
    public function getItem($itemID)
    {
        list($response) = $this->getItemWithHttpInfo($itemID);
        return $response;
    }

    /**
     * Operation getItemWithHttpInfo
     *
     * Allows you to retrieve a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Items, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemWithHttpInfo($itemID)
    {
        $request = $this->getItemRequest($itemID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Items' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Items', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Items';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Items',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getItemAsync
     *
     * Allows you to retrieve a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemAsync($itemID)
    {
        return $this->getItemAsyncWithHttpInfo($itemID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getItemAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemAsyncWithHttpInfo($itemID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Items';
        $request = $this->getItemRequest($itemID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getItem'
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getItemRequest($itemID)
    {
        // verify the required parameter 'itemID' is set
        if ($itemID === null || (is_array($itemID) && count($itemID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $itemID when calling getItem'
            );
        }

        $resourcePath = '/Items/{ItemID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($itemID !== null) {
            $resourcePath = str_replace(
                '{' . 'ItemID' . '}',
                ObjectSerializer::toPathValue($itemID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getItemHistory
     *
     * Allows you to retrieve history for items
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getItemHistory($itemID)
    {
        list($response) = $this->getItemHistoryWithHttpInfo($itemID);
        return $response;
    }

    /**
     * Operation getItemHistoryWithHttpInfo
     *
     * Allows you to retrieve history for items
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemHistoryWithHttpInfo($itemID)
    {
        $request = $this->getItemHistoryRequest($itemID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getItemHistoryAsync
     *
     * Allows you to retrieve history for items
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemHistoryAsync($itemID)
    {
        return $this->getItemHistoryAsyncWithHttpInfo($itemID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getItemHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve history for items
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemHistoryAsyncWithHttpInfo($itemID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getItemHistoryRequest($itemID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getItemHistory'
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getItemHistoryRequest($itemID)
    {
        // verify the required parameter 'itemID' is set
        if ($itemID === null || (is_array($itemID) && count($itemID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $itemID when calling getItemHistory'
            );
        }

        $resourcePath = '/Items/{ItemID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($itemID !== null) {
            $resourcePath = str_replace(
                '{' . 'ItemID' . '}',
                ObjectSerializer::toPathValue($itemID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getItems
     *
     * Allows you to retrieve any items
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Items
     */
    public function getItems($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {
        list($response) = $this->getItemsWithHttpInfo($ifModifiedSince, $where, $order, $unitdp);
        return $response;
    }

    /**
     * Operation getItemsWithHttpInfo
     *
     * Allows you to retrieve any items
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Items, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {
        $request = $this->getItemsRequest($ifModifiedSince, $where, $order, $unitdp);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Items' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Items', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Items';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Items',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getItemsAsync
     *
     * Allows you to retrieve any items
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemsAsync($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {
        return $this->getItemsAsyncWithHttpInfo($ifModifiedSince, $where, $order, $unitdp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getItemsAsyncWithHttpInfo
     *
     * Allows you to retrieve any items
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemsAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Items';
        $request = $this->getItemsRequest($ifModifiedSince, $where, $order, $unitdp);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getItems'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getItemsRequest($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {

        $resourcePath = '/Items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($unitdp !== null) {
            $queryParams['unitdp'] = ObjectSerializer::toQueryValue($unitdp);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getJournal
     *
     * Allows you to retrieve a specified journals.
     *
     * @param  string $journalID Unique identifier for a Journal (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Journals
     */
    public function getJournal($journalID)
    {
        list($response) = $this->getJournalWithHttpInfo($journalID);
        return $response;
    }

    /**
     * Operation getJournalWithHttpInfo
     *
     * Allows you to retrieve a specified journals.
     *
     * @param  string $journalID Unique identifier for a Journal (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Journals, HTTP status code, HTTP response headers (array of strings)
     */
    public function getJournalWithHttpInfo($journalID)
    {
        $request = $this->getJournalRequest($journalID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Journals' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Journals', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Journals';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Journals',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getJournalAsync
     *
     * Allows you to retrieve a specified journals.
     *
     * @param  string $journalID Unique identifier for a Journal (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJournalAsync($journalID)
    {
        return $this->getJournalAsyncWithHttpInfo($journalID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getJournalAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified journals.
     *
     * @param  string $journalID Unique identifier for a Journal (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJournalAsyncWithHttpInfo($journalID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Journals';
        $request = $this->getJournalRequest($journalID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getJournal'
     *
     * @param  string $journalID Unique identifier for a Journal (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getJournalRequest($journalID)
    {
        // verify the required parameter 'journalID' is set
        if ($journalID === null || (is_array($journalID) && count($journalID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journalID when calling getJournal'
            );
        }

        $resourcePath = '/Journals/{JournalID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($journalID !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalID' . '}',
                ObjectSerializer::toPathValue($journalID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getJournals
     *
     * Allows you to retrieve any journals.
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  int $offset Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned (optional)
     * @param  bool $paymentsOnly Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default. (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Journals
     */
    public function getJournals($ifModifiedSince = null, $offset = null, $paymentsOnly = null)
    {
        list($response) = $this->getJournalsWithHttpInfo($ifModifiedSince, $offset, $paymentsOnly);
        return $response;
    }

    /**
     * Operation getJournalsWithHttpInfo
     *
     * Allows you to retrieve any journals.
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  int $offset Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned (optional)
     * @param  bool $paymentsOnly Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default. (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Journals, HTTP status code, HTTP response headers (array of strings)
     */
    public function getJournalsWithHttpInfo($ifModifiedSince = null, $offset = null, $paymentsOnly = null)
    {
        $request = $this->getJournalsRequest($ifModifiedSince, $offset, $paymentsOnly);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Journals' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Journals', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Journals';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Journals',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getJournalsAsync
     *
     * Allows you to retrieve any journals.
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  int $offset Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned (optional)
     * @param  bool $paymentsOnly Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJournalsAsync($ifModifiedSince = null, $offset = null, $paymentsOnly = null)
    {
        return $this->getJournalsAsyncWithHttpInfo($ifModifiedSince, $offset, $paymentsOnly)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getJournalsAsyncWithHttpInfo
     *
     * Allows you to retrieve any journals.
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  int $offset Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned (optional)
     * @param  bool $paymentsOnly Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJournalsAsyncWithHttpInfo($ifModifiedSince = null, $offset = null, $paymentsOnly = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Journals';
        $request = $this->getJournalsRequest($ifModifiedSince, $offset, $paymentsOnly);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getJournals'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  int $offset Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned (optional)
     * @param  bool $paymentsOnly Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default. (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getJournalsRequest($ifModifiedSince = null, $offset = null, $paymentsOnly = null)
    {

        $resourcePath = '/Journals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($paymentsOnly !== null) {
            $queryParams['paymentsOnly'] = ObjectSerializer::toQueryValue($paymentsOnly);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getLinkedTransaction
     *
     * Allows you to retrieve a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions
     */
    public function getLinkedTransaction($linkedTransactionID)
    {
        list($response) = $this->getLinkedTransactionWithHttpInfo($linkedTransactionID);
        return $response;
    }

    /**
     * Operation getLinkedTransactionWithHttpInfo
     *
     * Allows you to retrieve a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLinkedTransactionWithHttpInfo($linkedTransactionID)
    {
        $request = $this->getLinkedTransactionRequest($linkedTransactionID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLinkedTransactionAsync
     *
     * Allows you to retrieve a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLinkedTransactionAsync($linkedTransactionID)
    {
        return $this->getLinkedTransactionAsyncWithHttpInfo($linkedTransactionID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLinkedTransactionAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLinkedTransactionAsyncWithHttpInfo($linkedTransactionID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions';
        $request = $this->getLinkedTransactionRequest($linkedTransactionID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLinkedTransaction'
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getLinkedTransactionRequest($linkedTransactionID)
    {
        // verify the required parameter 'linkedTransactionID' is set
        if ($linkedTransactionID === null || (is_array($linkedTransactionID) && count($linkedTransactionID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $linkedTransactionID when calling getLinkedTransaction'
            );
        }

        $resourcePath = '/LinkedTransactions/{LinkedTransactionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($linkedTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'LinkedTransactionID' . '}',
                ObjectSerializer::toPathValue($linkedTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getLinkedTransactions
     *
     * Retrieve linked transactions (billable expenses)
     *
     * @param  int $page Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page&#x3D;1. (optional)
     * @param  string $linkedTransactionID The Xero identifier for an Linked Transaction (optional)
     * @param  string $sourceTransactionID Filter by the SourceTransactionID. Get all the linked transactions created from a particular ACCPAY invoice (optional)
     * @param  string $contactID Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer. (optional)
     * @param  string $status Filter by the combination of ContactID and Status. Get all the linked transactions that have been assigned to a particular customer and have a particular status e.g. GET /LinkedTransactions?ContactID&#x3D;4bb34b03-3378-4bb2-a0ed-6345abf3224e&amp;Status&#x3D;APPROVED. (optional)
     * @param  string $targetTransactionID Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions
     */
    public function getLinkedTransactions($page = null, $linkedTransactionID = null, $sourceTransactionID = null, $contactID = null, $status = null, $targetTransactionID = null)
    {
        list($response) = $this->getLinkedTransactionsWithHttpInfo($page, $linkedTransactionID, $sourceTransactionID, $contactID, $status, $targetTransactionID);
        return $response;
    }

    /**
     * Operation getLinkedTransactionsWithHttpInfo
     *
     * Retrieve linked transactions (billable expenses)
     *
     * @param  int $page Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page&#x3D;1. (optional)
     * @param  string $linkedTransactionID The Xero identifier for an Linked Transaction (optional)
     * @param  string $sourceTransactionID Filter by the SourceTransactionID. Get all the linked transactions created from a particular ACCPAY invoice (optional)
     * @param  string $contactID Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer. (optional)
     * @param  string $status Filter by the combination of ContactID and Status. Get all the linked transactions that have been assigned to a particular customer and have a particular status e.g. GET /LinkedTransactions?ContactID&#x3D;4bb34b03-3378-4bb2-a0ed-6345abf3224e&amp;Status&#x3D;APPROVED. (optional)
     * @param  string $targetTransactionID Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLinkedTransactionsWithHttpInfo($page = null, $linkedTransactionID = null, $sourceTransactionID = null, $contactID = null, $status = null, $targetTransactionID = null)
    {
        $request = $this->getLinkedTransactionsRequest($page, $linkedTransactionID, $sourceTransactionID, $contactID, $status, $targetTransactionID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLinkedTransactionsAsync
     *
     * Retrieve linked transactions (billable expenses)
     *
     * @param  int $page Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page&#x3D;1. (optional)
     * @param  string $linkedTransactionID The Xero identifier for an Linked Transaction (optional)
     * @param  string $sourceTransactionID Filter by the SourceTransactionID. Get all the linked transactions created from a particular ACCPAY invoice (optional)
     * @param  string $contactID Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer. (optional)
     * @param  string $status Filter by the combination of ContactID and Status. Get all the linked transactions that have been assigned to a particular customer and have a particular status e.g. GET /LinkedTransactions?ContactID&#x3D;4bb34b03-3378-4bb2-a0ed-6345abf3224e&amp;Status&#x3D;APPROVED. (optional)
     * @param  string $targetTransactionID Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLinkedTransactionsAsync($page = null, $linkedTransactionID = null, $sourceTransactionID = null, $contactID = null, $status = null, $targetTransactionID = null)
    {
        return $this->getLinkedTransactionsAsyncWithHttpInfo($page, $linkedTransactionID, $sourceTransactionID, $contactID, $status, $targetTransactionID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLinkedTransactionsAsyncWithHttpInfo
     *
     * Retrieve linked transactions (billable expenses)
     *
     * @param  int $page Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page&#x3D;1. (optional)
     * @param  string $linkedTransactionID The Xero identifier for an Linked Transaction (optional)
     * @param  string $sourceTransactionID Filter by the SourceTransactionID. Get all the linked transactions created from a particular ACCPAY invoice (optional)
     * @param  string $contactID Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer. (optional)
     * @param  string $status Filter by the combination of ContactID and Status. Get all the linked transactions that have been assigned to a particular customer and have a particular status e.g. GET /LinkedTransactions?ContactID&#x3D;4bb34b03-3378-4bb2-a0ed-6345abf3224e&amp;Status&#x3D;APPROVED. (optional)
     * @param  string $targetTransactionID Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLinkedTransactionsAsyncWithHttpInfo($page = null, $linkedTransactionID = null, $sourceTransactionID = null, $contactID = null, $status = null, $targetTransactionID = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions';
        $request = $this->getLinkedTransactionsRequest($page, $linkedTransactionID, $sourceTransactionID, $contactID, $status, $targetTransactionID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLinkedTransactions'
     *
     * @param  int $page Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page&#x3D;1. (optional)
     * @param  string $linkedTransactionID The Xero identifier for an Linked Transaction (optional)
     * @param  string $sourceTransactionID Filter by the SourceTransactionID. Get all the linked transactions created from a particular ACCPAY invoice (optional)
     * @param  string $contactID Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer. (optional)
     * @param  string $status Filter by the combination of ContactID and Status. Get all the linked transactions that have been assigned to a particular customer and have a particular status e.g. GET /LinkedTransactions?ContactID&#x3D;4bb34b03-3378-4bb2-a0ed-6345abf3224e&amp;Status&#x3D;APPROVED. (optional)
     * @param  string $targetTransactionID Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getLinkedTransactionsRequest($page = null, $linkedTransactionID = null, $sourceTransactionID = null, $contactID = null, $status = null, $targetTransactionID = null)
    {

        $resourcePath = '/LinkedTransactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($linkedTransactionID !== null) {
            $queryParams['LinkedTransactionID'] = ObjectSerializer::toQueryValue($linkedTransactionID);
        }
        // query params
        if ($sourceTransactionID !== null) {
            $queryParams['SourceTransactionID'] = ObjectSerializer::toQueryValue($sourceTransactionID);
        }
        // query params
        if ($contactID !== null) {
            $queryParams['ContactID'] = ObjectSerializer::toQueryValue($contactID);
        }
        // query params
        if ($status !== null) {
            $queryParams['Status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($targetTransactionID !== null) {
            $queryParams['TargetTransactionID'] = ObjectSerializer::toQueryValue($targetTransactionID);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getManualJournal
     *
     * Allows you to retrieve a specified manual journals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ManualJournals
     */
    public function getManualJournal($manualJournalID)
    {
        list($response) = $this->getManualJournalWithHttpInfo($manualJournalID);
        return $response;
    }

    /**
     * Operation getManualJournalWithHttpInfo
     *
     * Allows you to retrieve a specified manual journals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ManualJournals, HTTP status code, HTTP response headers (array of strings)
     */
    public function getManualJournalWithHttpInfo($manualJournalID)
    {
        $request = $this->getManualJournalRequest($manualJournalID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ManualJournals' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ManualJournals', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ManualJournals';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ManualJournals',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getManualJournalAsync
     *
     * Allows you to retrieve a specified manual journals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getManualJournalAsync($manualJournalID)
    {
        return $this->getManualJournalAsyncWithHttpInfo($manualJournalID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getManualJournalAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified manual journals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getManualJournalAsyncWithHttpInfo($manualJournalID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ManualJournals';
        $request = $this->getManualJournalRequest($manualJournalID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getManualJournal'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getManualJournalRequest($manualJournalID)
    {
        // verify the required parameter 'manualJournalID' is set
        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $manualJournalID when calling getManualJournal'
            );
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getManualJournalAttachmentByFileName
     *
     * Allows you to retrieve specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getManualJournalAttachmentByFileName($manualJournalID, $fileName, $contentType)
    {
        list($response) = $this->getManualJournalAttachmentByFileNameWithHttpInfo($manualJournalID, $fileName, $contentType);
        return $response;
    }

    /**
     * Operation getManualJournalAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getManualJournalAttachmentByFileNameWithHttpInfo($manualJournalID, $fileName, $contentType)
    {
        $request = $this->getManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getManualJournalAttachmentByFileNameAsync
     *
     * Allows you to retrieve specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getManualJournalAttachmentByFileNameAsync($manualJournalID, $fileName, $contentType)
    {
        return $this->getManualJournalAttachmentByFileNameAsyncWithHttpInfo($manualJournalID, $fileName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getManualJournalAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to retrieve specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getManualJournalAttachmentByFileNameAsyncWithHttpInfo($manualJournalID, $fileName, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getManualJournalAttachmentByFileName'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $contentType)
    {
        // verify the required parameter 'manualJournalID' is set
        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $manualJournalID when calling getManualJournalAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling getManualJournalAttachmentByFileName'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getManualJournalAttachmentByFileName'
            );
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getManualJournalAttachmentById
     *
     * Allows you to retrieve specified Attachment on ManualJournals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getManualJournalAttachmentById($manualJournalID, $attachmentID, $contentType)
    {
        list($response) = $this->getManualJournalAttachmentByIdWithHttpInfo($manualJournalID, $attachmentID, $contentType);
        return $response;
    }

    /**
     * Operation getManualJournalAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve specified Attachment on ManualJournals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getManualJournalAttachmentByIdWithHttpInfo($manualJournalID, $attachmentID, $contentType)
    {
        $request = $this->getManualJournalAttachmentByIdRequest($manualJournalID, $attachmentID, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getManualJournalAttachmentByIdAsync
     *
     * Allows you to retrieve specified Attachment on ManualJournals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getManualJournalAttachmentByIdAsync($manualJournalID, $attachmentID, $contentType)
    {
        return $this->getManualJournalAttachmentByIdAsyncWithHttpInfo($manualJournalID, $attachmentID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getManualJournalAttachmentByIdAsyncWithHttpInfo
     *
     * Allows you to retrieve specified Attachment on ManualJournals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getManualJournalAttachmentByIdAsyncWithHttpInfo($manualJournalID, $attachmentID, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getManualJournalAttachmentByIdRequest($manualJournalID, $attachmentID, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getManualJournalAttachmentById'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getManualJournalAttachmentByIdRequest($manualJournalID, $attachmentID, $contentType)
    {
        // verify the required parameter 'manualJournalID' is set
        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $manualJournalID when calling getManualJournalAttachmentById'
            );
        }
        // verify the required parameter 'attachmentID' is set
        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachmentID when calling getManualJournalAttachmentById'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getManualJournalAttachmentById'
            );
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getManualJournalAttachments
     *
     * Allows you to retrieve Attachment for manual journals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments
     */
    public function getManualJournalAttachments($manualJournalID)
    {
        list($response) = $this->getManualJournalAttachmentsWithHttpInfo($manualJournalID);
        return $response;
    }

    /**
     * Operation getManualJournalAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachment for manual journals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getManualJournalAttachmentsWithHttpInfo($manualJournalID)
    {
        $request = $this->getManualJournalAttachmentsRequest($manualJournalID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getManualJournalAttachmentsAsync
     *
     * Allows you to retrieve Attachment for manual journals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getManualJournalAttachmentsAsync($manualJournalID)
    {
        return $this->getManualJournalAttachmentsAsyncWithHttpInfo($manualJournalID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getManualJournalAttachmentsAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachment for manual journals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getManualJournalAttachmentsAsyncWithHttpInfo($manualJournalID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->getManualJournalAttachmentsRequest($manualJournalID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getManualJournalAttachments'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getManualJournalAttachmentsRequest($manualJournalID)
    {
        // verify the required parameter 'manualJournalID' is set
        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $manualJournalID when calling getManualJournalAttachments'
            );
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getManualJournals
     *
     * Allows you to retrieve any manual journals
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ManualJournals
     */
    public function getManualJournals($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {
        list($response) = $this->getManualJournalsWithHttpInfo($ifModifiedSince, $where, $order, $page);
        return $response;
    }

    /**
     * Operation getManualJournalsWithHttpInfo
     *
     * Allows you to retrieve any manual journals
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ManualJournals, HTTP status code, HTTP response headers (array of strings)
     */
    public function getManualJournalsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {
        $request = $this->getManualJournalsRequest($ifModifiedSince, $where, $order, $page);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ManualJournals' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ManualJournals', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ManualJournals';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ManualJournals',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getManualJournalsAsync
     *
     * Allows you to retrieve any manual journals
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getManualJournalsAsync($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {
        return $this->getManualJournalsAsyncWithHttpInfo($ifModifiedSince, $where, $order, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getManualJournalsAsyncWithHttpInfo
     *
     * Allows you to retrieve any manual journals
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getManualJournalsAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ManualJournals';
        $request = $this->getManualJournalsRequest($ifModifiedSince, $where, $order, $page);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getManualJournals'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getManualJournalsRequest($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {

        $resourcePath = '/ManualJournals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getOnlineInvoice
     *
     * Allows you to retrieve a URL to an online invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\OnlineInvoices
     */
    public function getOnlineInvoice($invoiceID)
    {
        list($response) = $this->getOnlineInvoiceWithHttpInfo($invoiceID);
        return $response;
    }

    /**
     * Operation getOnlineInvoiceWithHttpInfo
     *
     * Allows you to retrieve a URL to an online invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\OnlineInvoices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOnlineInvoiceWithHttpInfo($invoiceID)
    {
        $request = $this->getOnlineInvoiceRequest($invoiceID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\OnlineInvoices' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\OnlineInvoices', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\OnlineInvoices';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\OnlineInvoices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOnlineInvoiceAsync
     *
     * Allows you to retrieve a URL to an online invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOnlineInvoiceAsync($invoiceID)
    {
        return $this->getOnlineInvoiceAsyncWithHttpInfo($invoiceID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOnlineInvoiceAsyncWithHttpInfo
     *
     * Allows you to retrieve a URL to an online invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOnlineInvoiceAsyncWithHttpInfo($invoiceID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\OnlineInvoices';
        $request = $this->getOnlineInvoiceRequest($invoiceID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOnlineInvoice'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getOnlineInvoiceRequest($invoiceID)
    {
        // verify the required parameter 'invoiceID' is set
        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceID when calling getOnlineInvoice'
            );
        }

        $resourcePath = '/Invoices/{InvoiceID}/OnlineInvoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getOrganisationCISSettings
     *
     * Allows you To verify if an organisation is using contruction industry scheme, you can retrieve the CIS settings for the organistaion.
     *
     * @param  string $organisationID organisationID (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\CISOrgSetting
     */
    public function getOrganisationCISSettings($organisationID)
    {
        list($response) = $this->getOrganisationCISSettingsWithHttpInfo($organisationID);
        return $response;
    }

    /**
     * Operation getOrganisationCISSettingsWithHttpInfo
     *
     * Allows you To verify if an organisation is using contruction industry scheme, you can retrieve the CIS settings for the organistaion.
     *
     * @param  string $organisationID (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\CISOrgSetting, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganisationCISSettingsWithHttpInfo($organisationID)
    {
        $request = $this->getOrganisationCISSettingsRequest($organisationID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\CISOrgSetting' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\CISOrgSetting', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\CISOrgSetting';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\CISOrgSetting',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganisationCISSettingsAsync
     *
     * Allows you To verify if an organisation is using contruction industry scheme, you can retrieve the CIS settings for the organistaion.
     *
     * @param  string $organisationID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganisationCISSettingsAsync($organisationID)
    {
        return $this->getOrganisationCISSettingsAsyncWithHttpInfo($organisationID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganisationCISSettingsAsyncWithHttpInfo
     *
     * Allows you To verify if an organisation is using contruction industry scheme, you can retrieve the CIS settings for the organistaion.
     *
     * @param  string $organisationID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganisationCISSettingsAsyncWithHttpInfo($organisationID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\CISOrgSetting';
        $request = $this->getOrganisationCISSettingsRequest($organisationID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganisationCISSettings'
     *
     * @param  string $organisationID (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getOrganisationCISSettingsRequest($organisationID)
    {
        // verify the required parameter 'organisationID' is set
        if ($organisationID === null || (is_array($organisationID) && count($organisationID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisationID when calling getOrganisationCISSettings'
            );
        }

        $resourcePath = '/Organisation/{OrganisationID}/CISSettings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($organisationID !== null) {
            $resourcePath = str_replace(
                '{' . 'OrganisationID' . '}',
                ObjectSerializer::toPathValue($organisationID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getOrganisations
     *
     * Allows you to retrieve Organisation details
     *
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Organisations
     */
    public function getOrganisations()
    {
        list($response) = $this->getOrganisationsWithHttpInfo();
        return $response;
    }

    /**
     * Operation getOrganisationsWithHttpInfo
     *
     * Allows you to retrieve Organisation details
     *
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Organisations, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganisationsWithHttpInfo()
    {
        $request = $this->getOrganisationsRequest();

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Organisations' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Organisations', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Organisations';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Organisations',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganisationsAsync
     *
     * Allows you to retrieve Organisation details
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganisationsAsync()
    {
        return $this->getOrganisationsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganisationsAsyncWithHttpInfo
     *
     * Allows you to retrieve Organisation details
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganisationsAsyncWithHttpInfo()
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Organisations';
        $request = $this->getOrganisationsRequest();

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganisations'
     *
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getOrganisationsRequest()
    {

        $resourcePath = '/Organisation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getOverpayment
     *
     * Allows you to retrieve a specified overpayments
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Overpayments
     */
    public function getOverpayment($overpaymentID)
    {
        list($response) = $this->getOverpaymentWithHttpInfo($overpaymentID);
        return $response;
    }

    /**
     * Operation getOverpaymentWithHttpInfo
     *
     * Allows you to retrieve a specified overpayments
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Overpayments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOverpaymentWithHttpInfo($overpaymentID)
    {
        $request = $this->getOverpaymentRequest($overpaymentID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Overpayments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Overpayments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Overpayments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Overpayments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOverpaymentAsync
     *
     * Allows you to retrieve a specified overpayments
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOverpaymentAsync($overpaymentID)
    {
        return $this->getOverpaymentAsyncWithHttpInfo($overpaymentID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOverpaymentAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified overpayments
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOverpaymentAsyncWithHttpInfo($overpaymentID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Overpayments';
        $request = $this->getOverpaymentRequest($overpaymentID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOverpayment'
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getOverpaymentRequest($overpaymentID)
    {
        // verify the required parameter 'overpaymentID' is set
        if ($overpaymentID === null || (is_array($overpaymentID) && count($overpaymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overpaymentID when calling getOverpayment'
            );
        }

        $resourcePath = '/Overpayments/{OverpaymentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($overpaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'OverpaymentID' . '}',
                ObjectSerializer::toPathValue($overpaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getOverpaymentHistory
     *
     * Allows you to retrieve a history records of an Overpayment
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getOverpaymentHistory($overpaymentID)
    {
        list($response) = $this->getOverpaymentHistoryWithHttpInfo($overpaymentID);
        return $response;
    }

    /**
     * Operation getOverpaymentHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an Overpayment
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOverpaymentHistoryWithHttpInfo($overpaymentID)
    {
        $request = $this->getOverpaymentHistoryRequest($overpaymentID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOverpaymentHistoryAsync
     *
     * Allows you to retrieve a history records of an Overpayment
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOverpaymentHistoryAsync($overpaymentID)
    {
        return $this->getOverpaymentHistoryAsyncWithHttpInfo($overpaymentID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOverpaymentHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve a history records of an Overpayment
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOverpaymentHistoryAsyncWithHttpInfo($overpaymentID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getOverpaymentHistoryRequest($overpaymentID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOverpaymentHistory'
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getOverpaymentHistoryRequest($overpaymentID)
    {
        // verify the required parameter 'overpaymentID' is set
        if ($overpaymentID === null || (is_array($overpaymentID) && count($overpaymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overpaymentID when calling getOverpaymentHistory'
            );
        }

        $resourcePath = '/Overpayments/{OverpaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($overpaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'OverpaymentID' . '}',
                ObjectSerializer::toPathValue($overpaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getOverpayments
     *
     * Allows you to retrieve overpayments
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Overpayments
     */
    public function getOverpayments($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        list($response) = $this->getOverpaymentsWithHttpInfo($ifModifiedSince, $where, $order, $page, $unitdp);
        return $response;
    }

    /**
     * Operation getOverpaymentsWithHttpInfo
     *
     * Allows you to retrieve overpayments
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Overpayments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOverpaymentsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        $request = $this->getOverpaymentsRequest($ifModifiedSince, $where, $order, $page, $unitdp);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Overpayments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Overpayments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Overpayments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Overpayments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOverpaymentsAsync
     *
     * Allows you to retrieve overpayments
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOverpaymentsAsync($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        return $this->getOverpaymentsAsyncWithHttpInfo($ifModifiedSince, $where, $order, $page, $unitdp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOverpaymentsAsyncWithHttpInfo
     *
     * Allows you to retrieve overpayments
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOverpaymentsAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Overpayments';
        $request = $this->getOverpaymentsRequest($ifModifiedSince, $where, $order, $page, $unitdp);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOverpayments'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getOverpaymentsRequest($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {

        $resourcePath = '/Overpayments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($unitdp !== null) {
            $queryParams['unitdp'] = ObjectSerializer::toQueryValue($unitdp);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPayment
     *
     * Allows you to retrieve a specified payment for invoices and credit notes
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Payments
     */
    public function getPayment($paymentID)
    {
        list($response) = $this->getPaymentWithHttpInfo($paymentID);
        return $response;
    }

    /**
     * Operation getPaymentWithHttpInfo
     *
     * Allows you to retrieve a specified payment for invoices and credit notes
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Payments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentWithHttpInfo($paymentID)
    {
        $request = $this->getPaymentRequest($paymentID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Payments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Payments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Payments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Payments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentAsync
     *
     * Allows you to retrieve a specified payment for invoices and credit notes
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentAsync($paymentID)
    {
        return $this->getPaymentAsyncWithHttpInfo($paymentID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified payment for invoices and credit notes
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentAsyncWithHttpInfo($paymentID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Payments';
        $request = $this->getPaymentRequest($paymentID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPayment'
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getPaymentRequest($paymentID)
    {
        // verify the required parameter 'paymentID' is set
        if ($paymentID === null || (is_array($paymentID) && count($paymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $paymentID when calling getPayment'
            );
        }

        $resourcePath = '/Payments/{PaymentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($paymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PaymentID' . '}',
                ObjectSerializer::toPathValue($paymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPaymentHistory
     *
     * Allows you to retrieve history records of a payment
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getPaymentHistory($paymentID)
    {
        list($response) = $this->getPaymentHistoryWithHttpInfo($paymentID);
        return $response;
    }

    /**
     * Operation getPaymentHistoryWithHttpInfo
     *
     * Allows you to retrieve history records of a payment
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentHistoryWithHttpInfo($paymentID)
    {
        $request = $this->getPaymentHistoryRequest($paymentID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentHistoryAsync
     *
     * Allows you to retrieve history records of a payment
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentHistoryAsync($paymentID)
    {
        return $this->getPaymentHistoryAsyncWithHttpInfo($paymentID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve history records of a payment
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentHistoryAsyncWithHttpInfo($paymentID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getPaymentHistoryRequest($paymentID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentHistory'
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getPaymentHistoryRequest($paymentID)
    {
        // verify the required parameter 'paymentID' is set
        if ($paymentID === null || (is_array($paymentID) && count($paymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $paymentID when calling getPaymentHistory'
            );
        }

        $resourcePath = '/Payments/{PaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($paymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PaymentID' . '}',
                ObjectSerializer::toPathValue($paymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPaymentServices
     *
     * Allows you to retrieve payment services
     *
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\PaymentServices
     */
    public function getPaymentServices()
    {
        list($response) = $this->getPaymentServicesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getPaymentServicesWithHttpInfo
     *
     * Allows you to retrieve payment services
     *
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\PaymentServices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentServicesWithHttpInfo()
    {
        $request = $this->getPaymentServicesRequest();

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\PaymentServices' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\PaymentServices', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\PaymentServices';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\PaymentServices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentServicesAsync
     *
     * Allows you to retrieve payment services
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentServicesAsync()
    {
        return $this->getPaymentServicesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentServicesAsyncWithHttpInfo
     *
     * Allows you to retrieve payment services
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentServicesAsyncWithHttpInfo()
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\PaymentServices';
        $request = $this->getPaymentServicesRequest();

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentServices'
     *
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getPaymentServicesRequest()
    {

        $resourcePath = '/PaymentServices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPayments
     *
     * Allows you to retrieve payments for invoices and credit notes
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Payments
     */
    public function getPayments($ifModifiedSince = null, $where = null, $order = null)
    {
        list($response) = $this->getPaymentsWithHttpInfo($ifModifiedSince, $where, $order);
        return $response;
    }

    /**
     * Operation getPaymentsWithHttpInfo
     *
     * Allows you to retrieve payments for invoices and credit notes
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Payments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getPaymentsRequest($ifModifiedSince, $where, $order);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Payments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Payments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Payments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Payments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentsAsync
     *
     * Allows you to retrieve payments for invoices and credit notes
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentsAsync($ifModifiedSince = null, $where = null, $order = null)
    {
        return $this->getPaymentsAsyncWithHttpInfo($ifModifiedSince, $where, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentsAsyncWithHttpInfo
     *
     * Allows you to retrieve payments for invoices and credit notes
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentsAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Payments';
        $request = $this->getPaymentsRequest($ifModifiedSince, $where, $order);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPayments'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getPaymentsRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/Payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPrepayment
     *
     * Allows you to retrieve a specified prepayments
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Prepayments
     */
    public function getPrepayment($prepaymentID)
    {
        list($response) = $this->getPrepaymentWithHttpInfo($prepaymentID);
        return $response;
    }

    /**
     * Operation getPrepaymentWithHttpInfo
     *
     * Allows you to retrieve a specified prepayments
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Prepayments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPrepaymentWithHttpInfo($prepaymentID)
    {
        $request = $this->getPrepaymentRequest($prepaymentID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Prepayments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Prepayments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Prepayments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Prepayments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPrepaymentAsync
     *
     * Allows you to retrieve a specified prepayments
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPrepaymentAsync($prepaymentID)
    {
        return $this->getPrepaymentAsyncWithHttpInfo($prepaymentID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPrepaymentAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified prepayments
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPrepaymentAsyncWithHttpInfo($prepaymentID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Prepayments';
        $request = $this->getPrepaymentRequest($prepaymentID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPrepayment'
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getPrepaymentRequest($prepaymentID)
    {
        // verify the required parameter 'prepaymentID' is set
        if ($prepaymentID === null || (is_array($prepaymentID) && count($prepaymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prepaymentID when calling getPrepayment'
            );
        }

        $resourcePath = '/Prepayments/{PrepaymentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($prepaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PrepaymentID' . '}',
                ObjectSerializer::toPathValue($prepaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPrepaymentHistory
     *
     * Allows you to retrieve a history records of an Prepayment
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getPrepaymentHistory($prepaymentID)
    {
        list($response) = $this->getPrepaymentHistoryWithHttpInfo($prepaymentID);
        return $response;
    }

    /**
     * Operation getPrepaymentHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an Prepayment
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPrepaymentHistoryWithHttpInfo($prepaymentID)
    {
        $request = $this->getPrepaymentHistoryRequest($prepaymentID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPrepaymentHistoryAsync
     *
     * Allows you to retrieve a history records of an Prepayment
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPrepaymentHistoryAsync($prepaymentID)
    {
        return $this->getPrepaymentHistoryAsyncWithHttpInfo($prepaymentID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPrepaymentHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve a history records of an Prepayment
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPrepaymentHistoryAsyncWithHttpInfo($prepaymentID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getPrepaymentHistoryRequest($prepaymentID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPrepaymentHistory'
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getPrepaymentHistoryRequest($prepaymentID)
    {
        // verify the required parameter 'prepaymentID' is set
        if ($prepaymentID === null || (is_array($prepaymentID) && count($prepaymentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prepaymentID when calling getPrepaymentHistory'
            );
        }

        $resourcePath = '/Prepayments/{PrepaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($prepaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PrepaymentID' . '}',
                ObjectSerializer::toPathValue($prepaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPrepayments
     *
     * Allows you to retrieve prepayments
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Prepayments
     */
    public function getPrepayments($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        list($response) = $this->getPrepaymentsWithHttpInfo($ifModifiedSince, $where, $order, $page, $unitdp);
        return $response;
    }

    /**
     * Operation getPrepaymentsWithHttpInfo
     *
     * Allows you to retrieve prepayments
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Prepayments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPrepaymentsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        $request = $this->getPrepaymentsRequest($ifModifiedSince, $where, $order, $page, $unitdp);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Prepayments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Prepayments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Prepayments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Prepayments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPrepaymentsAsync
     *
     * Allows you to retrieve prepayments
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPrepaymentsAsync($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        return $this->getPrepaymentsAsyncWithHttpInfo($ifModifiedSince, $where, $order, $page, $unitdp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPrepaymentsAsyncWithHttpInfo
     *
     * Allows you to retrieve prepayments
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPrepaymentsAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Prepayments';
        $request = $this->getPrepaymentsRequest($ifModifiedSince, $where, $order, $page, $unitdp);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPrepayments'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1  Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getPrepaymentsRequest($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {

        $resourcePath = '/Prepayments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($unitdp !== null) {
            $queryParams['unitdp'] = ObjectSerializer::toQueryValue($unitdp);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPurchaseOrder
     *
     * Allows you to retrieve a specified purchase orders
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders
     */
    public function getPurchaseOrder($purchaseOrderID)
    {
        list($response) = $this->getPurchaseOrderWithHttpInfo($purchaseOrderID);
        return $response;
    }

    /**
     * Operation getPurchaseOrderWithHttpInfo
     *
     * Allows you to retrieve a specified purchase orders
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPurchaseOrderWithHttpInfo($purchaseOrderID)
    {
        $request = $this->getPurchaseOrderRequest($purchaseOrderID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPurchaseOrderAsync
     *
     * Allows you to retrieve a specified purchase orders
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPurchaseOrderAsync($purchaseOrderID)
    {
        return $this->getPurchaseOrderAsyncWithHttpInfo($purchaseOrderID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPurchaseOrderAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified purchase orders
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPurchaseOrderAsyncWithHttpInfo($purchaseOrderID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders';
        $request = $this->getPurchaseOrderRequest($purchaseOrderID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPurchaseOrder'
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getPurchaseOrderRequest($purchaseOrderID)
    {
        // verify the required parameter 'purchaseOrderID' is set
        if ($purchaseOrderID === null || (is_array($purchaseOrderID) && count($purchaseOrderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purchaseOrderID when calling getPurchaseOrder'
            );
        }

        $resourcePath = '/PurchaseOrders/{PurchaseOrderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($purchaseOrderID !== null) {
            $resourcePath = str_replace(
                '{' . 'PurchaseOrderID' . '}',
                ObjectSerializer::toPathValue($purchaseOrderID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPurchaseOrderHistory
     *
     * Allows you to retrieve history for PurchaseOrder
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getPurchaseOrderHistory($purchaseOrderID)
    {
        list($response) = $this->getPurchaseOrderHistoryWithHttpInfo($purchaseOrderID);
        return $response;
    }

    /**
     * Operation getPurchaseOrderHistoryWithHttpInfo
     *
     * Allows you to retrieve history for PurchaseOrder
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPurchaseOrderHistoryWithHttpInfo($purchaseOrderID)
    {
        $request = $this->getPurchaseOrderHistoryRequest($purchaseOrderID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPurchaseOrderHistoryAsync
     *
     * Allows you to retrieve history for PurchaseOrder
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPurchaseOrderHistoryAsync($purchaseOrderID)
    {
        return $this->getPurchaseOrderHistoryAsyncWithHttpInfo($purchaseOrderID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPurchaseOrderHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve history for PurchaseOrder
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPurchaseOrderHistoryAsyncWithHttpInfo($purchaseOrderID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getPurchaseOrderHistoryRequest($purchaseOrderID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPurchaseOrderHistory'
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getPurchaseOrderHistoryRequest($purchaseOrderID)
    {
        // verify the required parameter 'purchaseOrderID' is set
        if ($purchaseOrderID === null || (is_array($purchaseOrderID) && count($purchaseOrderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purchaseOrderID when calling getPurchaseOrderHistory'
            );
        }

        $resourcePath = '/PurchaseOrders/{PurchaseOrderID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($purchaseOrderID !== null) {
            $resourcePath = str_replace(
                '{' . 'PurchaseOrderID' . '}',
                ObjectSerializer::toPathValue($purchaseOrderID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPurchaseOrders
     *
     * Allows you to retrieve purchase orders
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $status Filter by purchase order status (optional)
     * @param  string $dateFrom Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $dateTo Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page To specify a page, append the page parameter to the URL e.g. ?page&#x3D;1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page&#x3D;2 and continuing this process until no more results are returned. (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders
     */
    public function getPurchaseOrders($ifModifiedSince = null, $status = null, $dateFrom = null, $dateTo = null, $order = null, $page = null)
    {
        list($response) = $this->getPurchaseOrdersWithHttpInfo($ifModifiedSince, $status, $dateFrom, $dateTo, $order, $page);
        return $response;
    }

    /**
     * Operation getPurchaseOrdersWithHttpInfo
     *
     * Allows you to retrieve purchase orders
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $status Filter by purchase order status (optional)
     * @param  string $dateFrom Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $dateTo Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page To specify a page, append the page parameter to the URL e.g. ?page&#x3D;1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page&#x3D;2 and continuing this process until no more results are returned. (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPurchaseOrdersWithHttpInfo($ifModifiedSince = null, $status = null, $dateFrom = null, $dateTo = null, $order = null, $page = null)
    {
        $request = $this->getPurchaseOrdersRequest($ifModifiedSince, $status, $dateFrom, $dateTo, $order, $page);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPurchaseOrdersAsync
     *
     * Allows you to retrieve purchase orders
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $status Filter by purchase order status (optional)
     * @param  string $dateFrom Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $dateTo Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page To specify a page, append the page parameter to the URL e.g. ?page&#x3D;1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page&#x3D;2 and continuing this process until no more results are returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPurchaseOrdersAsync($ifModifiedSince = null, $status = null, $dateFrom = null, $dateTo = null, $order = null, $page = null)
    {
        return $this->getPurchaseOrdersAsyncWithHttpInfo($ifModifiedSince, $status, $dateFrom, $dateTo, $order, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPurchaseOrdersAsyncWithHttpInfo
     *
     * Allows you to retrieve purchase orders
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $status Filter by purchase order status (optional)
     * @param  string $dateFrom Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $dateTo Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page To specify a page, append the page parameter to the URL e.g. ?page&#x3D;1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page&#x3D;2 and continuing this process until no more results are returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPurchaseOrdersAsyncWithHttpInfo($ifModifiedSince = null, $status = null, $dateFrom = null, $dateTo = null, $order = null, $page = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders';
        $request = $this->getPurchaseOrdersRequest($ifModifiedSince, $status, $dateFrom, $dateTo, $order, $page);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPurchaseOrders'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $status Filter by purchase order status (optional)
     * @param  string $dateFrom Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $dateTo Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page To specify a page, append the page parameter to the URL e.g. ?page&#x3D;1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page&#x3D;2 and continuing this process until no more results are returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getPurchaseOrdersRequest($ifModifiedSince = null, $status = null, $dateFrom = null, $dateTo = null, $order = null, $page = null)
    {

        $resourcePath = '/PurchaseOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($status !== null) {
            $queryParams['Status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($dateFrom !== null) {
            $queryParams['DateFrom'] = ObjectSerializer::toQueryValue($dateFrom);
        }
        // query params
        if ($dateTo !== null) {
            $queryParams['DateTo'] = ObjectSerializer::toQueryValue($dateTo);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReceipt
     *
     * Allows you to retrieve a specified draft expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Receipts
     */
    public function getReceipt($receiptID)
    {
        list($response) = $this->getReceiptWithHttpInfo($receiptID);
        return $response;
    }

    /**
     * Operation getReceiptWithHttpInfo
     *
     * Allows you to retrieve a specified draft expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Receipts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiptWithHttpInfo($receiptID)
    {
        $request = $this->getReceiptRequest($receiptID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Receipts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Receipts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Receipts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Receipts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReceiptAsync
     *
     * Allows you to retrieve a specified draft expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiptAsync($receiptID)
    {
        return $this->getReceiptAsyncWithHttpInfo($receiptID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReceiptAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified draft expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiptAsyncWithHttpInfo($receiptID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Receipts';
        $request = $this->getReceiptRequest($receiptID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReceipt'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReceiptRequest($receiptID)
    {
        // verify the required parameter 'receiptID' is set
        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receiptID when calling getReceipt'
            );
        }

        $resourcePath = '/Receipts/{ReceiptID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReceiptAttachmentByFileName
     *
     * Allows you to retrieve Attachments on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getReceiptAttachmentByFileName($receiptID, $fileName, $contentType)
    {
        list($response) = $this->getReceiptAttachmentByFileNameWithHttpInfo($receiptID, $fileName, $contentType);
        return $response;
    }

    /**
     * Operation getReceiptAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachments on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiptAttachmentByFileNameWithHttpInfo($receiptID, $fileName, $contentType)
    {
        $request = $this->getReceiptAttachmentByFileNameRequest($receiptID, $fileName, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReceiptAttachmentByFileNameAsync
     *
     * Allows you to retrieve Attachments on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiptAttachmentByFileNameAsync($receiptID, $fileName, $contentType)
    {
        return $this->getReceiptAttachmentByFileNameAsyncWithHttpInfo($receiptID, $fileName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReceiptAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiptAttachmentByFileNameAsyncWithHttpInfo($receiptID, $fileName, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getReceiptAttachmentByFileNameRequest($receiptID, $fileName, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReceiptAttachmentByFileName'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReceiptAttachmentByFileNameRequest($receiptID, $fileName, $contentType)
    {
        // verify the required parameter 'receiptID' is set
        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receiptID when calling getReceiptAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling getReceiptAttachmentByFileName'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getReceiptAttachmentByFileName'
            );
        }

        $resourcePath = '/Receipts/{ReceiptID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReceiptAttachmentById
     *
     * Allows you to retrieve Attachments on expense claim receipts by ID
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getReceiptAttachmentById($receiptID, $attachmentID, $contentType)
    {
        list($response) = $this->getReceiptAttachmentByIdWithHttpInfo($receiptID, $attachmentID, $contentType);
        return $response;
    }

    /**
     * Operation getReceiptAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve Attachments on expense claim receipts by ID
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiptAttachmentByIdWithHttpInfo($receiptID, $attachmentID, $contentType)
    {
        $request = $this->getReceiptAttachmentByIdRequest($receiptID, $attachmentID, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReceiptAttachmentByIdAsync
     *
     * Allows you to retrieve Attachments on expense claim receipts by ID
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiptAttachmentByIdAsync($receiptID, $attachmentID, $contentType)
    {
        return $this->getReceiptAttachmentByIdAsyncWithHttpInfo($receiptID, $attachmentID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReceiptAttachmentByIdAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments on expense claim receipts by ID
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiptAttachmentByIdAsyncWithHttpInfo($receiptID, $attachmentID, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getReceiptAttachmentByIdRequest($receiptID, $attachmentID, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReceiptAttachmentById'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReceiptAttachmentByIdRequest($receiptID, $attachmentID, $contentType)
    {
        // verify the required parameter 'receiptID' is set
        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receiptID when calling getReceiptAttachmentById'
            );
        }
        // verify the required parameter 'attachmentID' is set
        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachmentID when calling getReceiptAttachmentById'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getReceiptAttachmentById'
            );
        }

        $resourcePath = '/Receipts/{ReceiptID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReceiptAttachments
     *
     * Allows you to retrieve Attachments for expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments
     */
    public function getReceiptAttachments($receiptID)
    {
        list($response) = $this->getReceiptAttachmentsWithHttpInfo($receiptID);
        return $response;
    }

    /**
     * Operation getReceiptAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachments for expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiptAttachmentsWithHttpInfo($receiptID)
    {
        $request = $this->getReceiptAttachmentsRequest($receiptID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReceiptAttachmentsAsync
     *
     * Allows you to retrieve Attachments for expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiptAttachmentsAsync($receiptID)
    {
        return $this->getReceiptAttachmentsAsyncWithHttpInfo($receiptID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReceiptAttachmentsAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments for expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiptAttachmentsAsyncWithHttpInfo($receiptID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->getReceiptAttachmentsRequest($receiptID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReceiptAttachments'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReceiptAttachmentsRequest($receiptID)
    {
        // verify the required parameter 'receiptID' is set
        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receiptID when calling getReceiptAttachments'
            );
        }

        $resourcePath = '/Receipts/{ReceiptID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReceiptHistory
     *
     * Allows you to retrieve a history records of an Receipt
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getReceiptHistory($receiptID)
    {
        list($response) = $this->getReceiptHistoryWithHttpInfo($receiptID);
        return $response;
    }

    /**
     * Operation getReceiptHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an Receipt
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiptHistoryWithHttpInfo($receiptID)
    {
        $request = $this->getReceiptHistoryRequest($receiptID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReceiptHistoryAsync
     *
     * Allows you to retrieve a history records of an Receipt
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiptHistoryAsync($receiptID)
    {
        return $this->getReceiptHistoryAsyncWithHttpInfo($receiptID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReceiptHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve a history records of an Receipt
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiptHistoryAsyncWithHttpInfo($receiptID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getReceiptHistoryRequest($receiptID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReceiptHistory'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReceiptHistoryRequest($receiptID)
    {
        // verify the required parameter 'receiptID' is set
        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receiptID when calling getReceiptHistory'
            );
        }

        $resourcePath = '/Receipts/{ReceiptID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReceipts
     *
     * Allows you to retrieve draft expense claim receipts for any user
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Receipts
     */
    public function getReceipts($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {
        list($response) = $this->getReceiptsWithHttpInfo($ifModifiedSince, $where, $order, $unitdp);
        return $response;
    }

    /**
     * Operation getReceiptsWithHttpInfo
     *
     * Allows you to retrieve draft expense claim receipts for any user
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Receipts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiptsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {
        $request = $this->getReceiptsRequest($ifModifiedSince, $where, $order, $unitdp);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Receipts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Receipts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Receipts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Receipts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReceiptsAsync
     *
     * Allows you to retrieve draft expense claim receipts for any user
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiptsAsync($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {
        return $this->getReceiptsAsyncWithHttpInfo($ifModifiedSince, $where, $order, $unitdp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReceiptsAsyncWithHttpInfo
     *
     * Allows you to retrieve draft expense claim receipts for any user
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReceiptsAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Receipts';
        $request = $this->getReceiptsRequest($ifModifiedSince, $where, $order, $unitdp);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReceipts'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4  You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReceiptsRequest($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {

        $resourcePath = '/Receipts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($unitdp !== null) {
            $queryParams['unitdp'] = ObjectSerializer::toQueryValue($unitdp);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getRepeatingInvoice
     *
     * Allows you to retrieve a specified repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices
     */
    public function getRepeatingInvoice($repeatingInvoiceID)
    {
        list($response) = $this->getRepeatingInvoiceWithHttpInfo($repeatingInvoiceID);
        return $response;
    }

    /**
     * Operation getRepeatingInvoiceWithHttpInfo
     *
     * Allows you to retrieve a specified repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepeatingInvoiceWithHttpInfo($repeatingInvoiceID)
    {
        $request = $this->getRepeatingInvoiceRequest($repeatingInvoiceID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRepeatingInvoiceAsync
     *
     * Allows you to retrieve a specified repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepeatingInvoiceAsync($repeatingInvoiceID)
    {
        return $this->getRepeatingInvoiceAsyncWithHttpInfo($repeatingInvoiceID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRepeatingInvoiceAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepeatingInvoiceAsyncWithHttpInfo($repeatingInvoiceID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices';
        $request = $this->getRepeatingInvoiceRequest($repeatingInvoiceID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRepeatingInvoice'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getRepeatingInvoiceRequest($repeatingInvoiceID)
    {
        // verify the required parameter 'repeatingInvoiceID' is set
        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repeatingInvoiceID when calling getRepeatingInvoice'
            );
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getRepeatingInvoiceAttachmentByFileName
     *
     * Allows you to retrieve specified attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getRepeatingInvoiceAttachmentByFileName($repeatingInvoiceID, $fileName, $contentType)
    {
        list($response) = $this->getRepeatingInvoiceAttachmentByFileNameWithHttpInfo($repeatingInvoiceID, $fileName, $contentType);
        return $response;
    }

    /**
     * Operation getRepeatingInvoiceAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve specified attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepeatingInvoiceAttachmentByFileNameWithHttpInfo($repeatingInvoiceID, $fileName, $contentType)
    {
        $request = $this->getRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRepeatingInvoiceAttachmentByFileNameAsync
     *
     * Allows you to retrieve specified attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepeatingInvoiceAttachmentByFileNameAsync($repeatingInvoiceID, $fileName, $contentType)
    {
        return $this->getRepeatingInvoiceAttachmentByFileNameAsyncWithHttpInfo($repeatingInvoiceID, $fileName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRepeatingInvoiceAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to retrieve specified attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepeatingInvoiceAttachmentByFileNameAsyncWithHttpInfo($repeatingInvoiceID, $fileName, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRepeatingInvoiceAttachmentByFileName'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $contentType)
    {
        // verify the required parameter 'repeatingInvoiceID' is set
        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repeatingInvoiceID when calling getRepeatingInvoiceAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling getRepeatingInvoiceAttachmentByFileName'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getRepeatingInvoiceAttachmentByFileName'
            );
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getRepeatingInvoiceAttachmentById
     *
     * Allows you to retrieve a specified Attachments on repeating invoices
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getRepeatingInvoiceAttachmentById($repeatingInvoiceID, $attachmentID, $contentType)
    {
        list($response) = $this->getRepeatingInvoiceAttachmentByIdWithHttpInfo($repeatingInvoiceID, $attachmentID, $contentType);
        return $response;
    }

    /**
     * Operation getRepeatingInvoiceAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve a specified Attachments on repeating invoices
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepeatingInvoiceAttachmentByIdWithHttpInfo($repeatingInvoiceID, $attachmentID, $contentType)
    {
        $request = $this->getRepeatingInvoiceAttachmentByIdRequest($repeatingInvoiceID, $attachmentID, $contentType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRepeatingInvoiceAttachmentByIdAsync
     *
     * Allows you to retrieve a specified Attachments on repeating invoices
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepeatingInvoiceAttachmentByIdAsync($repeatingInvoiceID, $attachmentID, $contentType)
    {
        return $this->getRepeatingInvoiceAttachmentByIdAsyncWithHttpInfo($repeatingInvoiceID, $attachmentID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRepeatingInvoiceAttachmentByIdAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified Attachments on repeating invoices
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepeatingInvoiceAttachmentByIdAsyncWithHttpInfo($repeatingInvoiceID, $attachmentID, $contentType)
    {
        $returnType = '\SplFileObject';
        $request = $this->getRepeatingInvoiceAttachmentByIdRequest($repeatingInvoiceID, $attachmentID, $contentType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRepeatingInvoiceAttachmentById'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getRepeatingInvoiceAttachmentByIdRequest($repeatingInvoiceID, $attachmentID, $contentType)
    {
        // verify the required parameter 'repeatingInvoiceID' is set
        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repeatingInvoiceID when calling getRepeatingInvoiceAttachmentById'
            );
        }
        // verify the required parameter 'attachmentID' is set
        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachmentID when calling getRepeatingInvoiceAttachmentById'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getRepeatingInvoiceAttachmentById'
            );
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getRepeatingInvoiceAttachments
     *
     * Allows you to retrieve Attachments on repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments
     */
    public function getRepeatingInvoiceAttachments($repeatingInvoiceID)
    {
        list($response) = $this->getRepeatingInvoiceAttachmentsWithHttpInfo($repeatingInvoiceID);
        return $response;
    }

    /**
     * Operation getRepeatingInvoiceAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachments on repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepeatingInvoiceAttachmentsWithHttpInfo($repeatingInvoiceID)
    {
        $request = $this->getRepeatingInvoiceAttachmentsRequest($repeatingInvoiceID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRepeatingInvoiceAttachmentsAsync
     *
     * Allows you to retrieve Attachments on repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepeatingInvoiceAttachmentsAsync($repeatingInvoiceID)
    {
        return $this->getRepeatingInvoiceAttachmentsAsyncWithHttpInfo($repeatingInvoiceID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRepeatingInvoiceAttachmentsAsyncWithHttpInfo
     *
     * Allows you to retrieve Attachments on repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepeatingInvoiceAttachmentsAsyncWithHttpInfo($repeatingInvoiceID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->getRepeatingInvoiceAttachmentsRequest($repeatingInvoiceID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRepeatingInvoiceAttachments'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getRepeatingInvoiceAttachmentsRequest($repeatingInvoiceID)
    {
        // verify the required parameter 'repeatingInvoiceID' is set
        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repeatingInvoiceID when calling getRepeatingInvoiceAttachments'
            );
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getRepeatingInvoiceHistory
     *
     * Allows you to retrieve history for a repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\HistoryRecords
     */
    public function getRepeatingInvoiceHistory($repeatingInvoiceID)
    {
        list($response) = $this->getRepeatingInvoiceHistoryWithHttpInfo($repeatingInvoiceID);
        return $response;
    }

    /**
     * Operation getRepeatingInvoiceHistoryWithHttpInfo
     *
     * Allows you to retrieve history for a repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepeatingInvoiceHistoryWithHttpInfo($repeatingInvoiceID)
    {
        $request = $this->getRepeatingInvoiceHistoryRequest($repeatingInvoiceID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\HistoryRecords' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRepeatingInvoiceHistoryAsync
     *
     * Allows you to retrieve history for a repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepeatingInvoiceHistoryAsync($repeatingInvoiceID)
    {
        return $this->getRepeatingInvoiceHistoryAsyncWithHttpInfo($repeatingInvoiceID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRepeatingInvoiceHistoryAsyncWithHttpInfo
     *
     * Allows you to retrieve history for a repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepeatingInvoiceHistoryAsyncWithHttpInfo($repeatingInvoiceID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\HistoryRecords';
        $request = $this->getRepeatingInvoiceHistoryRequest($repeatingInvoiceID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRepeatingInvoiceHistory'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getRepeatingInvoiceHistoryRequest($repeatingInvoiceID)
    {
        // verify the required parameter 'repeatingInvoiceID' is set
        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repeatingInvoiceID when calling getRepeatingInvoiceHistory'
            );
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getRepeatingInvoices
     *
     * Allows you to retrieve any repeating invoices
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices
     */
    public function getRepeatingInvoices($where = null, $order = null)
    {
        list($response) = $this->getRepeatingInvoicesWithHttpInfo($where, $order);
        return $response;
    }

    /**
     * Operation getRepeatingInvoicesWithHttpInfo
     *
     * Allows you to retrieve any repeating invoices
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepeatingInvoicesWithHttpInfo($where = null, $order = null)
    {
        $request = $this->getRepeatingInvoicesRequest($where, $order);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRepeatingInvoicesAsync
     *
     * Allows you to retrieve any repeating invoices
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepeatingInvoicesAsync($where = null, $order = null)
    {
        return $this->getRepeatingInvoicesAsyncWithHttpInfo($where, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRepeatingInvoicesAsyncWithHttpInfo
     *
     * Allows you to retrieve any repeating invoices
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRepeatingInvoicesAsyncWithHttpInfo($where = null, $order = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\RepeatingInvoices';
        $request = $this->getRepeatingInvoicesRequest($where, $order);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRepeatingInvoices'
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getRepeatingInvoicesRequest($where = null, $order = null)
    {

        $resourcePath = '/RepeatingInvoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportAgedPayablesByContact
     *
     * Allows you to retrieve report for AgedPayablesByContact
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Payables By Contact report (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ReportWithRows
     */
    public function getReportAgedPayablesByContact($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        list($response) = $this->getReportAgedPayablesByContactWithHttpInfo($contactId, $date, $fromDate, $toDate);
        return $response;
    }

    /**
     * Operation getReportAgedPayablesByContactWithHttpInfo
     *
     * Allows you to retrieve report for AgedPayablesByContact
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Payables By Contact report (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportAgedPayablesByContactWithHttpInfo($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        $request = $this->getReportAgedPayablesByContactRequest($contactId, $date, $fromDate, $toDate);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ReportWithRows' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReportAgedPayablesByContactAsync
     *
     * Allows you to retrieve report for AgedPayablesByContact
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Payables By Contact report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportAgedPayablesByContactAsync($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        return $this->getReportAgedPayablesByContactAsyncWithHttpInfo($contactId, $date, $fromDate, $toDate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReportAgedPayablesByContactAsyncWithHttpInfo
     *
     * Allows you to retrieve report for AgedPayablesByContact
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Payables By Contact report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportAgedPayablesByContactAsyncWithHttpInfo($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
        $request = $this->getReportAgedPayablesByContactRequest($contactId, $date, $fromDate, $toDate);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReportAgedPayablesByContact'
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Payables By Contact report (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReportAgedPayablesByContactRequest($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        // verify the required parameter 'contactId' is set
        if ($contactId === null || (is_array($contactId) && count($contactId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactId when calling getReportAgedPayablesByContact'
            );
        }

        $resourcePath = '/Reports/AgedPayablesByContact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contactId !== null) {
            $queryParams['contactId'] = ObjectSerializer::toQueryValue($contactId);
        }
        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($fromDate !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($fromDate);
        }
        // query params
        if ($toDate !== null) {
            $queryParams['toDate'] = ObjectSerializer::toQueryValue($toDate);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportAgedReceivablesByContact
     *
     * Allows you to retrieve report for AgedReceivablesByContact
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Receivables By Contact report (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ReportWithRows
     */
    public function getReportAgedReceivablesByContact($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        list($response) = $this->getReportAgedReceivablesByContactWithHttpInfo($contactId, $date, $fromDate, $toDate);
        return $response;
    }

    /**
     * Operation getReportAgedReceivablesByContactWithHttpInfo
     *
     * Allows you to retrieve report for AgedReceivablesByContact
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Receivables By Contact report (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportAgedReceivablesByContactWithHttpInfo($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        $request = $this->getReportAgedReceivablesByContactRequest($contactId, $date, $fromDate, $toDate);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ReportWithRows' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReportAgedReceivablesByContactAsync
     *
     * Allows you to retrieve report for AgedReceivablesByContact
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Receivables By Contact report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportAgedReceivablesByContactAsync($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        return $this->getReportAgedReceivablesByContactAsyncWithHttpInfo($contactId, $date, $fromDate, $toDate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReportAgedReceivablesByContactAsyncWithHttpInfo
     *
     * Allows you to retrieve report for AgedReceivablesByContact
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Receivables By Contact report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportAgedReceivablesByContactAsyncWithHttpInfo($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
        $request = $this->getReportAgedReceivablesByContactRequest($contactId, $date, $fromDate, $toDate);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReportAgedReceivablesByContact'
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Receivables By Contact report (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReportAgedReceivablesByContactRequest($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        // verify the required parameter 'contactId' is set
        if ($contactId === null || (is_array($contactId) && count($contactId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactId when calling getReportAgedReceivablesByContact'
            );
        }

        $resourcePath = '/Reports/AgedReceivablesByContact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contactId !== null) {
            $queryParams['contactId'] = ObjectSerializer::toQueryValue($contactId);
        }
        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($fromDate !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($fromDate);
        }
        // query params
        if ($toDate !== null) {
            $queryParams['toDate'] = ObjectSerializer::toQueryValue($toDate);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportBASorGST
     *
     * Allows you to retrieve report for BAS only valid for AU orgs
     *
     * @param  string $reportID Unique identifier for a Report (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ReportWithRows
     */
    public function getReportBASorGST($reportID)
    {
        list($response) = $this->getReportBASorGSTWithHttpInfo($reportID);
        return $response;
    }

    /**
     * Operation getReportBASorGSTWithHttpInfo
     *
     * Allows you to retrieve report for BAS only valid for AU orgs
     *
     * @param  string $reportID Unique identifier for a Report (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportBASorGSTWithHttpInfo($reportID)
    {
        $request = $this->getReportBASorGSTRequest($reportID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ReportWithRows' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReportBASorGSTAsync
     *
     * Allows you to retrieve report for BAS only valid for AU orgs
     *
     * @param  string $reportID Unique identifier for a Report (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportBASorGSTAsync($reportID)
    {
        return $this->getReportBASorGSTAsyncWithHttpInfo($reportID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReportBASorGSTAsyncWithHttpInfo
     *
     * Allows you to retrieve report for BAS only valid for AU orgs
     *
     * @param  string $reportID Unique identifier for a Report (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportBASorGSTAsyncWithHttpInfo($reportID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
        $request = $this->getReportBASorGSTRequest($reportID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReportBASorGST'
     *
     * @param  string $reportID Unique identifier for a Report (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReportBASorGSTRequest($reportID)
    {
        // verify the required parameter 'reportID' is set
        if ($reportID === null || (is_array($reportID) && count($reportID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reportID when calling getReportBASorGST'
            );
        }

        $resourcePath = '/Reports/{ReportID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($reportID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReportID' . '}',
                ObjectSerializer::toPathValue($reportID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportBASorGSTList
     *
     * Allows you to retrieve report for BAS only valid for AU orgs
     *
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ReportWithRows
     */
    public function getReportBASorGSTList()
    {
        list($response) = $this->getReportBASorGSTListWithHttpInfo();
        return $response;
    }

    /**
     * Operation getReportBASorGSTListWithHttpInfo
     *
     * Allows you to retrieve report for BAS only valid for AU orgs
     *
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportBASorGSTListWithHttpInfo()
    {
        $request = $this->getReportBASorGSTListRequest();

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ReportWithRows' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReportBASorGSTListAsync
     *
     * Allows you to retrieve report for BAS only valid for AU orgs
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportBASorGSTListAsync()
    {
        return $this->getReportBASorGSTListAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReportBASorGSTListAsyncWithHttpInfo
     *
     * Allows you to retrieve report for BAS only valid for AU orgs
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportBASorGSTListAsyncWithHttpInfo()
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
        $request = $this->getReportBASorGSTListRequest();

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReportBASorGSTList'
     *
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReportBASorGSTListRequest()
    {

        $resourcePath = '/Reports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportBalanceSheet
     *
     * Allows you to retrieve report for BalanceSheet
     *
     * @param  string $date The date of the Balance Sheet report (optional)
     * @param  int $periods The number of periods for the Balance Sheet report (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingOptionID1 The tracking option 1 for the Balance Sheet report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the Balance Sheet report (optional)
     * @param  bool $standardLayout The standard layout boolean for the Balance Sheet report (optional)
     * @param  bool $paymentsOnly return a cash basis for the Balance Sheet report (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ReportWithRows
     */
    public function getReportBalanceSheet($date = null, $periods = null, $timeframe = null, $trackingOptionID1 = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {
        list($response) = $this->getReportBalanceSheetWithHttpInfo($date, $periods, $timeframe, $trackingOptionID1, $trackingOptionID2, $standardLayout, $paymentsOnly);
        return $response;
    }

    /**
     * Operation getReportBalanceSheetWithHttpInfo
     *
     * Allows you to retrieve report for BalanceSheet
     *
     * @param  string $date The date of the Balance Sheet report (optional)
     * @param  int $periods The number of periods for the Balance Sheet report (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingOptionID1 The tracking option 1 for the Balance Sheet report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the Balance Sheet report (optional)
     * @param  bool $standardLayout The standard layout boolean for the Balance Sheet report (optional)
     * @param  bool $paymentsOnly return a cash basis for the Balance Sheet report (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportBalanceSheetWithHttpInfo($date = null, $periods = null, $timeframe = null, $trackingOptionID1 = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {
        $request = $this->getReportBalanceSheetRequest($date, $periods, $timeframe, $trackingOptionID1, $trackingOptionID2, $standardLayout, $paymentsOnly);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ReportWithRows' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReportBalanceSheetAsync
     *
     * Allows you to retrieve report for BalanceSheet
     *
     * @param  string $date The date of the Balance Sheet report (optional)
     * @param  int $periods The number of periods for the Balance Sheet report (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingOptionID1 The tracking option 1 for the Balance Sheet report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the Balance Sheet report (optional)
     * @param  bool $standardLayout The standard layout boolean for the Balance Sheet report (optional)
     * @param  bool $paymentsOnly return a cash basis for the Balance Sheet report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportBalanceSheetAsync($date = null, $periods = null, $timeframe = null, $trackingOptionID1 = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {
        return $this->getReportBalanceSheetAsyncWithHttpInfo($date, $periods, $timeframe, $trackingOptionID1, $trackingOptionID2, $standardLayout, $paymentsOnly)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReportBalanceSheetAsyncWithHttpInfo
     *
     * Allows you to retrieve report for BalanceSheet
     *
     * @param  string $date The date of the Balance Sheet report (optional)
     * @param  int $periods The number of periods for the Balance Sheet report (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingOptionID1 The tracking option 1 for the Balance Sheet report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the Balance Sheet report (optional)
     * @param  bool $standardLayout The standard layout boolean for the Balance Sheet report (optional)
     * @param  bool $paymentsOnly return a cash basis for the Balance Sheet report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportBalanceSheetAsyncWithHttpInfo($date = null, $periods = null, $timeframe = null, $trackingOptionID1 = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
        $request = $this->getReportBalanceSheetRequest($date, $periods, $timeframe, $trackingOptionID1, $trackingOptionID2, $standardLayout, $paymentsOnly);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReportBalanceSheet'
     *
     * @param  string $date The date of the Balance Sheet report (optional)
     * @param  int $periods The number of periods for the Balance Sheet report (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingOptionID1 The tracking option 1 for the Balance Sheet report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the Balance Sheet report (optional)
     * @param  bool $standardLayout The standard layout boolean for the Balance Sheet report (optional)
     * @param  bool $paymentsOnly return a cash basis for the Balance Sheet report (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReportBalanceSheetRequest($date = null, $periods = null, $timeframe = null, $trackingOptionID1 = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {

        $resourcePath = '/Reports/BalanceSheet';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($periods !== null) {
            $queryParams['periods'] = ObjectSerializer::toQueryValue($periods);
        }
        // query params
        if ($timeframe !== null) {
            $queryParams['timeframe'] = ObjectSerializer::toQueryValue($timeframe);
        }
        // query params
        if ($trackingOptionID1 !== null) {
            $queryParams['trackingOptionID1'] = ObjectSerializer::toQueryValue($trackingOptionID1);
        }
        // query params
        if ($trackingOptionID2 !== null) {
            $queryParams['trackingOptionID2'] = ObjectSerializer::toQueryValue($trackingOptionID2);
        }
        // query params
        if ($standardLayout !== null) {
            $queryParams['standardLayout'] = ObjectSerializer::toQueryValue($standardLayout);
        }
        // query params
        if ($paymentsOnly !== null) {
            $queryParams['paymentsOnly'] = ObjectSerializer::toQueryValue($paymentsOnly);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportBankSummary
     *
     * Allows you to retrieve report for BankSummary
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ReportWithRows
     */
    public function getReportBankSummary($date = null, $period = null, $timeframe = null)
    {
        list($response) = $this->getReportBankSummaryWithHttpInfo($date, $period, $timeframe);
        return $response;
    }

    /**
     * Operation getReportBankSummaryWithHttpInfo
     *
     * Allows you to retrieve report for BankSummary
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportBankSummaryWithHttpInfo($date = null, $period = null, $timeframe = null)
    {
        $request = $this->getReportBankSummaryRequest($date, $period, $timeframe);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ReportWithRows' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReportBankSummaryAsync
     *
     * Allows you to retrieve report for BankSummary
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportBankSummaryAsync($date = null, $period = null, $timeframe = null)
    {
        return $this->getReportBankSummaryAsyncWithHttpInfo($date, $period, $timeframe)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReportBankSummaryAsyncWithHttpInfo
     *
     * Allows you to retrieve report for BankSummary
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportBankSummaryAsyncWithHttpInfo($date = null, $period = null, $timeframe = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
        $request = $this->getReportBankSummaryRequest($date, $period, $timeframe);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReportBankSummary'
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReportBankSummaryRequest($date = null, $period = null, $timeframe = null)
    {

        $resourcePath = '/Reports/BankSummary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($period !== null) {
            $queryParams['period'] = ObjectSerializer::toQueryValue($period);
        }
        // query params
        if ($timeframe !== null) {
            $queryParams['timeframe'] = ObjectSerializer::toQueryValue($timeframe);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportBudgetSummary
     *
     * Allows you to retrieve report for Budget Summary
     *
     * @param  \DateTime $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ReportWithRows
     */
    public function getReportBudgetSummary($date = null, $period = null, $timeframe = null)
    {
        list($response) = $this->getReportBudgetSummaryWithHttpInfo($date, $period, $timeframe);
        return $response;
    }

    /**
     * Operation getReportBudgetSummaryWithHttpInfo
     *
     * Allows you to retrieve report for Budget Summary
     *
     * @param  \DateTime $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportBudgetSummaryWithHttpInfo($date = null, $period = null, $timeframe = null)
    {
        $request = $this->getReportBudgetSummaryRequest($date, $period, $timeframe);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ReportWithRows' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReportBudgetSummaryAsync
     *
     * Allows you to retrieve report for Budget Summary
     *
     * @param  \DateTime $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportBudgetSummaryAsync($date = null, $period = null, $timeframe = null)
    {
        return $this->getReportBudgetSummaryAsyncWithHttpInfo($date, $period, $timeframe)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReportBudgetSummaryAsyncWithHttpInfo
     *
     * Allows you to retrieve report for Budget Summary
     *
     * @param  \DateTime $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportBudgetSummaryAsyncWithHttpInfo($date = null, $period = null, $timeframe = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
        $request = $this->getReportBudgetSummaryRequest($date, $period, $timeframe);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReportBudgetSummary'
     *
     * @param  \DateTime $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReportBudgetSummaryRequest($date = null, $period = null, $timeframe = null)
    {

        $resourcePath = '/Reports/BudgetSummary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($period !== null) {
            $queryParams['period'] = ObjectSerializer::toQueryValue($period);
        }
        // query params
        if ($timeframe !== null) {
            $queryParams['timeframe'] = ObjectSerializer::toQueryValue($timeframe);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportExecutiveSummary
     *
     * Allows you to retrieve report for ExecutiveSummary
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ReportWithRows
     */
    public function getReportExecutiveSummary($date = null)
    {
        list($response) = $this->getReportExecutiveSummaryWithHttpInfo($date);
        return $response;
    }

    /**
     * Operation getReportExecutiveSummaryWithHttpInfo
     *
     * Allows you to retrieve report for ExecutiveSummary
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportExecutiveSummaryWithHttpInfo($date = null)
    {
        $request = $this->getReportExecutiveSummaryRequest($date);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ReportWithRows' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReportExecutiveSummaryAsync
     *
     * Allows you to retrieve report for ExecutiveSummary
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportExecutiveSummaryAsync($date = null)
    {
        return $this->getReportExecutiveSummaryAsyncWithHttpInfo($date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReportExecutiveSummaryAsyncWithHttpInfo
     *
     * Allows you to retrieve report for ExecutiveSummary
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportExecutiveSummaryAsyncWithHttpInfo($date = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
        $request = $this->getReportExecutiveSummaryRequest($date);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReportExecutiveSummary'
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReportExecutiveSummaryRequest($date = null)
    {

        $resourcePath = '/Reports/ExecutiveSummary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportProfitAndLoss
     *
     * Allows you to retrieve report for ProfitAndLoss
     *
     * @param  string $fromDate The from date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  string $toDate The to date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  int $periods The number of periods to compare (integer between 1 and 12) (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingCategoryID The trackingCategory 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingCategoryID2 The trackingCategory 2 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID The tracking option 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the ProfitAndLoss report (optional)
     * @param  bool $standardLayout Return the standard layout for the ProfitAndLoss report (optional)
     * @param  bool $paymentsOnly Return cash only basis for the ProfitAndLoss report (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ReportWithRows
     */
    public function getReportProfitAndLoss($fromDate = null, $toDate = null, $periods = null, $timeframe = null, $trackingCategoryID = null, $trackingCategoryID2 = null, $trackingOptionID = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {
        list($response) = $this->getReportProfitAndLossWithHttpInfo($fromDate, $toDate, $periods, $timeframe, $trackingCategoryID, $trackingCategoryID2, $trackingOptionID, $trackingOptionID2, $standardLayout, $paymentsOnly);
        return $response;
    }

    /**
     * Operation getReportProfitAndLossWithHttpInfo
     *
     * Allows you to retrieve report for ProfitAndLoss
     *
     * @param  string $fromDate The from date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  string $toDate The to date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  int $periods The number of periods to compare (integer between 1 and 12) (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingCategoryID The trackingCategory 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingCategoryID2 The trackingCategory 2 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID The tracking option 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the ProfitAndLoss report (optional)
     * @param  bool $standardLayout Return the standard layout for the ProfitAndLoss report (optional)
     * @param  bool $paymentsOnly Return cash only basis for the ProfitAndLoss report (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportProfitAndLossWithHttpInfo($fromDate = null, $toDate = null, $periods = null, $timeframe = null, $trackingCategoryID = null, $trackingCategoryID2 = null, $trackingOptionID = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {
        $request = $this->getReportProfitAndLossRequest($fromDate, $toDate, $periods, $timeframe, $trackingCategoryID, $trackingCategoryID2, $trackingOptionID, $trackingOptionID2, $standardLayout, $paymentsOnly);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ReportWithRows' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReportProfitAndLossAsync
     *
     * Allows you to retrieve report for ProfitAndLoss
     *
     * @param  string $fromDate The from date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  string $toDate The to date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  int $periods The number of periods to compare (integer between 1 and 12) (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingCategoryID The trackingCategory 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingCategoryID2 The trackingCategory 2 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID The tracking option 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the ProfitAndLoss report (optional)
     * @param  bool $standardLayout Return the standard layout for the ProfitAndLoss report (optional)
     * @param  bool $paymentsOnly Return cash only basis for the ProfitAndLoss report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportProfitAndLossAsync($fromDate = null, $toDate = null, $periods = null, $timeframe = null, $trackingCategoryID = null, $trackingCategoryID2 = null, $trackingOptionID = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {
        return $this->getReportProfitAndLossAsyncWithHttpInfo($fromDate, $toDate, $periods, $timeframe, $trackingCategoryID, $trackingCategoryID2, $trackingOptionID, $trackingOptionID2, $standardLayout, $paymentsOnly)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReportProfitAndLossAsyncWithHttpInfo
     *
     * Allows you to retrieve report for ProfitAndLoss
     *
     * @param  string $fromDate The from date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  string $toDate The to date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  int $periods The number of periods to compare (integer between 1 and 12) (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingCategoryID The trackingCategory 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingCategoryID2 The trackingCategory 2 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID The tracking option 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the ProfitAndLoss report (optional)
     * @param  bool $standardLayout Return the standard layout for the ProfitAndLoss report (optional)
     * @param  bool $paymentsOnly Return cash only basis for the ProfitAndLoss report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportProfitAndLossAsyncWithHttpInfo($fromDate = null, $toDate = null, $periods = null, $timeframe = null, $trackingCategoryID = null, $trackingCategoryID2 = null, $trackingOptionID = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
        $request = $this->getReportProfitAndLossRequest($fromDate, $toDate, $periods, $timeframe, $trackingCategoryID, $trackingCategoryID2, $trackingOptionID, $trackingOptionID2, $standardLayout, $paymentsOnly);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReportProfitAndLoss'
     *
     * @param  string $fromDate The from date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  string $toDate The to date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  int $periods The number of periods to compare (integer between 1 and 12) (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingCategoryID The trackingCategory 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingCategoryID2 The trackingCategory 2 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID The tracking option 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the ProfitAndLoss report (optional)
     * @param  bool $standardLayout Return the standard layout for the ProfitAndLoss report (optional)
     * @param  bool $paymentsOnly Return cash only basis for the ProfitAndLoss report (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReportProfitAndLossRequest($fromDate = null, $toDate = null, $periods = null, $timeframe = null, $trackingCategoryID = null, $trackingCategoryID2 = null, $trackingOptionID = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {

        $resourcePath = '/Reports/ProfitAndLoss';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fromDate !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($fromDate);
        }
        // query params
        if ($toDate !== null) {
            $queryParams['toDate'] = ObjectSerializer::toQueryValue($toDate);
        }
        // query params
        if ($periods !== null) {
            $queryParams['periods'] = ObjectSerializer::toQueryValue($periods);
        }
        // query params
        if ($timeframe !== null) {
            $queryParams['timeframe'] = ObjectSerializer::toQueryValue($timeframe);
        }
        // query params
        if ($trackingCategoryID !== null) {
            $queryParams['trackingCategoryID'] = ObjectSerializer::toQueryValue($trackingCategoryID);
        }
        // query params
        if ($trackingCategoryID2 !== null) {
            $queryParams['trackingCategoryID2'] = ObjectSerializer::toQueryValue($trackingCategoryID2);
        }
        // query params
        if ($trackingOptionID !== null) {
            $queryParams['trackingOptionID'] = ObjectSerializer::toQueryValue($trackingOptionID);
        }
        // query params
        if ($trackingOptionID2 !== null) {
            $queryParams['trackingOptionID2'] = ObjectSerializer::toQueryValue($trackingOptionID2);
        }
        // query params
        if ($standardLayout !== null) {
            $queryParams['standardLayout'] = ObjectSerializer::toQueryValue($standardLayout);
        }
        // query params
        if ($paymentsOnly !== null) {
            $queryParams['paymentsOnly'] = ObjectSerializer::toQueryValue($paymentsOnly);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportTenNinetyNine
     *
     * Allows you to retrieve report for TenNinetyNine
     *
     * @param  string $reportYear The year of the 1099 report (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Reports
     */
    public function getReportTenNinetyNine($reportYear = null)
    {
        list($response) = $this->getReportTenNinetyNineWithHttpInfo($reportYear);
        return $response;
    }

    /**
     * Operation getReportTenNinetyNineWithHttpInfo
     *
     * Allows you to retrieve report for TenNinetyNine
     *
     * @param  string $reportYear The year of the 1099 report (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Reports, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportTenNinetyNineWithHttpInfo($reportYear = null)
    {
        $request = $this->getReportTenNinetyNineRequest($reportYear);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Reports' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Reports', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Reports';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Reports',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReportTenNinetyNineAsync
     *
     * Allows you to retrieve report for TenNinetyNine
     *
     * @param  string $reportYear The year of the 1099 report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportTenNinetyNineAsync($reportYear = null)
    {
        return $this->getReportTenNinetyNineAsyncWithHttpInfo($reportYear)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReportTenNinetyNineAsyncWithHttpInfo
     *
     * Allows you to retrieve report for TenNinetyNine
     *
     * @param  string $reportYear The year of the 1099 report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportTenNinetyNineAsyncWithHttpInfo($reportYear = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Reports';
        $request = $this->getReportTenNinetyNineRequest($reportYear);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReportTenNinetyNine'
     *
     * @param  string $reportYear The year of the 1099 report (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReportTenNinetyNineRequest($reportYear = null)
    {

        $resourcePath = '/Reports/TenNinetyNine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($reportYear !== null) {
            $queryParams['reportYear'] = ObjectSerializer::toQueryValue($reportYear);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportTrialBalance
     *
     * Allows you to retrieve report for TrialBalance
     *
     * @param  string $date The date for the Trial Balance report e.g. 2018-03-31 (optional)
     * @param  bool $paymentsOnly Return cash only basis for the Trial Balance report (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ReportWithRows
     */
    public function getReportTrialBalance($date = null, $paymentsOnly = null)
    {
        list($response) = $this->getReportTrialBalanceWithHttpInfo($date, $paymentsOnly);
        return $response;
    }

    /**
     * Operation getReportTrialBalanceWithHttpInfo
     *
     * Allows you to retrieve report for TrialBalance
     *
     * @param  string $date The date for the Trial Balance report e.g. 2018-03-31 (optional)
     * @param  bool $paymentsOnly Return cash only basis for the Trial Balance report (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportTrialBalanceWithHttpInfo($date = null, $paymentsOnly = null)
    {
        $request = $this->getReportTrialBalanceRequest($date, $paymentsOnly);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ReportWithRows' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReportTrialBalanceAsync
     *
     * Allows you to retrieve report for TrialBalance
     *
     * @param  string $date The date for the Trial Balance report e.g. 2018-03-31 (optional)
     * @param  bool $paymentsOnly Return cash only basis for the Trial Balance report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportTrialBalanceAsync($date = null, $paymentsOnly = null)
    {
        return $this->getReportTrialBalanceAsyncWithHttpInfo($date, $paymentsOnly)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReportTrialBalanceAsyncWithHttpInfo
     *
     * Allows you to retrieve report for TrialBalance
     *
     * @param  string $date The date for the Trial Balance report e.g. 2018-03-31 (optional)
     * @param  bool $paymentsOnly Return cash only basis for the Trial Balance report (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReportTrialBalanceAsyncWithHttpInfo($date = null, $paymentsOnly = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ReportWithRows';
        $request = $this->getReportTrialBalanceRequest($date, $paymentsOnly);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReportTrialBalance'
     *
     * @param  string $date The date for the Trial Balance report e.g. 2018-03-31 (optional)
     * @param  bool $paymentsOnly Return cash only basis for the Trial Balance report (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getReportTrialBalanceRequest($date = null, $paymentsOnly = null)
    {

        $resourcePath = '/Reports/TrialBalance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($paymentsOnly !== null) {
            $queryParams['paymentsOnly'] = ObjectSerializer::toQueryValue($paymentsOnly);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getTaxRates
     *
     * Allows you to retrieve Tax Rates
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $taxType Filter by tax type (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\TaxRates
     */
    public function getTaxRates($where = null, $order = null, $taxType = null)
    {
        list($response) = $this->getTaxRatesWithHttpInfo($where, $order, $taxType);
        return $response;
    }

    /**
     * Operation getTaxRatesWithHttpInfo
     *
     * Allows you to retrieve Tax Rates
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $taxType Filter by tax type (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\TaxRates, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTaxRatesWithHttpInfo($where = null, $order = null, $taxType = null)
    {
        $request = $this->getTaxRatesRequest($where, $order, $taxType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\TaxRates' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\TaxRates', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\TaxRates';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\TaxRates',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTaxRatesAsync
     *
     * Allows you to retrieve Tax Rates
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $taxType Filter by tax type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaxRatesAsync($where = null, $order = null, $taxType = null)
    {
        return $this->getTaxRatesAsyncWithHttpInfo($where, $order, $taxType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTaxRatesAsyncWithHttpInfo
     *
     * Allows you to retrieve Tax Rates
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $taxType Filter by tax type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaxRatesAsyncWithHttpInfo($where = null, $order = null, $taxType = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\TaxRates';
        $request = $this->getTaxRatesRequest($where, $order, $taxType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTaxRates'
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $taxType Filter by tax type (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getTaxRatesRequest($where = null, $order = null, $taxType = null)
    {

        $resourcePath = '/TaxRates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($taxType !== null) {
            $queryParams['TaxType'] = ObjectSerializer::toQueryValue($taxType);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getTrackingCategories
     *
     * Allows you to retrieve tracking categories and options
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Categories and options with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\TrackingCategories
     */
    public function getTrackingCategories($where = null, $order = null, $includeArchived = null)
    {
        list($response) = $this->getTrackingCategoriesWithHttpInfo($where, $order, $includeArchived);
        return $response;
    }

    /**
     * Operation getTrackingCategoriesWithHttpInfo
     *
     * Allows you to retrieve tracking categories and options
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Categories and options with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\TrackingCategories, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTrackingCategoriesWithHttpInfo($where = null, $order = null, $includeArchived = null)
    {
        $request = $this->getTrackingCategoriesRequest($where, $order, $includeArchived);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\TrackingCategories' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTrackingCategoriesAsync
     *
     * Allows you to retrieve tracking categories and options
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Categories and options with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrackingCategoriesAsync($where = null, $order = null, $includeArchived = null)
    {
        return $this->getTrackingCategoriesAsyncWithHttpInfo($where, $order, $includeArchived)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTrackingCategoriesAsyncWithHttpInfo
     *
     * Allows you to retrieve tracking categories and options
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Categories and options with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrackingCategoriesAsyncWithHttpInfo($where = null, $order = null, $includeArchived = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories';
        $request = $this->getTrackingCategoriesRequest($where, $order, $includeArchived);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTrackingCategories'
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Categories and options with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getTrackingCategoriesRequest($where = null, $order = null, $includeArchived = null)
    {

        $resourcePath = '/TrackingCategories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($includeArchived !== null) {
            $queryParams['includeArchived'] = ObjectSerializer::toQueryValue($includeArchived);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getTrackingCategory
     *
     * Allows you to retrieve tracking categories and options for specified category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\TrackingCategories
     */
    public function getTrackingCategory($trackingCategoryID)
    {
        list($response) = $this->getTrackingCategoryWithHttpInfo($trackingCategoryID);
        return $response;
    }

    /**
     * Operation getTrackingCategoryWithHttpInfo
     *
     * Allows you to retrieve tracking categories and options for specified category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\TrackingCategories, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTrackingCategoryWithHttpInfo($trackingCategoryID)
    {
        $request = $this->getTrackingCategoryRequest($trackingCategoryID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\TrackingCategories' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTrackingCategoryAsync
     *
     * Allows you to retrieve tracking categories and options for specified category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrackingCategoryAsync($trackingCategoryID)
    {
        return $this->getTrackingCategoryAsyncWithHttpInfo($trackingCategoryID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTrackingCategoryAsyncWithHttpInfo
     *
     * Allows you to retrieve tracking categories and options for specified category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrackingCategoryAsyncWithHttpInfo($trackingCategoryID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories';
        $request = $this->getTrackingCategoryRequest($trackingCategoryID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTrackingCategory'
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getTrackingCategoryRequest($trackingCategoryID)
    {
        // verify the required parameter 'trackingCategoryID' is set
        if ($trackingCategoryID === null || (is_array($trackingCategoryID) && count($trackingCategoryID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trackingCategoryID when calling getTrackingCategory'
            );
        }

        $resourcePath = '/TrackingCategories/{TrackingCategoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($trackingCategoryID !== null) {
            $resourcePath = str_replace(
                '{' . 'TrackingCategoryID' . '}',
                ObjectSerializer::toPathValue($trackingCategoryID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getUser
     *
     * Allows you to retrieve a specified user
     *
     * @param  string $userID Unique identifier for a User (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Users
     */
    public function getUser($userID)
    {
        list($response) = $this->getUserWithHttpInfo($userID);
        return $response;
    }

    /**
     * Operation getUserWithHttpInfo
     *
     * Allows you to retrieve a specified user
     *
     * @param  string $userID Unique identifier for a User (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Users, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserWithHttpInfo($userID)
    {
        $request = $this->getUserRequest($userID);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Users' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Users', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Users';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Users',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserAsync
     *
     * Allows you to retrieve a specified user
     *
     * @param  string $userID Unique identifier for a User (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAsync($userID)
    {
        return $this->getUserAsyncWithHttpInfo($userID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified user
     *
     * @param  string $userID Unique identifier for a User (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAsyncWithHttpInfo($userID)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Users';
        $request = $this->getUserRequest($userID);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUser'
     *
     * @param  string $userID Unique identifier for a User (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getUserRequest($userID)
    {
        // verify the required parameter 'userID' is set
        if ($userID === null || (is_array($userID) && count($userID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userID when calling getUser'
            );
        }

        $resourcePath = '/Users/{UserID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($userID !== null) {
            $resourcePath = str_replace(
                '{' . 'UserID' . '}',
                ObjectSerializer::toPathValue($userID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getUsers
     *
     * Allows you to retrieve users
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Users
     */
    public function getUsers($ifModifiedSince = null, $where = null, $order = null)
    {
        list($response) = $this->getUsersWithHttpInfo($ifModifiedSince, $where, $order);
        return $response;
    }

    /**
     * Operation getUsersWithHttpInfo
     *
     * Allows you to retrieve users
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Users, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUsersWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getUsersRequest($ifModifiedSince, $where, $order);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Users' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Users', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Users';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Users',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUsersAsync
     *
     * Allows you to retrieve users
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUsersAsync($ifModifiedSince = null, $where = null, $order = null)
    {
        return $this->getUsersAsyncWithHttpInfo($ifModifiedSince, $where, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUsersAsyncWithHttpInfo
     *
     * Allows you to retrieve users
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUsersAsyncWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Users';
        $request = $this->getUsersRequest($ifModifiedSince, $where, $order);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUsers'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getUsersRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/Users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateAccount
     *
     * Allows you to update a chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Accounts $accounts Request of type Accounts array with one Account (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Accounts|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateAccount($accountID, $accounts)
    {
        list($response) = $this->updateAccountWithHttpInfo($accountID, $accounts);
        return $response;
    }

    /**
     * Operation updateAccountWithHttpInfo
     *
     * Allows you to update a chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Accounts $accounts Request of type Accounts array with one Account (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Accounts|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAccountWithHttpInfo($accountID, $accounts)
    {
        $request = $this->updateAccountRequest($accountID, $accounts);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Accounts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Accounts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Accounts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Accounts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAccountAsync
     *
     * Allows you to update a chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Accounts $accounts Request of type Accounts array with one Account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAccountAsync($accountID, $accounts)
    {
        return $this->updateAccountAsyncWithHttpInfo($accountID, $accounts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAccountAsyncWithHttpInfo
     *
     * Allows you to update a chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Accounts $accounts Request of type Accounts array with one Account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAccountAsyncWithHttpInfo($accountID, $accounts)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Accounts';
        $request = $this->updateAccountRequest($accountID, $accounts);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAccount'
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Accounts $accounts Request of type Accounts array with one Account (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateAccountRequest($accountID, $accounts)
    {
        // verify the required parameter 'accountID' is set
        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountID when calling updateAccount'
            );
        }
        // verify the required parameter 'accounts' is set
        if ($accounts === null || (is_array($accounts) && count($accounts) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accounts when calling updateAccount'
            );
        }

        $resourcePath = '/Accounts/{AccountID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($accounts)) {
            $_tempBody = $accounts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateAccountAttachmentByFileName
     *
     * Allows you to update Attachment on Account by Filename
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateAccountAttachmentByFileName($accountID, $fileName, $body)
    {
        list($response) = $this->updateAccountAttachmentByFileNameWithHttpInfo($accountID, $fileName, $body);
        return $response;
    }

    /**
     * Operation updateAccountAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update Attachment on Account by Filename
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAccountAttachmentByFileNameWithHttpInfo($accountID, $fileName, $body)
    {
        $request = $this->updateAccountAttachmentByFileNameRequest($accountID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAccountAttachmentByFileNameAsync
     *
     * Allows you to update Attachment on Account by Filename
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAccountAttachmentByFileNameAsync($accountID, $fileName, $body)
    {
        return $this->updateAccountAttachmentByFileNameAsyncWithHttpInfo($accountID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAccountAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to update Attachment on Account by Filename
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAccountAttachmentByFileNameAsyncWithHttpInfo($accountID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->updateAccountAttachmentByFileNameRequest($accountID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAccountAttachmentByFileName'
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateAccountAttachmentByFileNameRequest($accountID, $fileName, $body)
    {
        // verify the required parameter 'accountID' is set
        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountID when calling updateAccountAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling updateAccountAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateAccountAttachmentByFileName'
            );
        }

        $resourcePath = '/Accounts/{AccountID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateBankTransaction
     *
     * Allows you to update a single spend or receive money transaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransactions $bankTransactions bankTransactions (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\BankTransactions|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateBankTransaction($bankTransactionID, $bankTransactions)
    {
        list($response) = $this->updateBankTransactionWithHttpInfo($bankTransactionID, $bankTransactions);
        return $response;
    }

    /**
     * Operation updateBankTransactionWithHttpInfo
     *
     * Allows you to update a single spend or receive money transaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransactions $bankTransactions (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\BankTransactions|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBankTransactionWithHttpInfo($bankTransactionID, $bankTransactions)
    {
        $request = $this->updateBankTransactionRequest($bankTransactionID, $bankTransactions);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\BankTransactions' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\BankTransactions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransactions';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\BankTransactions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateBankTransactionAsync
     *
     * Allows you to update a single spend or receive money transaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransactions $bankTransactions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBankTransactionAsync($bankTransactionID, $bankTransactions)
    {
        return $this->updateBankTransactionAsyncWithHttpInfo($bankTransactionID, $bankTransactions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBankTransactionAsyncWithHttpInfo
     *
     * Allows you to update a single spend or receive money transaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransactions $bankTransactions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBankTransactionAsyncWithHttpInfo($bankTransactionID, $bankTransactions)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\BankTransactions';
        $request = $this->updateBankTransactionRequest($bankTransactionID, $bankTransactions);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBankTransaction'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\BankTransactions $bankTransactions (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateBankTransactionRequest($bankTransactionID, $bankTransactions)
    {
        // verify the required parameter 'bankTransactionID' is set
        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransactionID when calling updateBankTransaction'
            );
        }
        // verify the required parameter 'bankTransactions' is set
        if ($bankTransactions === null || (is_array($bankTransactions) && count($bankTransactions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransactions when calling updateBankTransaction'
            );
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($bankTransactions)) {
            $_tempBody = $bankTransactions;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateBankTransactionAttachmentByFileName
     *
     * Allows you to update an Attachment on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateBankTransactionAttachmentByFileName($bankTransactionID, $fileName, $body)
    {
        list($response) = $this->updateBankTransactionAttachmentByFileNameWithHttpInfo($bankTransactionID, $fileName, $body);
        return $response;
    }

    /**
     * Operation updateBankTransactionAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update an Attachment on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBankTransactionAttachmentByFileNameWithHttpInfo($bankTransactionID, $fileName, $body)
    {
        $request = $this->updateBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateBankTransactionAttachmentByFileNameAsync
     *
     * Allows you to update an Attachment on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBankTransactionAttachmentByFileNameAsync($bankTransactionID, $fileName, $body)
    {
        return $this->updateBankTransactionAttachmentByFileNameAsyncWithHttpInfo($bankTransactionID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBankTransactionAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to update an Attachment on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBankTransactionAttachmentByFileNameAsyncWithHttpInfo($bankTransactionID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->updateBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBankTransactionAttachmentByFileName'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $body)
    {
        // verify the required parameter 'bankTransactionID' is set
        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransactionID when calling updateBankTransactionAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling updateBankTransactionAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateBankTransactionAttachmentByFileName'
            );
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateBankTransferAttachmentByFileName
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateBankTransferAttachmentByFileName($bankTransferID, $fileName, $body)
    {
        list($response) = $this->updateBankTransferAttachmentByFileNameWithHttpInfo($bankTransferID, $fileName, $body);
        return $response;
    }

    /**
     * Operation updateBankTransferAttachmentByFileNameWithHttpInfo
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBankTransferAttachmentByFileNameWithHttpInfo($bankTransferID, $fileName, $body)
    {
        $request = $this->updateBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateBankTransferAttachmentByFileNameAsync
     *
     * 
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBankTransferAttachmentByFileNameAsync($bankTransferID, $fileName, $body)
    {
        return $this->updateBankTransferAttachmentByFileNameAsyncWithHttpInfo($bankTransferID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBankTransferAttachmentByFileNameAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBankTransferAttachmentByFileNameAsyncWithHttpInfo($bankTransferID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->updateBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBankTransferAttachmentByFileName'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $body)
    {
        // verify the required parameter 'bankTransferID' is set
        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bankTransferID when calling updateBankTransferAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling updateBankTransferAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateBankTransferAttachmentByFileName'
            );
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateContact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contacts $contacts contacts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Contacts|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateContact($contactID, $contacts = null)
    {
        list($response) = $this->updateContactWithHttpInfo($contactID, $contacts);
        return $response;
    }

    /**
     * Operation updateContactWithHttpInfo
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contacts $contacts (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Contacts|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContactWithHttpInfo($contactID, $contacts = null)
    {
        $request = $this->updateContactRequest($contactID, $contacts);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Contacts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Contacts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Contacts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Contacts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateContactAsync
     *
     * 
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contacts $contacts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContactAsync($contactID, $contacts = null)
    {
        return $this->updateContactAsyncWithHttpInfo($contactID, $contacts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateContactAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contacts $contacts (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContactAsyncWithHttpInfo($contactID, $contacts = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Contacts';
        $request = $this->updateContactRequest($contactID, $contacts);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateContact'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Contacts $contacts (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateContactRequest($contactID, $contacts = null)
    {
        // verify the required parameter 'contactID' is set
        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactID when calling updateContact'
            );
        }

        $resourcePath = '/Contacts/{ContactID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($contacts)) {
            $_tempBody = $contacts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateContactAttachmentByFileName
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateContactAttachmentByFileName($contactID, $fileName, $body)
    {
        list($response) = $this->updateContactAttachmentByFileNameWithHttpInfo($contactID, $fileName, $body);
        return $response;
    }

    /**
     * Operation updateContactAttachmentByFileNameWithHttpInfo
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContactAttachmentByFileNameWithHttpInfo($contactID, $fileName, $body)
    {
        $request = $this->updateContactAttachmentByFileNameRequest($contactID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateContactAttachmentByFileNameAsync
     *
     * 
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContactAttachmentByFileNameAsync($contactID, $fileName, $body)
    {
        return $this->updateContactAttachmentByFileNameAsyncWithHttpInfo($contactID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateContactAttachmentByFileNameAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContactAttachmentByFileNameAsyncWithHttpInfo($contactID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->updateContactAttachmentByFileNameRequest($contactID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateContactAttachmentByFileName'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateContactAttachmentByFileNameRequest($contactID, $fileName, $body)
    {
        // verify the required parameter 'contactID' is set
        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactID when calling updateContactAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling updateContactAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateContactAttachmentByFileName'
            );
        }

        $resourcePath = '/Contacts/{ContactID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateContactGroup
     *
     * Allows you to update a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ContactGroups $contactGroups contactGroups (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ContactGroups|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateContactGroup($contactGroupID, $contactGroups = null)
    {
        list($response) = $this->updateContactGroupWithHttpInfo($contactGroupID, $contactGroups);
        return $response;
    }

    /**
     * Operation updateContactGroupWithHttpInfo
     *
     * Allows you to update a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ContactGroups $contactGroups (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ContactGroups|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContactGroupWithHttpInfo($contactGroupID, $contactGroups = null)
    {
        $request = $this->updateContactGroupRequest($contactGroupID, $contactGroups);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ContactGroups' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ContactGroups', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ContactGroups';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ContactGroups',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateContactGroupAsync
     *
     * Allows you to update a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ContactGroups $contactGroups (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContactGroupAsync($contactGroupID, $contactGroups = null)
    {
        return $this->updateContactGroupAsyncWithHttpInfo($contactGroupID, $contactGroups)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateContactGroupAsyncWithHttpInfo
     *
     * Allows you to update a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ContactGroups $contactGroups (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContactGroupAsyncWithHttpInfo($contactGroupID, $contactGroups = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ContactGroups';
        $request = $this->updateContactGroupRequest($contactGroupID, $contactGroups);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateContactGroup'
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ContactGroups $contactGroups (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateContactGroupRequest($contactGroupID, $contactGroups = null)
    {
        // verify the required parameter 'contactGroupID' is set
        if ($contactGroupID === null || (is_array($contactGroupID) && count($contactGroupID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contactGroupID when calling updateContactGroup'
            );
        }

        $resourcePath = '/ContactGroups/{ContactGroupID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactGroupID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactGroupID' . '}',
                ObjectSerializer::toPathValue($contactGroupID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($contactGroups)) {
            $_tempBody = $contactGroups;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateCreditNote
     *
     * Allows you to update a specific credit note
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\CreditNotes $creditNotes creditNotes (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\CreditNotes|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateCreditNote($creditNoteID, $creditNotes = null)
    {
        list($response) = $this->updateCreditNoteWithHttpInfo($creditNoteID, $creditNotes);
        return $response;
    }

    /**
     * Operation updateCreditNoteWithHttpInfo
     *
     * Allows you to update a specific credit note
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\CreditNotes $creditNotes (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\CreditNotes|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCreditNoteWithHttpInfo($creditNoteID, $creditNotes = null)
    {
        $request = $this->updateCreditNoteRequest($creditNoteID, $creditNotes);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\CreditNotes' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\CreditNotes', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\CreditNotes';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\CreditNotes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCreditNoteAsync
     *
     * Allows you to update a specific credit note
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\CreditNotes $creditNotes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCreditNoteAsync($creditNoteID, $creditNotes = null)
    {
        return $this->updateCreditNoteAsyncWithHttpInfo($creditNoteID, $creditNotes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCreditNoteAsyncWithHttpInfo
     *
     * Allows you to update a specific credit note
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\CreditNotes $creditNotes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCreditNoteAsyncWithHttpInfo($creditNoteID, $creditNotes = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\CreditNotes';
        $request = $this->updateCreditNoteRequest($creditNoteID, $creditNotes);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCreditNote'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\CreditNotes $creditNotes (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateCreditNoteRequest($creditNoteID, $creditNotes = null)
    {
        // verify the required parameter 'creditNoteID' is set
        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $creditNoteID when calling updateCreditNote'
            );
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($creditNotes)) {
            $_tempBody = $creditNotes;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateCreditNoteAttachmentByFileName
     *
     * Allows you to update Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateCreditNoteAttachmentByFileName($creditNoteID, $fileName, $body)
    {
        list($response) = $this->updateCreditNoteAttachmentByFileNameWithHttpInfo($creditNoteID, $fileName, $body);
        return $response;
    }

    /**
     * Operation updateCreditNoteAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCreditNoteAttachmentByFileNameWithHttpInfo($creditNoteID, $fileName, $body)
    {
        $request = $this->updateCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCreditNoteAttachmentByFileNameAsync
     *
     * Allows you to update Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCreditNoteAttachmentByFileNameAsync($creditNoteID, $fileName, $body)
    {
        return $this->updateCreditNoteAttachmentByFileNameAsyncWithHttpInfo($creditNoteID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCreditNoteAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to update Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCreditNoteAttachmentByFileNameAsyncWithHttpInfo($creditNoteID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->updateCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCreditNoteAttachmentByFileName'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $body)
    {
        // verify the required parameter 'creditNoteID' is set
        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $creditNoteID when calling updateCreditNoteAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling updateCreditNoteAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateCreditNoteAttachmentByFileName'
            );
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateEmployee
     *
     * Allows you to update a specific employee used in Xero payrun
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Employees $employees employees (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Employees|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateEmployee($employeeID, $employees)
    {
        list($response) = $this->updateEmployeeWithHttpInfo($employeeID, $employees);
        return $response;
    }

    /**
     * Operation updateEmployeeWithHttpInfo
     *
     * Allows you to update a specific employee used in Xero payrun
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Employees $employees (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Employees|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEmployeeWithHttpInfo($employeeID, $employees)
    {
        $request = $this->updateEmployeeRequest($employeeID, $employees);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Employees' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Employees', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Employees';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Employees',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateEmployeeAsync
     *
     * Allows you to update a specific employee used in Xero payrun
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Employees $employees (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmployeeAsync($employeeID, $employees)
    {
        return $this->updateEmployeeAsyncWithHttpInfo($employeeID, $employees)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEmployeeAsyncWithHttpInfo
     *
     * Allows you to update a specific employee used in Xero payrun
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Employees $employees (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmployeeAsyncWithHttpInfo($employeeID, $employees)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Employees';
        $request = $this->updateEmployeeRequest($employeeID, $employees);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEmployee'
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Employees $employees (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateEmployeeRequest($employeeID, $employees)
    {
        // verify the required parameter 'employeeID' is set
        if ($employeeID === null || (is_array($employeeID) && count($employeeID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employeeID when calling updateEmployee'
            );
        }
        // verify the required parameter 'employees' is set
        if ($employees === null || (is_array($employees) && count($employees) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employees when calling updateEmployee'
            );
        }

        $resourcePath = '/Employees/{EmployeeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($employeeID !== null) {
            $resourcePath = str_replace(
                '{' . 'EmployeeID' . '}',
                ObjectSerializer::toPathValue($employeeID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($employees)) {
            $_tempBody = $employees;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateExpenseClaim
     *
     * Allows you to update specified expense claims
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims $expenseClaims expenseClaims (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateExpenseClaim($expenseClaimID, $expenseClaims)
    {
        list($response) = $this->updateExpenseClaimWithHttpInfo($expenseClaimID, $expenseClaims);
        return $response;
    }

    /**
     * Operation updateExpenseClaimWithHttpInfo
     *
     * Allows you to update specified expense claims
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims $expenseClaims (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateExpenseClaimWithHttpInfo($expenseClaimID, $expenseClaims)
    {
        $request = $this->updateExpenseClaimRequest($expenseClaimID, $expenseClaims);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateExpenseClaimAsync
     *
     * Allows you to update specified expense claims
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims $expenseClaims (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExpenseClaimAsync($expenseClaimID, $expenseClaims)
    {
        return $this->updateExpenseClaimAsyncWithHttpInfo($expenseClaimID, $expenseClaims)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateExpenseClaimAsyncWithHttpInfo
     *
     * Allows you to update specified expense claims
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims $expenseClaims (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExpenseClaimAsyncWithHttpInfo($expenseClaimID, $expenseClaims)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ExpenseClaims';
        $request = $this->updateExpenseClaimRequest($expenseClaimID, $expenseClaims);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateExpenseClaim'
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ExpenseClaims $expenseClaims (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateExpenseClaimRequest($expenseClaimID, $expenseClaims)
    {
        // verify the required parameter 'expenseClaimID' is set
        if ($expenseClaimID === null || (is_array($expenseClaimID) && count($expenseClaimID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $expenseClaimID when calling updateExpenseClaim'
            );
        }
        // verify the required parameter 'expenseClaims' is set
        if ($expenseClaims === null || (is_array($expenseClaims) && count($expenseClaims) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $expenseClaims when calling updateExpenseClaim'
            );
        }

        $resourcePath = '/ExpenseClaims/{ExpenseClaimID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($expenseClaimID !== null) {
            $resourcePath = str_replace(
                '{' . 'ExpenseClaimID' . '}',
                ObjectSerializer::toPathValue($expenseClaimID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($expenseClaims)) {
            $_tempBody = $expenseClaims;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateInvoice
     *
     * Allows you to update a specified sales invoices or purchase bills
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Invoices $invoices invoices (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Invoices|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateInvoice($invoiceID, $invoices)
    {
        list($response) = $this->updateInvoiceWithHttpInfo($invoiceID, $invoices);
        return $response;
    }

    /**
     * Operation updateInvoiceWithHttpInfo
     *
     * Allows you to update a specified sales invoices or purchase bills
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Invoices $invoices (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Invoices|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateInvoiceWithHttpInfo($invoiceID, $invoices)
    {
        $request = $this->updateInvoiceRequest($invoiceID, $invoices);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Invoices' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Invoices', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Invoices';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Invoices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateInvoiceAsync
     *
     * Allows you to update a specified sales invoices or purchase bills
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Invoices $invoices (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInvoiceAsync($invoiceID, $invoices)
    {
        return $this->updateInvoiceAsyncWithHttpInfo($invoiceID, $invoices)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateInvoiceAsyncWithHttpInfo
     *
     * Allows you to update a specified sales invoices or purchase bills
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Invoices $invoices (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInvoiceAsyncWithHttpInfo($invoiceID, $invoices)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Invoices';
        $request = $this->updateInvoiceRequest($invoiceID, $invoices);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateInvoice'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Invoices $invoices (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateInvoiceRequest($invoiceID, $invoices)
    {
        // verify the required parameter 'invoiceID' is set
        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceID when calling updateInvoice'
            );
        }
        // verify the required parameter 'invoices' is set
        if ($invoices === null || (is_array($invoices) && count($invoices) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoices when calling updateInvoice'
            );
        }

        $resourcePath = '/Invoices/{InvoiceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($invoices)) {
            $_tempBody = $invoices;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateInvoiceAttachmentByFileName
     *
     * Allows you to update Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateInvoiceAttachmentByFileName($invoiceID, $fileName, $body)
    {
        list($response) = $this->updateInvoiceAttachmentByFileNameWithHttpInfo($invoiceID, $fileName, $body);
        return $response;
    }

    /**
     * Operation updateInvoiceAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateInvoiceAttachmentByFileNameWithHttpInfo($invoiceID, $fileName, $body)
    {
        $request = $this->updateInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateInvoiceAttachmentByFileNameAsync
     *
     * Allows you to update Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInvoiceAttachmentByFileNameAsync($invoiceID, $fileName, $body)
    {
        return $this->updateInvoiceAttachmentByFileNameAsyncWithHttpInfo($invoiceID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateInvoiceAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to update Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInvoiceAttachmentByFileNameAsyncWithHttpInfo($invoiceID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->updateInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateInvoiceAttachmentByFileName'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $body)
    {
        // verify the required parameter 'invoiceID' is set
        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceID when calling updateInvoiceAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling updateInvoiceAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateInvoiceAttachmentByFileName'
            );
        }

        $resourcePath = '/Invoices/{InvoiceID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateItem
     *
     * Allows you to udpate a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Items $items items (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Items|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateItem($itemID, $items)
    {
        list($response) = $this->updateItemWithHttpInfo($itemID, $items);
        return $response;
    }

    /**
     * Operation updateItemWithHttpInfo
     *
     * Allows you to udpate a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Items $items (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Items|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateItemWithHttpInfo($itemID, $items)
    {
        $request = $this->updateItemRequest($itemID, $items);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Items' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Items', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Items';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Items',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateItemAsync
     *
     * Allows you to udpate a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Items $items (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateItemAsync($itemID, $items)
    {
        return $this->updateItemAsyncWithHttpInfo($itemID, $items)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateItemAsyncWithHttpInfo
     *
     * Allows you to udpate a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Items $items (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateItemAsyncWithHttpInfo($itemID, $items)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Items';
        $request = $this->updateItemRequest($itemID, $items);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateItem'
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Items $items (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateItemRequest($itemID, $items)
    {
        // verify the required parameter 'itemID' is set
        if ($itemID === null || (is_array($itemID) && count($itemID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $itemID when calling updateItem'
            );
        }
        // verify the required parameter 'items' is set
        if ($items === null || (is_array($items) && count($items) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $items when calling updateItem'
            );
        }

        $resourcePath = '/Items/{ItemID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($itemID !== null) {
            $resourcePath = str_replace(
                '{' . 'ItemID' . '}',
                ObjectSerializer::toPathValue($itemID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($items)) {
            $_tempBody = $items;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateLinkedTransaction
     *
     * Allows you to update a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions $linkedTransactions linkedTransactions (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateLinkedTransaction($linkedTransactionID, $linkedTransactions)
    {
        list($response) = $this->updateLinkedTransactionWithHttpInfo($linkedTransactionID, $linkedTransactions);
        return $response;
    }

    /**
     * Operation updateLinkedTransactionWithHttpInfo
     *
     * Allows you to update a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions $linkedTransactions (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateLinkedTransactionWithHttpInfo($linkedTransactionID, $linkedTransactions)
    {
        $request = $this->updateLinkedTransactionRequest($linkedTransactionID, $linkedTransactions);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateLinkedTransactionAsync
     *
     * Allows you to update a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions $linkedTransactions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateLinkedTransactionAsync($linkedTransactionID, $linkedTransactions)
    {
        return $this->updateLinkedTransactionAsyncWithHttpInfo($linkedTransactionID, $linkedTransactions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateLinkedTransactionAsyncWithHttpInfo
     *
     * Allows you to update a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions $linkedTransactions (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateLinkedTransactionAsyncWithHttpInfo($linkedTransactionID, $linkedTransactions)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\LinkedTransactions';
        $request = $this->updateLinkedTransactionRequest($linkedTransactionID, $linkedTransactions);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateLinkedTransaction'
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\LinkedTransactions $linkedTransactions (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateLinkedTransactionRequest($linkedTransactionID, $linkedTransactions)
    {
        // verify the required parameter 'linkedTransactionID' is set
        if ($linkedTransactionID === null || (is_array($linkedTransactionID) && count($linkedTransactionID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $linkedTransactionID when calling updateLinkedTransaction'
            );
        }
        // verify the required parameter 'linkedTransactions' is set
        if ($linkedTransactions === null || (is_array($linkedTransactions) && count($linkedTransactions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $linkedTransactions when calling updateLinkedTransaction'
            );
        }

        $resourcePath = '/LinkedTransactions/{LinkedTransactionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($linkedTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'LinkedTransactionID' . '}',
                ObjectSerializer::toPathValue($linkedTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($linkedTransactions)) {
            $_tempBody = $linkedTransactions;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateManualJournal
     *
     * Allows you to update a specified manual journal
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ManualJournals $manualJournals manualJournals (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\ManualJournals|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateManualJournal($manualJournalID, $manualJournals)
    {
        list($response) = $this->updateManualJournalWithHttpInfo($manualJournalID, $manualJournals);
        return $response;
    }

    /**
     * Operation updateManualJournalWithHttpInfo
     *
     * Allows you to update a specified manual journal
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ManualJournals $manualJournals (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\ManualJournals|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateManualJournalWithHttpInfo($manualJournalID, $manualJournals)
    {
        $request = $this->updateManualJournalRequest($manualJournalID, $manualJournals);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\ManualJournals' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\ManualJournals', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\ManualJournals';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\ManualJournals',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateManualJournalAsync
     *
     * Allows you to update a specified manual journal
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ManualJournals $manualJournals (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateManualJournalAsync($manualJournalID, $manualJournals)
    {
        return $this->updateManualJournalAsyncWithHttpInfo($manualJournalID, $manualJournals)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateManualJournalAsyncWithHttpInfo
     *
     * Allows you to update a specified manual journal
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ManualJournals $manualJournals (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateManualJournalAsyncWithHttpInfo($manualJournalID, $manualJournals)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\ManualJournals';
        $request = $this->updateManualJournalRequest($manualJournalID, $manualJournals);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateManualJournal'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\ManualJournals $manualJournals (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateManualJournalRequest($manualJournalID, $manualJournals)
    {
        // verify the required parameter 'manualJournalID' is set
        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $manualJournalID when calling updateManualJournal'
            );
        }
        // verify the required parameter 'manualJournals' is set
        if ($manualJournals === null || (is_array($manualJournals) && count($manualJournals) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $manualJournals when calling updateManualJournal'
            );
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($manualJournals)) {
            $_tempBody = $manualJournals;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateManualJournalAttachmentByFileName
     *
     * Allows you to update a specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateManualJournalAttachmentByFileName($manualJournalID, $fileName, $body)
    {
        list($response) = $this->updateManualJournalAttachmentByFileNameWithHttpInfo($manualJournalID, $fileName, $body);
        return $response;
    }

    /**
     * Operation updateManualJournalAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update a specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateManualJournalAttachmentByFileNameWithHttpInfo($manualJournalID, $fileName, $body)
    {
        $request = $this->updateManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateManualJournalAttachmentByFileNameAsync
     *
     * Allows you to update a specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateManualJournalAttachmentByFileNameAsync($manualJournalID, $fileName, $body)
    {
        return $this->updateManualJournalAttachmentByFileNameAsyncWithHttpInfo($manualJournalID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateManualJournalAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to update a specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateManualJournalAttachmentByFileNameAsyncWithHttpInfo($manualJournalID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->updateManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateManualJournalAttachmentByFileName'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $body)
    {
        // verify the required parameter 'manualJournalID' is set
        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $manualJournalID when calling updateManualJournalAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling updateManualJournalAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateManualJournalAttachmentByFileName'
            );
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updatePurchaseOrder
     *
     * Allows you to update a specified purchase order
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders $purchaseOrders purchaseOrders (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updatePurchaseOrder($purchaseOrderID, $purchaseOrders)
    {
        list($response) = $this->updatePurchaseOrderWithHttpInfo($purchaseOrderID, $purchaseOrders);
        return $response;
    }

    /**
     * Operation updatePurchaseOrderWithHttpInfo
     *
     * Allows you to update a specified purchase order
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders $purchaseOrders (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePurchaseOrderWithHttpInfo($purchaseOrderID, $purchaseOrders)
    {
        $request = $this->updatePurchaseOrderRequest($purchaseOrderID, $purchaseOrders);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePurchaseOrderAsync
     *
     * Allows you to update a specified purchase order
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders $purchaseOrders (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePurchaseOrderAsync($purchaseOrderID, $purchaseOrders)
    {
        return $this->updatePurchaseOrderAsyncWithHttpInfo($purchaseOrderID, $purchaseOrders)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePurchaseOrderAsyncWithHttpInfo
     *
     * Allows you to update a specified purchase order
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders $purchaseOrders (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePurchaseOrderAsyncWithHttpInfo($purchaseOrderID, $purchaseOrders)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\PurchaseOrders';
        $request = $this->updatePurchaseOrderRequest($purchaseOrderID, $purchaseOrders);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePurchaseOrder'
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\PurchaseOrders $purchaseOrders (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updatePurchaseOrderRequest($purchaseOrderID, $purchaseOrders)
    {
        // verify the required parameter 'purchaseOrderID' is set
        if ($purchaseOrderID === null || (is_array($purchaseOrderID) && count($purchaseOrderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purchaseOrderID when calling updatePurchaseOrder'
            );
        }
        // verify the required parameter 'purchaseOrders' is set
        if ($purchaseOrders === null || (is_array($purchaseOrders) && count($purchaseOrders) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purchaseOrders when calling updatePurchaseOrder'
            );
        }

        $resourcePath = '/PurchaseOrders/{PurchaseOrderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($purchaseOrderID !== null) {
            $resourcePath = str_replace(
                '{' . 'PurchaseOrderID' . '}',
                ObjectSerializer::toPathValue($purchaseOrderID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($purchaseOrders)) {
            $_tempBody = $purchaseOrders;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateReceipt
     *
     * Allows you to retrieve a specified draft expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Receipts $receipts receipts (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Receipts|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateReceipt($receiptID, $receipts)
    {
        list($response) = $this->updateReceiptWithHttpInfo($receiptID, $receipts);
        return $response;
    }

    /**
     * Operation updateReceiptWithHttpInfo
     *
     * Allows you to retrieve a specified draft expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Receipts $receipts (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Receipts|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateReceiptWithHttpInfo($receiptID, $receipts)
    {
        $request = $this->updateReceiptRequest($receiptID, $receipts);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Receipts' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Receipts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Receipts';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Receipts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateReceiptAsync
     *
     * Allows you to retrieve a specified draft expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Receipts $receipts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateReceiptAsync($receiptID, $receipts)
    {
        return $this->updateReceiptAsyncWithHttpInfo($receiptID, $receipts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateReceiptAsyncWithHttpInfo
     *
     * Allows you to retrieve a specified draft expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Receipts $receipts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateReceiptAsyncWithHttpInfo($receiptID, $receipts)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Receipts';
        $request = $this->updateReceiptRequest($receiptID, $receipts);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateReceipt'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Receipts $receipts (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateReceiptRequest($receiptID, $receipts)
    {
        // verify the required parameter 'receiptID' is set
        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receiptID when calling updateReceipt'
            );
        }
        // verify the required parameter 'receipts' is set
        if ($receipts === null || (is_array($receipts) && count($receipts) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receipts when calling updateReceipt'
            );
        }

        $resourcePath = '/Receipts/{ReceiptID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($receipts)) {
            $_tempBody = $receipts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateReceiptAttachmentByFileName
     *
     * Allows you to update Attachment on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateReceiptAttachmentByFileName($receiptID, $fileName, $body)
    {
        list($response) = $this->updateReceiptAttachmentByFileNameWithHttpInfo($receiptID, $fileName, $body);
        return $response;
    }

    /**
     * Operation updateReceiptAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update Attachment on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateReceiptAttachmentByFileNameWithHttpInfo($receiptID, $fileName, $body)
    {
        $request = $this->updateReceiptAttachmentByFileNameRequest($receiptID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateReceiptAttachmentByFileNameAsync
     *
     * Allows you to update Attachment on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateReceiptAttachmentByFileNameAsync($receiptID, $fileName, $body)
    {
        return $this->updateReceiptAttachmentByFileNameAsyncWithHttpInfo($receiptID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateReceiptAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to update Attachment on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateReceiptAttachmentByFileNameAsyncWithHttpInfo($receiptID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->updateReceiptAttachmentByFileNameRequest($receiptID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateReceiptAttachmentByFileName'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateReceiptAttachmentByFileNameRequest($receiptID, $fileName, $body)
    {
        // verify the required parameter 'receiptID' is set
        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receiptID when calling updateReceiptAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling updateReceiptAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateReceiptAttachmentByFileName'
            );
        }

        $resourcePath = '/Receipts/{ReceiptID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateRepeatingInvoiceAttachmentByFileName
     *
     * Allows you to update specified attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateRepeatingInvoiceAttachmentByFileName($repeatingInvoiceID, $fileName, $body)
    {
        list($response) = $this->updateRepeatingInvoiceAttachmentByFileNameWithHttpInfo($repeatingInvoiceID, $fileName, $body);
        return $response;
    }

    /**
     * Operation updateRepeatingInvoiceAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update specified attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Attachments|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateRepeatingInvoiceAttachmentByFileNameWithHttpInfo($repeatingInvoiceID, $fileName, $body)
    {
        $request = $this->updateRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $body);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Attachments' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Attachments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Attachments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateRepeatingInvoiceAttachmentByFileNameAsync
     *
     * Allows you to update specified attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRepeatingInvoiceAttachmentByFileNameAsync($repeatingInvoiceID, $fileName, $body)
    {
        return $this->updateRepeatingInvoiceAttachmentByFileNameAsyncWithHttpInfo($repeatingInvoiceID, $fileName, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateRepeatingInvoiceAttachmentByFileNameAsyncWithHttpInfo
     *
     * Allows you to update specified attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRepeatingInvoiceAttachmentByFileNameAsyncWithHttpInfo($repeatingInvoiceID, $fileName, $body)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Attachments';
        $request = $this->updateRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $body);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateRepeatingInvoiceAttachmentByFileName'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $body)
    {
        // verify the required parameter 'repeatingInvoiceID' is set
        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repeatingInvoiceID when calling updateRepeatingInvoiceAttachmentByFileName'
            );
        }
        // verify the required parameter 'fileName' is set
        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileName when calling updateRepeatingInvoiceAttachmentByFileName'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateRepeatingInvoiceAttachmentByFileName'
            );
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateTaxRate
     *
     * Allows you to update Tax Rates
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TaxRates $taxRates taxRates (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\TaxRates|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateTaxRate($taxRates)
    {
        list($response) = $this->updateTaxRateWithHttpInfo($taxRates);
        return $response;
    }

    /**
     * Operation updateTaxRateWithHttpInfo
     *
     * Allows you to update Tax Rates
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TaxRates $taxRates (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\TaxRates|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTaxRateWithHttpInfo($taxRates)
    {
        $request = $this->updateTaxRateRequest($taxRates);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\TaxRates' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\TaxRates', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\TaxRates';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\TaxRates',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTaxRateAsync
     *
     * Allows you to update Tax Rates
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TaxRates $taxRates (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaxRateAsync($taxRates)
    {
        return $this->updateTaxRateAsyncWithHttpInfo($taxRates)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTaxRateAsyncWithHttpInfo
     *
     * Allows you to update Tax Rates
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TaxRates $taxRates (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaxRateAsyncWithHttpInfo($taxRates)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\TaxRates';
        $request = $this->updateTaxRateRequest($taxRates);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTaxRate'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\TaxRates $taxRates (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateTaxRateRequest($taxRates)
    {
        // verify the required parameter 'taxRates' is set
        if ($taxRates === null || (is_array($taxRates) && count($taxRates) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taxRates when calling updateTaxRate'
            );
        }

        $resourcePath = '/TaxRates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($taxRates)) {
            $_tempBody = $taxRates;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateTrackingCategory
     *
     * Allows you to update tracking categories
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingCategory $trackingCategory trackingCategory (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\TrackingCategories|\Consilience\XeroAccounting\Sdk\Model\Error
     */
    public function updateTrackingCategory($trackingCategoryID, $trackingCategory)
    {
        list($response) = $this->updateTrackingCategoryWithHttpInfo($trackingCategoryID, $trackingCategory);
        return $response;
    }

    /**
     * Operation updateTrackingCategoryWithHttpInfo
     *
     * Allows you to update tracking categories
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingCategory $trackingCategory (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\TrackingCategories|\Consilience\XeroAccounting\Sdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTrackingCategoryWithHttpInfo($trackingCategoryID, $trackingCategory)
    {
        $request = $this->updateTrackingCategoryRequest($trackingCategoryID, $trackingCategory);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\TrackingCategories' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Error' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTrackingCategoryAsync
     *
     * Allows you to update tracking categories
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingCategory $trackingCategory (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTrackingCategoryAsync($trackingCategoryID, $trackingCategory)
    {
        return $this->updateTrackingCategoryAsyncWithHttpInfo($trackingCategoryID, $trackingCategory)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTrackingCategoryAsyncWithHttpInfo
     *
     * Allows you to update tracking categories
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingCategory $trackingCategory (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTrackingCategoryAsyncWithHttpInfo($trackingCategoryID, $trackingCategory)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\TrackingCategories';
        $request = $this->updateTrackingCategoryRequest($trackingCategoryID, $trackingCategory);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTrackingCategory'
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\TrackingCategory $trackingCategory (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateTrackingCategoryRequest($trackingCategoryID, $trackingCategory)
    {
        // verify the required parameter 'trackingCategoryID' is set
        if ($trackingCategoryID === null || (is_array($trackingCategoryID) && count($trackingCategoryID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trackingCategoryID when calling updateTrackingCategory'
            );
        }
        // verify the required parameter 'trackingCategory' is set
        if ($trackingCategory === null || (is_array($trackingCategory) && count($trackingCategory) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trackingCategory when calling updateTrackingCategory'
            );
        }

        $resourcePath = '/TrackingCategories/{TrackingCategoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($trackingCategoryID !== null) {
            $resourcePath = str_replace(
                '{' . 'TrackingCategoryID' . '}',
                ObjectSerializer::toPathValue($trackingCategoryID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($trackingCategory)) {
            $_tempBody = $trackingCategory;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Return a PSR-7 request.
     *
     * @return RequestInterface
     */
    protected function createRequest(string $method, $uri): RequestInterface
    {
        // Get the factory from Configuration.

        $requestFactory = $this->config->getRequestFactory();

        return $requestFactory->createRequest($method, $uri);
    }

    /**
     * Return a PSR-7 URI.
     *
     * @return UriInterface
     */
    protected function createUri(string $uri = ''): UriInterface
    {
        // Get the factory from Configuration.

        $uriFactory = $this->config->getUriFactory();

        return $uriFactory->createUri($uri);
    }

    /**
     * Get a synchronous client.
     */
    protected function getSyncClient(): ClientInterface
    {
        return $this->config->getSyncClient();
    }

    /**
     * Get an asynchronous client.
     */
    protected function getAsyncClient(): GuzzleClientInterface
    {
        return $this->config->getAsyncClient();
    }

    /**
     * Return a PSR-7 URI.
     *
     * @return UriInterface
     */
    protected function createStream(string $content = ''): StreamInterface
    {
        // Get the factory from Configuration.

        $streamFactory = $this->config->getStreamFactory();

        return $streamFactory->createStream($content);
    }

    /**
    * Wrapper for JSON encoding that throws when an error occurs.
    *
    * @param mixed $value   The value being encoded
    * @param int    $options JSON encode option bitmask
    * @param int    $depth   Set the maximum depth. Must be greater than zero.
    *
    * @return string
    * @throws \InvalidArgumentException if the JSON cannot be encoded.
    * @link http://www.php.net/manual/en/function.json-encode.php
    */
    function jsonEncode($value, $options = 0, $depth = 512)
    {
        $json = \json_encode($value, $options, $depth);
        if (JSON_ERROR_NONE !== json_last_error()) {
            throw new \InvalidArgumentException(
                'json_encode error: ' . json_last_error_msg()
            );
        }

        return $json;
    }

    /**
    * Safely opens a PHP stream resource using a filename.
    *
    * When fopen fails, PHP normally raises a warning. This function adds an
    * error handler that checks for errors and throws an exception instead.
    *
    * @param string $filename File to open
    * @param string $mode     Mode used to open the file
    *
    * @return resource
    * @throws \RuntimeException if the file cannot be opened
    */
    function tryFopen($filename, $mode)
    {
        $ex = null;
        set_error_handler(function () use ($filename, $mode, &$ex) {
            $ex = new \RuntimeException(sprintf(
                'Unable to open %s using mode %s: %s',
                $filename,
                $mode,
                func_get_args()[1]
            ));
        });

        $handle = fopen($filename, $mode);
        restore_error_handler();

        if ($ex) {
            /** @var $ex \RuntimeException */
            throw $ex;
        }

        return $handle;
    }

    /**
    * Build a query string from an array of key value pairs.
    *
    * This function can use the return value of parse_query() to build a query
    * string. This function does not modify the provided keys when an array is
    * encountered (like http_build_query would).
    *
    * @param array     $params   Query string parameters.
    * @param int|false $encoding Set to false to not encode, PHP_QUERY_RFC3986
    *                            to encode using RFC3986, or PHP_QUERY_RFC1738
    *                            to encode using RFC1738.
    * @return string
    */
    function buildQuery(array $params, $encoding = PHP_QUERY_RFC3986)
    {
        if (!$params) {
            return '';
        }
        if ($encoding === false) {
            $encoder = function ($str) { return $str; };
        } elseif ($encoding === PHP_QUERY_RFC3986) {
            $encoder = 'rawurlencode';
        } elseif ($encoding === PHP_QUERY_RFC1738) {
            $encoder = 'urlencode';
        } else {
            throw new \InvalidArgumentException('Invalid type');
        }
        $qs = '';
        foreach ($params as $k => $v) {
            $k = $encoder($k);
            if (!is_array($v)) {
                $qs .= $k;
                if ($v !== null) {
                    $qs .= '=' . $encoder($v);
                }
                $qs .= '&';
            } else {
                foreach ($v as $vv) {
                    $qs .= $k;
                    if ($vv !== null) {
                        $qs .= '=' . $encoder($vv);
                    }
                    $qs .= '&';
                }
            }
        }
        return $qs ? (string) substr($qs, 0, -1) : '';
    }
}

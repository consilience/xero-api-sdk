<?php

namespace Consilience\XeroAccounting\Sdk\Api;

/**
 * FilesApi
 * PHP version 5
 *
 * @category Class
 * @package  Consilience\XeroAccounting\Sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Xero Files API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@xero.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// PSR-18
use Psr\Http\Client\ClientInterface;
use Psr\Http\Client\RequestExceptionInterface;

// PSR-7
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\UriInterface;
use Psr\Http\Message\StreamInterface;

// PSR-17
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\UriFactoryInterface;
use Psr\Http\Message\StreamFactoryInterface;

// Guzzle
use GuzzleHttp\ClientInterface as GuzzleClientInterface;

use Consilience\XeroAccounting\Sdk\ApiException;
use Consilience\XeroAccounting\Sdk\Configuration;
use Consilience\XeroAccounting\Sdk\HeaderSelector;
use Consilience\XeroAccounting\Sdk\ObjectSerializer;

/**
 * FilesApi Class Doc Comment
 *
 * @category Class
 * @package  Consilience\XeroAccounting\Sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class FilesApi
{
    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * FIXME: think about the client. We need a client that can handle both synchronous and
     * asynchronous requests. There is no PSR for asyn as yet, and implementations are so
     * diverse that we need to pick a specific implementaton (Guzzle, I guess). So do we
     * provide a wrapper that we can put one, the other, or both into? Even when there is a
     * PSR for promises, it will not be PSR-18, so we would still need two clients I believe.
     * The wrapper would support both interfaces for PSR-18 and whatever provides async requests.
     * We cannot do that with generator templates alone. We'll just add them to the configuration,
     * like the factories to avoid making this a blocker.
     *
     * @param ClientInterface|GuzzleClient $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->setConfig($config ?: new Configuration());
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * @param Configuration $config
     * @return $this
     */
    protected function setConfig(Configuration $config)
    {
        $this->config = $config;
        return $this;
    }

    /**
     * @param Configuration $config
     * @return $this
     */
    protected function withConfig(Configuration $config)
    {
        $clone = clone $this;
        return $clone->setConfig($config);
    }

    /**
     * Operation createFileAssociation
     *
     * create a new association
     *
     * @param  string $fileId File id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Association $association association (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Association
     */
    public function createFileAssociation($fileId, $association = null)
    {
        list($response) = $this->createFileAssociationWithHttpInfo($fileId, $association);
        return $response;
    }

    /**
     * Operation createFileAssociationWithHttpInfo
     *
     * create a new association
     *
     * @param  string $fileId File id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Association $association (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Association, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFileAssociationWithHttpInfo($fileId, $association = null)
    {
        $request = $this->createFileAssociationRequest($fileId, $association);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Association' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Association', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Association';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Association',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createFileAssociationAsync
     *
     * create a new association
     *
     * @param  string $fileId File id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Association $association (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFileAssociationAsync($fileId, $association = null)
    {
        return $this->createFileAssociationAsyncWithHttpInfo($fileId, $association)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFileAssociationAsyncWithHttpInfo
     *
     * create a new association
     *
     * @param  string $fileId File id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Association $association (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFileAssociationAsyncWithHttpInfo($fileId, $association = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Association';
        $request = $this->createFileAssociationRequest($fileId, $association);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFileAssociation'
     *
     * @param  string $fileId File id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Association $association (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createFileAssociationRequest($fileId, $association = null)
    {
        // verify the required parameter 'fileId' is set
        if ($fileId === null || (is_array($fileId) && count($fileId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileId when calling createFileAssociation'
            );
        }

        $resourcePath = '/Files/{FileId}/Associations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($fileId !== null) {
            $resourcePath = str_replace(
                '{' . 'FileId' . '}',
                ObjectSerializer::toPathValue($fileId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($association)) {
            $_tempBody = $association;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createFolder
     *
     * create a new folder
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Folder $folder folder (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Folder
     */
    public function createFolder($folder = null)
    {
        list($response) = $this->createFolderWithHttpInfo($folder);
        return $response;
    }

    /**
     * Operation createFolderWithHttpInfo
     *
     * create a new folder
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Folder $folder (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Folder, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFolderWithHttpInfo($folder = null)
    {
        $request = $this->createFolderRequest($folder);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Folder' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Folder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Folder';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createFolderAsync
     *
     * create a new folder
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Folder $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFolderAsync($folder = null)
    {
        return $this->createFolderAsyncWithHttpInfo($folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFolderAsyncWithHttpInfo
     *
     * create a new folder
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Folder $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFolderAsyncWithHttpInfo($folder = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Folder';
        $request = $this->createFolderRequest($folder);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFolder'
     *
     * @param  \Consilience\XeroAccounting\Sdk\Model\Folder $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function createFolderRequest($folder = null)
    {

        $resourcePath = '/Folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($folder)) {
            $_tempBody = $folder;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteFile
     *
     * delete a file
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\FileResponse204
     */
    public function deleteFile($fileId)
    {
        list($response) = $this->deleteFileWithHttpInfo($fileId);
        return $response;
    }

    /**
     * Operation deleteFileWithHttpInfo
     *
     * delete a file
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\FileResponse204, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileWithHttpInfo($fileId)
    {
        $request = $this->deleteFileRequest($fileId);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 204:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\FileResponse204' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\FileResponse204', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\FileResponse204';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\FileResponse204',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFileAsync
     *
     * delete a file
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsync($fileId)
    {
        return $this->deleteFileAsyncWithHttpInfo($fileId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileAsyncWithHttpInfo
     *
     * delete a file
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsyncWithHttpInfo($fileId)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\FileResponse204';
        $request = $this->deleteFileRequest($fileId);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFile'
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function deleteFileRequest($fileId)
    {
        // verify the required parameter 'fileId' is set
        if ($fileId === null || (is_array($fileId) && count($fileId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileId when calling deleteFile'
            );
        }

        $resourcePath = '/Files/{FileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($fileId !== null) {
            $resourcePath = str_replace(
                '{' . 'FileId' . '}',
                ObjectSerializer::toPathValue($fileId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteFileAssociation
     *
     * create a new association
     *
     * @param  string $fileId File id for single object (required)
     * @param  string $objectId Object id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\FileResponse204
     */
    public function deleteFileAssociation($fileId, $objectId)
    {
        list($response) = $this->deleteFileAssociationWithHttpInfo($fileId, $objectId);
        return $response;
    }

    /**
     * Operation deleteFileAssociationWithHttpInfo
     *
     * create a new association
     *
     * @param  string $fileId File id for single object (required)
     * @param  string $objectId Object id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\FileResponse204, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileAssociationWithHttpInfo($fileId, $objectId)
    {
        $request = $this->deleteFileAssociationRequest($fileId, $objectId);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 204:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\FileResponse204' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\FileResponse204', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\FileResponse204';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\FileResponse204',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFileAssociationAsync
     *
     * create a new association
     *
     * @param  string $fileId File id for single object (required)
     * @param  string $objectId Object id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAssociationAsync($fileId, $objectId)
    {
        return $this->deleteFileAssociationAsyncWithHttpInfo($fileId, $objectId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileAssociationAsyncWithHttpInfo
     *
     * create a new association
     *
     * @param  string $fileId File id for single object (required)
     * @param  string $objectId Object id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAssociationAsyncWithHttpInfo($fileId, $objectId)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\FileResponse204';
        $request = $this->deleteFileAssociationRequest($fileId, $objectId);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFileAssociation'
     *
     * @param  string $fileId File id for single object (required)
     * @param  string $objectId Object id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function deleteFileAssociationRequest($fileId, $objectId)
    {
        // verify the required parameter 'fileId' is set
        if ($fileId === null || (is_array($fileId) && count($fileId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileId when calling deleteFileAssociation'
            );
        }
        // verify the required parameter 'objectId' is set
        if ($objectId === null || (is_array($objectId) && count($objectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $objectId when calling deleteFileAssociation'
            );
        }

        $resourcePath = '/Files/{FileId}/Associations/{ObjectId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($fileId !== null) {
            $resourcePath = str_replace(
                '{' . 'FileId' . '}',
                ObjectSerializer::toPathValue($fileId),
                $resourcePath
            );
        }
        // path params
        if ($objectId !== null) {
            $resourcePath = str_replace(
                '{' . 'ObjectId' . '}',
                ObjectSerializer::toPathValue($objectId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteFolder
     *
     * delete a folder
     *
     * @param  string $folderId Folder id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\FileResponse204
     */
    public function deleteFolder($folderId)
    {
        list($response) = $this->deleteFolderWithHttpInfo($folderId);
        return $response;
    }

    /**
     * Operation deleteFolderWithHttpInfo
     *
     * delete a folder
     *
     * @param  string $folderId Folder id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\FileResponse204, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFolderWithHttpInfo($folderId)
    {
        $request = $this->deleteFolderRequest($folderId);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 204:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\FileResponse204' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\FileResponse204', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\FileResponse204';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\FileResponse204',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFolderAsync
     *
     * delete a folder
     *
     * @param  string $folderId Folder id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderAsync($folderId)
    {
        return $this->deleteFolderAsyncWithHttpInfo($folderId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFolderAsyncWithHttpInfo
     *
     * delete a folder
     *
     * @param  string $folderId Folder id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderAsyncWithHttpInfo($folderId)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\FileResponse204';
        $request = $this->deleteFolderRequest($folderId);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFolder'
     *
     * @param  string $folderId Folder id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function deleteFolderRequest($folderId)
    {
        // verify the required parameter 'folderId' is set
        if ($folderId === null || (is_array($folderId) && count($folderId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folderId when calling deleteFolder'
            );
        }

        $resourcePath = '/Folders/{FolderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($folderId !== null) {
            $resourcePath = str_replace(
                '{' . 'FolderId' . '}',
                ObjectSerializer::toPathValue($folderId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getAssociationsByObject
     *
     * searches files
     *
     * @param  string $objectId Object id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Association[]
     */
    public function getAssociationsByObject($objectId)
    {
        list($response) = $this->getAssociationsByObjectWithHttpInfo($objectId);
        return $response;
    }

    /**
     * Operation getAssociationsByObjectWithHttpInfo
     *
     * searches files
     *
     * @param  string $objectId Object id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Association[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getAssociationsByObjectWithHttpInfo($objectId)
    {
        $request = $this->getAssociationsByObjectRequest($objectId);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Association[]' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Association[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Association[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Association[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAssociationsByObjectAsync
     *
     * searches files
     *
     * @param  string $objectId Object id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAssociationsByObjectAsync($objectId)
    {
        return $this->getAssociationsByObjectAsyncWithHttpInfo($objectId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAssociationsByObjectAsyncWithHttpInfo
     *
     * searches files
     *
     * @param  string $objectId Object id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAssociationsByObjectAsyncWithHttpInfo($objectId)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Association[]';
        $request = $this->getAssociationsByObjectRequest($objectId);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAssociationsByObject'
     *
     * @param  string $objectId Object id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getAssociationsByObjectRequest($objectId)
    {
        // verify the required parameter 'objectId' is set
        if ($objectId === null || (is_array($objectId) && count($objectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $objectId when calling getAssociationsByObject'
            );
        }

        $resourcePath = '/Associations/{ObjectId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($objectId !== null) {
            $resourcePath = str_replace(
                '{' . 'ObjectId' . '}',
                ObjectSerializer::toPathValue($objectId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getFile
     *
     * searches for file by unique id
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\FileObject
     */
    public function getFile($fileId)
    {
        list($response) = $this->getFileWithHttpInfo($fileId);
        return $response;
    }

    /**
     * Operation getFileWithHttpInfo
     *
     * searches for file by unique id
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\FileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileWithHttpInfo($fileId)
    {
        $request = $this->getFileRequest($fileId);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\FileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\FileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\FileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\FileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFileAsync
     *
     * searches for file by unique id
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileAsync($fileId)
    {
        return $this->getFileAsyncWithHttpInfo($fileId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileAsyncWithHttpInfo
     *
     * searches for file by unique id
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileAsyncWithHttpInfo($fileId)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\FileObject';
        $request = $this->getFileRequest($fileId);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFile'
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getFileRequest($fileId)
    {
        // verify the required parameter 'fileId' is set
        if ($fileId === null || (is_array($fileId) && count($fileId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileId when calling getFile'
            );
        }

        $resourcePath = '/Files/{FileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($fileId !== null) {
            $resourcePath = str_replace(
                '{' . 'FileId' . '}',
                ObjectSerializer::toPathValue($fileId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getFileAssociations
     *
     * searches files
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Association[]
     */
    public function getFileAssociations($fileId)
    {
        list($response) = $this->getFileAssociationsWithHttpInfo($fileId);
        return $response;
    }

    /**
     * Operation getFileAssociationsWithHttpInfo
     *
     * searches files
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Association[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileAssociationsWithHttpInfo($fileId)
    {
        $request = $this->getFileAssociationsRequest($fileId);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Association[]' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Association[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Association[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Association[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFileAssociationsAsync
     *
     * searches files
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileAssociationsAsync($fileId)
    {
        return $this->getFileAssociationsAsyncWithHttpInfo($fileId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileAssociationsAsyncWithHttpInfo
     *
     * searches files
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileAssociationsAsyncWithHttpInfo($fileId)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Association[]';
        $request = $this->getFileAssociationsRequest($fileId);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileAssociations'
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getFileAssociationsRequest($fileId)
    {
        // verify the required parameter 'fileId' is set
        if ($fileId === null || (is_array($fileId) && count($fileId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileId when calling getFileAssociations'
            );
        }

        $resourcePath = '/Files/{FileId}/Associations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($fileId !== null) {
            $resourcePath = str_replace(
                '{' . 'FileId' . '}',
                ObjectSerializer::toPathValue($fileId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getFileContent
     *
     * searches files to retrieve the data
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getFileContent($fileId)
    {
        list($response) = $this->getFileContentWithHttpInfo($fileId);
        return $response;
    }

    /**
     * Operation getFileContentWithHttpInfo
     *
     * searches files to retrieve the data
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileContentWithHttpInfo($fileId)
    {
        $request = $this->getFileContentRequest($fileId);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\SplFileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFileContentAsync
     *
     * searches files to retrieve the data
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileContentAsync($fileId)
    {
        return $this->getFileContentAsyncWithHttpInfo($fileId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileContentAsyncWithHttpInfo
     *
     * searches files to retrieve the data
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileContentAsyncWithHttpInfo($fileId)
    {
        $returnType = '\SplFileObject';
        $request = $this->getFileContentRequest($fileId);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileContent'
     *
     * @param  string $fileId File id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getFileContentRequest($fileId)
    {
        // verify the required parameter 'fileId' is set
        if ($fileId === null || (is_array($fileId) && count($fileId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileId when calling getFileContent'
            );
        }

        $resourcePath = '/Files/{FileId}/Content';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($fileId !== null) {
            $resourcePath = str_replace(
                '{' . 'FileId' . '}',
                ObjectSerializer::toPathValue($fileId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getFiles
     *
     * searches files
     *
     * @param  int $pagesize pass an optional page size value (optional)
     * @param  int $page number of records to skip for pagination (optional)
     * @param  string $sort values to sort by (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Files
     */
    public function getFiles($pagesize = null, $page = null, $sort = null)
    {
        list($response) = $this->getFilesWithHttpInfo($pagesize, $page, $sort);
        return $response;
    }

    /**
     * Operation getFilesWithHttpInfo
     *
     * searches files
     *
     * @param  int $pagesize pass an optional page size value (optional)
     * @param  int $page number of records to skip for pagination (optional)
     * @param  string $sort values to sort by (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Files, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFilesWithHttpInfo($pagesize = null, $page = null, $sort = null)
    {
        $request = $this->getFilesRequest($pagesize, $page, $sort);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Files' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Files', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Files';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Files',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFilesAsync
     *
     * searches files
     *
     * @param  int $pagesize pass an optional page size value (optional)
     * @param  int $page number of records to skip for pagination (optional)
     * @param  string $sort values to sort by (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesAsync($pagesize = null, $page = null, $sort = null)
    {
        return $this->getFilesAsyncWithHttpInfo($pagesize, $page, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFilesAsyncWithHttpInfo
     *
     * searches files
     *
     * @param  int $pagesize pass an optional page size value (optional)
     * @param  int $page number of records to skip for pagination (optional)
     * @param  string $sort values to sort by (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesAsyncWithHttpInfo($pagesize = null, $page = null, $sort = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Files';
        $request = $this->getFilesRequest($pagesize, $page, $sort);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFiles'
     *
     * @param  int $pagesize pass an optional page size value (optional)
     * @param  int $page number of records to skip for pagination (optional)
     * @param  string $sort values to sort by (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getFilesRequest($pagesize = null, $page = null, $sort = null)
    {
        if ($pagesize !== null && $pagesize > 100) {
            throw new \InvalidArgumentException('invalid value for "$pagesize" when calling FilesApi.getFiles, must be smaller than or equal to 100.');
        }

        if ($page !== null && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling FilesApi.getFiles, must be bigger than or equal to 1.');
        }


        $resourcePath = '/Files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pagesize !== null) {
            $queryParams['pagesize'] = ObjectSerializer::toQueryValue($pagesize);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getFolder
     *
     * searches specific folder by id
     *
     * @param  string $folderId Folder id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Folder
     */
    public function getFolder($folderId)
    {
        list($response) = $this->getFolderWithHttpInfo($folderId);
        return $response;
    }

    /**
     * Operation getFolderWithHttpInfo
     *
     * searches specific folder by id
     *
     * @param  string $folderId Folder id for single object (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Folder, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFolderWithHttpInfo($folderId)
    {
        $request = $this->getFolderRequest($folderId);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Folder' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Folder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Folder';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFolderAsync
     *
     * searches specific folder by id
     *
     * @param  string $folderId Folder id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderAsync($folderId)
    {
        return $this->getFolderAsyncWithHttpInfo($folderId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFolderAsyncWithHttpInfo
     *
     * searches specific folder by id
     *
     * @param  string $folderId Folder id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderAsyncWithHttpInfo($folderId)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Folder';
        $request = $this->getFolderRequest($folderId);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFolder'
     *
     * @param  string $folderId Folder id for single object (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getFolderRequest($folderId)
    {
        // verify the required parameter 'folderId' is set
        if ($folderId === null || (is_array($folderId) && count($folderId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folderId when calling getFolder'
            );
        }

        $resourcePath = '/Folders/{FolderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($folderId !== null) {
            $resourcePath = str_replace(
                '{' . 'FolderId' . '}',
                ObjectSerializer::toPathValue($folderId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getFolders
     *
     * searches folder
     *
     * @param  string $sort values to sort by (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Folder[]
     */
    public function getFolders($sort = null)
    {
        list($response) = $this->getFoldersWithHttpInfo($sort);
        return $response;
    }

    /**
     * Operation getFoldersWithHttpInfo
     *
     * searches folder
     *
     * @param  string $sort values to sort by (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Folder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFoldersWithHttpInfo($sort = null)
    {
        $request = $this->getFoldersRequest($sort);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Folder[]' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Folder[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Folder[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Folder[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFoldersAsync
     *
     * searches folder
     *
     * @param  string $sort values to sort by (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFoldersAsync($sort = null)
    {
        return $this->getFoldersAsyncWithHttpInfo($sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFoldersAsyncWithHttpInfo
     *
     * searches folder
     *
     * @param  string $sort values to sort by (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFoldersAsyncWithHttpInfo($sort = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Folder[]';
        $request = $this->getFoldersRequest($sort);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFolders'
     *
     * @param  string $sort values to sort by (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getFoldersRequest($sort = null)
    {

        $resourcePath = '/Folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInbox
     *
     * searches inbox folder
     *
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Folder
     */
    public function getInbox()
    {
        list($response) = $this->getInboxWithHttpInfo();
        return $response;
    }

    /**
     * Operation getInboxWithHttpInfo
     *
     * searches inbox folder
     *
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Folder, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInboxWithHttpInfo()
    {
        $request = $this->getInboxRequest();

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Folder' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Folder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Folder';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInboxAsync
     *
     * searches inbox folder
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboxAsync()
    {
        return $this->getInboxAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInboxAsyncWithHttpInfo
     *
     * searches inbox folder
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboxAsyncWithHttpInfo()
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Folder';
        $request = $this->getInboxRequest();

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInbox'
     *
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function getInboxRequest()
    {

        $resourcePath = '/Inbox';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateFile
     *
     * Update a file
     *
     * @param  string $fileId File id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\FileObject $fileObject fileObject (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\FileObject
     */
    public function updateFile($fileId, $fileObject = null)
    {
        list($response) = $this->updateFileWithHttpInfo($fileId, $fileObject);
        return $response;
    }

    /**
     * Operation updateFileWithHttpInfo
     *
     * Update a file
     *
     * @param  string $fileId File id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\FileObject $fileObject (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\FileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFileWithHttpInfo($fileId, $fileObject = null)
    {
        $request = $this->updateFileRequest($fileId, $fileObject);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\FileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\FileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\FileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\FileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateFileAsync
     *
     * Update a file
     *
     * @param  string $fileId File id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\FileObject $fileObject (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFileAsync($fileId, $fileObject = null)
    {
        return $this->updateFileAsyncWithHttpInfo($fileId, $fileObject)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateFileAsyncWithHttpInfo
     *
     * Update a file
     *
     * @param  string $fileId File id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\FileObject $fileObject (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFileAsyncWithHttpInfo($fileId, $fileObject = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\FileObject';
        $request = $this->updateFileRequest($fileId, $fileObject);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateFile'
     *
     * @param  string $fileId File id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\FileObject $fileObject (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateFileRequest($fileId, $fileObject = null)
    {
        // verify the required parameter 'fileId' is set
        if ($fileId === null || (is_array($fileId) && count($fileId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileId when calling updateFile'
            );
        }

        $resourcePath = '/Files/{FileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($fileId !== null) {
            $resourcePath = str_replace(
                '{' . 'FileId' . '}',
                ObjectSerializer::toPathValue($fileId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($fileObject)) {
            $_tempBody = $fileObject;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateFolder
     *
     * update folder
     *
     * @param  string $folderId Folder id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Folder $folder folder (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\Folder
     */
    public function updateFolder($folderId, $folder)
    {
        list($response) = $this->updateFolderWithHttpInfo($folderId, $folder);
        return $response;
    }

    /**
     * Operation updateFolderWithHttpInfo
     *
     * update folder
     *
     * @param  string $folderId Folder id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Folder $folder (required)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\Folder, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFolderWithHttpInfo($folderId, $folder)
    {
        $request = $this->updateFolderRequest($folderId, $folder);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\Folder' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\Folder', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\Folder';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateFolderAsync
     *
     * update folder
     *
     * @param  string $folderId Folder id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Folder $folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFolderAsync($folderId, $folder)
    {
        return $this->updateFolderAsyncWithHttpInfo($folderId, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateFolderAsyncWithHttpInfo
     *
     * update folder
     *
     * @param  string $folderId Folder id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Folder $folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFolderAsyncWithHttpInfo($folderId, $folder)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\Folder';
        $request = $this->updateFolderRequest($folderId, $folder);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateFolder'
     *
     * @param  string $folderId Folder id for single object (required)
     * @param  \Consilience\XeroAccounting\Sdk\Model\Folder $folder (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function updateFolderRequest($folderId, $folder)
    {
        // verify the required parameter 'folderId' is set
        if ($folderId === null || (is_array($folderId) && count($folderId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folderId when calling updateFolder'
            );
        }
        // verify the required parameter 'folder' is set
        if ($folder === null || (is_array($folder) && count($folder) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder when calling updateFolder'
            );
        }

        $resourcePath = '/Folders/{FolderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($folderId !== null) {
            $resourcePath = str_replace(
                '{' . 'FolderId' . '}',
                ObjectSerializer::toPathValue($folderId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($folder)) {
            $_tempBody = $folder;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation uploadFile
     *
     * upload an File
     *
     * @param  string $folderId pass an optional folder id to save file to specific folder (optional)
     * @param  string $body body (optional)
     * @param  string $name exact name of the file you are uploading (optional)
     * @param  string $filename filename (optional)
     * @param  string $mimeType mimeType (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Consilience\XeroAccounting\Sdk\Model\FileObject
     */
    public function uploadFile($folderId = null, $body = null, $name = null, $filename = null, $mimeType = null)
    {
        list($response) = $this->uploadFileWithHttpInfo($folderId, $body, $name, $filename, $mimeType);
        return $response;
    }

    /**
     * Operation uploadFileWithHttpInfo
     *
     * upload an File
     *
     * @param  string $folderId pass an optional folder id to save file to specific folder (optional)
     * @param  string $body (optional)
     * @param  string $name exact name of the file you are uploading (optional)
     * @param  string $filename (optional)
     * @param  string $mimeType (optional)
     *
     * @throws \Consilience\XeroAccounting\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Consilience\XeroAccounting\Sdk\Model\FileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadFileWithHttpInfo($folderId = null, $body = null, $name = null, $filename = null, $mimeType = null)
    {
        $request = $this->uploadFileRequest($folderId, $body, $name, $filename, $mimeType);

        try {
            try {
                // Get a PSR-18 synchronous client.

                $client = $this->getSyncClient();

                $response = $client->sendRequest($request);
            } catch (RequestExceptionInterface $e) {
                // CHECKME: is this what the Guzzle client would throw too?
                // This $e->getResponse() - is that PSR-7 or just what the Guzzle exception provides?

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            // FIXME: this behavious is not desired, since even 4xx errors may
            // carry a payload with details of the problem that the application
            // may need to know.

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    // The response body will always be Psr\Http\Message\StreamInterface

                    if ('\Consilience\XeroAccounting\Sdk\Model\FileObject' === '\SplFileObject') {
                        // Data type maps to "file" in the spec.
                        $content = $responseBody;
                    } else {
                        $content = (string)$responseBody;
                    }

                    // FIXME: we should pass in $response->getHeaders() instead of []

                    return [
                        ObjectSerializer::deserialize($content, '\Consilience\XeroAccounting\Sdk\Model\FileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Consilience\XeroAccounting\Sdk\Model\FileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                // Stream goes to deserializer
                $content = $responseBody;
            } else {
                $content = (string)$responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Consilience\XeroAccounting\Sdk\Model\FileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadFileAsync
     *
     * upload an File
     *
     * @param  string $folderId pass an optional folder id to save file to specific folder (optional)
     * @param  string $body (optional)
     * @param  string $name exact name of the file you are uploading (optional)
     * @param  string $filename (optional)
     * @param  string $mimeType (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileAsync($folderId = null, $body = null, $name = null, $filename = null, $mimeType = null)
    {
        return $this->uploadFileAsyncWithHttpInfo($folderId, $body, $name, $filename, $mimeType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadFileAsyncWithHttpInfo
     *
     * upload an File
     *
     * @param  string $folderId pass an optional folder id to save file to specific folder (optional)
     * @param  string $body (optional)
     * @param  string $name exact name of the file you are uploading (optional)
     * @param  string $filename (optional)
     * @param  string $mimeType (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileAsyncWithHttpInfo($folderId = null, $body = null, $name = null, $filename = null, $mimeType = null)
    {
        $returnType = '\Consilience\XeroAccounting\Sdk\Model\FileObject';
        $request = $this->uploadFileRequest($folderId, $body, $name, $filename, $mimeType);

        if (! $this->client instanceof  GuzzleClient) {
            // TODO: Not a suitable client; throw excpetion.
        }

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadFile'
     *
     * @param  string $folderId pass an optional folder id to save file to specific folder (optional)
     * @param  string $body (optional)
     * @param  string $name exact name of the file you are uploading (optional)
     * @param  string $filename (optional)
     * @param  string $mimeType (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    protected function uploadFileRequest($folderId = null, $body = null, $name = null, $filename = null, $mimeType = null)
    {

        $resourcePath = '/Files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folderId !== null) {
            $queryParams['folderId'] = ObjectSerializer::toQueryValue($folderId);
        }


        // form params
        if ($body !== null) {
            $formParams['body'] = ObjectSerializer::toFormValue($body);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($filename !== null) {
            $formParams['filename'] = ObjectSerializer::toFormValue($filename);
        }
        // form params
        if ($mimeType !== null) {
            $formParams['mimeType'] = ObjectSerializer::toFormValue($mimeType);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Return a PSR-7 request.
     *
     * @return RequestInterface
     */
    protected function createRequest(string $method, $uri): RequestInterface
    {
        // Get the factory from Configuration.

        $requestFactory = $this->config->getRequestFactory();

        return $requestFactory->createRequest($method, $uri);
    }

    /**
     * Return a PSR-7 URI.
     *
     * @return UriInterface
     */
    protected function createUri(string $uri = ''): UriInterface
    {
        // Get the factory from Configuration.

        $uriFactory = $this->config->getUriFactory();

        return $uriFactory->createUri($uri);
    }

    /**
     * Get a synchronous client.
     */
    protected function getSyncClient(): ClientInterface
    {
        return $this->config->getSyncClient();
    }

    /**
     * Get an asynchronous client.
     */
    protected function getAsyncClient(): GuzzleClientInterface
    {
        return $this->config->getAsyncClient();
    }

    /**
     * Return a PSR-7 URI.
     *
     * @return UriInterface
     */
    protected function createStream(string $content = ''): StreamInterface
    {
        // Get the factory from Configuration.

        $streamFactory = $this->config->getStreamFactory();

        return $streamFactory->createStream($content);
    }

    /**
    * Wrapper for JSON encoding that throws when an error occurs.
    *
    * @param mixed $value   The value being encoded
    * @param int    $options JSON encode option bitmask
    * @param int    $depth   Set the maximum depth. Must be greater than zero.
    *
    * @return string
    * @throws \InvalidArgumentException if the JSON cannot be encoded.
    * @link http://www.php.net/manual/en/function.json-encode.php
    */
    function jsonEncode($value, $options = 0, $depth = 512)
    {
        $json = \json_encode($value, $options, $depth);
        if (JSON_ERROR_NONE !== json_last_error()) {
            throw new \InvalidArgumentException(
                'json_encode error: ' . json_last_error_msg()
            );
        }

        return $json;
    }

    /**
    * Safely opens a PHP stream resource using a filename.
    *
    * When fopen fails, PHP normally raises a warning. This function adds an
    * error handler that checks for errors and throws an exception instead.
    *
    * @param string $filename File to open
    * @param string $mode     Mode used to open the file
    *
    * @return resource
    * @throws \RuntimeException if the file cannot be opened
    */
    function tryFopen($filename, $mode)
    {
        $ex = null;
        set_error_handler(function () use ($filename, $mode, &$ex) {
            $ex = new \RuntimeException(sprintf(
                'Unable to open %s using mode %s: %s',
                $filename,
                $mode,
                func_get_args()[1]
            ));
        });

        $handle = fopen($filename, $mode);
        restore_error_handler();

        if ($ex) {
            /** @var $ex \RuntimeException */
            throw $ex;
        }

        return $handle;
    }

    /**
    * Build a query string from an array of key value pairs.
    *
    * This function can use the return value of parse_query() to build a query
    * string. This function does not modify the provided keys when an array is
    * encountered (like http_build_query would).
    *
    * @param array     $params   Query string parameters.
    * @param int|false $encoding Set to false to not encode, PHP_QUERY_RFC3986
    *                            to encode using RFC3986, or PHP_QUERY_RFC1738
    *                            to encode using RFC1738.
    * @return string
    */
    function buildQuery(array $params, $encoding = PHP_QUERY_RFC3986)
    {
        if (!$params) {
            return '';
        }
        if ($encoding === false) {
            $encoder = function ($str) { return $str; };
        } elseif ($encoding === PHP_QUERY_RFC3986) {
            $encoder = 'rawurlencode';
        } elseif ($encoding === PHP_QUERY_RFC1738) {
            $encoder = 'urlencode';
        } else {
            throw new \InvalidArgumentException('Invalid type');
        }
        $qs = '';
        foreach ($params as $k => $v) {
            $k = $encoder($k);
            if (!is_array($v)) {
                $qs .= $k;
                if ($v !== null) {
                    $qs .= '=' . $encoder($v);
                }
                $qs .= '&';
            } else {
                foreach ($v as $vv) {
                    $qs .= $k;
                    if ($vv !== null) {
                        $qs .= '=' . $encoder($vv);
                    }
                    $qs .= '&';
                }
            }
        }
        return $qs ? (string) substr($qs, 0, -1) : '';
    }
}

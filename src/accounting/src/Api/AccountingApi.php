<?php

namespace Consilience\Xero\AccountingSdk\Api;

/**
 * AccountingApi
 * PHP version 5
 *
 * @category Class
 * @package  Consilience\Xero\AccountingSdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Accounting API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: api@xero.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// PSR-18
use Psr\Http\Client\ClientInterface;
use Psr\Http\Client\RequestExceptionInterface;
use Psr\Http\Client\NetworkExceptionInterface;

// PSR-7
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\UriInterface;
use Psr\Http\Message\StreamInterface;

// PSR-17
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\UriFactoryInterface;
use Psr\Http\Message\StreamFactoryInterface;

// Guzzle
use GuzzleHttp\ClientInterface as GuzzleClientInterface;

use Consilience\Xero\AccountingSdk\ApiException;
use Consilience\Xero\AccountingSdk\Configuration;
use Consilience\Xero\AccountingSdk\HeaderSelector;
use Consilience\Xero\AccountingSdk\ObjectSerializer;

use InvalidArgumentException;

/**
 * AccountingApi Class Doc Comment
 *
 * @category Class
 * @package  Consilience\Xero\AccountingSdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AccountingApi
{
    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * FIXME: think about the client. We need a client that can handle both synchronous and
     * asynchronous requests. There is no PSR for asyn as yet, and implementations are so
     * diverse that we need to pick a specific implementaton (Guzzle, I guess). So do we
     * provide a wrapper that we can put one, the other, or both into? Even when there is a
     * PSR for promises, it will not be PSR-18, so we would still need two clients I believe.
     * The wrapper would support both interfaces for PSR-18 and whatever provides async requests.
     * We cannot do that with generator templates alone. We'll just add them to the configuration,
     * like the factories to avoid making this a blocker.
     *
     * @param ClientInterface|GuzzleClient $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->setConfig($config ?: new Configuration());
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * @param Configuration $config
     * @return $this
     */
    protected function setConfig(Configuration $config)
    {
        $this->config = $config;
        return $this;
    }

    /**
     * @param Configuration $config
     * @return $this
     */
    protected function withConfig(Configuration $config)
    {
        $clone = clone $this;
        return $clone->setConfig($config);
    }

    /**
     * Operation createAccount
     *
     * Allows you to create a new chart of accounts
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Account $account Request of type Account (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Accounts|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createAccount($account)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createAccountWithHttpInfo($account);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createAccountWithHttpInfo
     *
     * Allows you to create a new chart of accounts
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Account $account Request of type Account (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Accounts|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountWithHttpInfo($account)
    {
        $request = $this->createAccountRequest($account);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Accounts'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Accounts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createAccount'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Account $account Request of type Account (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createAccountRequest($account)
    {
        // Verify the required parameter 'account' is set

        if ($account === null || (is_array($account) && count($account) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'account',
                'createAccount'
            ));
        }

        $resourcePath = '/Accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($account)) {
            $_tempBody = $account;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createAccountAttachmentByFileName
     *
     * Allows you to create Attachment on Account
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createAccountAttachmentByFileName($accountID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createAccountAttachmentByFileNameWithHttpInfo($accountID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createAccountAttachmentByFileNameWithHttpInfo
     *
     * Allows you to create Attachment on Account
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountAttachmentByFileNameWithHttpInfo($accountID, $fileName, $body)
    {
        $request = $this->createAccountAttachmentByFileNameRequest($accountID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createAccountAttachmentByFileName'
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createAccountAttachmentByFileNameRequest($accountID, $fileName, $body)
    {
        // Verify the required parameter 'accountID' is set

        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'accountID',
                'createAccountAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'createAccountAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'createAccountAttachmentByFileName'
            ));
        }

        $resourcePath = '/Accounts/{AccountID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBankTransaction
     *
     * Allows you to create a spend or receive money transaction
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\BankTransactions $bankTransactions bankTransactions (required)
     * @param  bool $summarizeErrors response format that shows validation errors for each bank transaction (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\BankTransactions|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createBankTransaction($bankTransactions, $summarizeErrors = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createBankTransactionWithHttpInfo($bankTransactions, $summarizeErrors);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createBankTransactionWithHttpInfo
     *
     * Allows you to create a spend or receive money transaction
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\BankTransactions $bankTransactions (required)
     * @param  bool $summarizeErrors response format that shows validation errors for each bank transaction (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\BankTransactions|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBankTransactionWithHttpInfo($bankTransactions, $summarizeErrors = null)
    {
        $request = $this->createBankTransactionRequest($bankTransactions, $summarizeErrors);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\BankTransactions'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\BankTransactions';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createBankTransaction'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\BankTransactions $bankTransactions (required)
     * @param  bool $summarizeErrors response format that shows validation errors for each bank transaction (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createBankTransactionRequest($bankTransactions, $summarizeErrors = null)
    {
        // Verify the required parameter 'bankTransactions' is set

        if ($bankTransactions === null || (is_array($bankTransactions) && count($bankTransactions) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransactions',
                'createBankTransaction'
            ));
        }

        $resourcePath = '/BankTransactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($summarizeErrors !== null) {
            $queryParams['SummarizeErrors'] = ObjectSerializer::toQueryValue($summarizeErrors);
        }


        // body params
        $_tempBody = null;
        if (isset($bankTransactions)) {
            $_tempBody = $bankTransactions;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBankTransactionAttachmentByFileName
     *
     * Allows you to createa an Attachment on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createBankTransactionAttachmentByFileName($bankTransactionID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createBankTransactionAttachmentByFileNameWithHttpInfo($bankTransactionID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createBankTransactionAttachmentByFileNameWithHttpInfo
     *
     * Allows you to createa an Attachment on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBankTransactionAttachmentByFileNameWithHttpInfo($bankTransactionID, $fileName, $body)
    {
        $request = $this->createBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createBankTransactionAttachmentByFileName'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $body)
    {
        // Verify the required parameter 'bankTransactionID' is set

        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransactionID',
                'createBankTransactionAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'createBankTransactionAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'createBankTransactionAttachmentByFileName'
            ));
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBankTransactionHistoryRecord
     *
     * Allows you to create history record for a bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createBankTransactionHistoryRecord($bankTransactionID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createBankTransactionHistoryRecordWithHttpInfo($bankTransactionID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createBankTransactionHistoryRecordWithHttpInfo
     *
     * Allows you to create history record for a bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBankTransactionHistoryRecordWithHttpInfo($bankTransactionID, $historyRecords)
    {
        $request = $this->createBankTransactionHistoryRecordRequest($bankTransactionID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createBankTransactionHistoryRecord'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createBankTransactionHistoryRecordRequest($bankTransactionID, $historyRecords)
    {
        // Verify the required parameter 'bankTransactionID' is set

        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransactionID',
                'createBankTransactionHistoryRecord'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createBankTransactionHistoryRecord'
            ));
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBankTransfer
     *
     * Allows you to create a bank transfers
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\BankTransfers $bankTransfers bankTransfers (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\BankTransfers|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createBankTransfer($bankTransfers)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createBankTransferWithHttpInfo($bankTransfers);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createBankTransferWithHttpInfo
     *
     * Allows you to create a bank transfers
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\BankTransfers $bankTransfers (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\BankTransfers|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBankTransferWithHttpInfo($bankTransfers)
    {
        $request = $this->createBankTransferRequest($bankTransfers);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\BankTransfers'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\BankTransfers';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createBankTransfer'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\BankTransfers $bankTransfers (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createBankTransferRequest($bankTransfers)
    {
        // Verify the required parameter 'bankTransfers' is set

        if ($bankTransfers === null || (is_array($bankTransfers) && count($bankTransfers) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransfers',
                'createBankTransfer'
            ));
        }

        $resourcePath = '/BankTransfers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($bankTransfers)) {
            $_tempBody = $bankTransfers;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBankTransferAttachmentByFileName
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createBankTransferAttachmentByFileName($bankTransferID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createBankTransferAttachmentByFileNameWithHttpInfo($bankTransferID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createBankTransferAttachmentByFileNameWithHttpInfo
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBankTransferAttachmentByFileNameWithHttpInfo($bankTransferID, $fileName, $body)
    {
        $request = $this->createBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createBankTransferAttachmentByFileName'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $body)
    {
        // Verify the required parameter 'bankTransferID' is set

        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransferID',
                'createBankTransferAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'createBankTransferAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'createBankTransferAttachmentByFileName'
            ));
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBankTransferHistoryRecord
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createBankTransferHistoryRecord($bankTransferID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createBankTransferHistoryRecordWithHttpInfo($bankTransferID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createBankTransferHistoryRecordWithHttpInfo
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBankTransferHistoryRecordWithHttpInfo($bankTransferID, $historyRecords)
    {
        $request = $this->createBankTransferHistoryRecordRequest($bankTransferID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createBankTransferHistoryRecord'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createBankTransferHistoryRecordRequest($bankTransferID, $historyRecords)
    {
        // Verify the required parameter 'bankTransferID' is set

        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransferID',
                'createBankTransferHistoryRecord'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createBankTransferHistoryRecord'
            ));
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBatchPayment
     *
     * Create one or many BatchPayments for invoices
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\BatchPayments $batchPayments Request of type BatchPayments containing a Payments array with one or more Payment objects (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\BatchPayments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createBatchPayment($batchPayments)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createBatchPaymentWithHttpInfo($batchPayments);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createBatchPaymentWithHttpInfo
     *
     * Create one or many BatchPayments for invoices
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\BatchPayments $batchPayments Request of type BatchPayments containing a Payments array with one or more Payment objects (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\BatchPayments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBatchPaymentWithHttpInfo($batchPayments)
    {
        $request = $this->createBatchPaymentRequest($batchPayments);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\BatchPayments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\BatchPayments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createBatchPayment'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\BatchPayments $batchPayments Request of type BatchPayments containing a Payments array with one or more Payment objects (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createBatchPaymentRequest($batchPayments)
    {
        // Verify the required parameter 'batchPayments' is set

        if ($batchPayments === null || (is_array($batchPayments) && count($batchPayments) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'batchPayments',
                'createBatchPayment'
            ));
        }

        $resourcePath = '/BatchPayments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($batchPayments)) {
            $_tempBody = $batchPayments;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBatchPaymentHistoryRecord
     *
     * Allows you to create a history record for a Batch Payment
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createBatchPaymentHistoryRecord($batchPaymentID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createBatchPaymentHistoryRecordWithHttpInfo($batchPaymentID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createBatchPaymentHistoryRecordWithHttpInfo
     *
     * Allows you to create a history record for a Batch Payment
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBatchPaymentHistoryRecordWithHttpInfo($batchPaymentID, $historyRecords)
    {
        $request = $this->createBatchPaymentHistoryRecordRequest($batchPaymentID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createBatchPaymentHistoryRecord'
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createBatchPaymentHistoryRecordRequest($batchPaymentID, $historyRecords)
    {
        // Verify the required parameter 'batchPaymentID' is set

        if ($batchPaymentID === null || (is_array($batchPaymentID) && count($batchPaymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'batchPaymentID',
                'createBatchPaymentHistoryRecord'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createBatchPaymentHistoryRecord'
            ));
        }

        $resourcePath = '/BatchPayments/{BatchPaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($batchPaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'BatchPaymentID' . '}',
                ObjectSerializer::toPathValue($batchPaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createBrandingThemePaymentServices
     *
     * Allow for the creation of new custom payment service for specified Branding Theme
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\PaymentService $paymentService paymentService (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\PaymentServices|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createBrandingThemePaymentServices($brandingThemeID, $paymentService)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createBrandingThemePaymentServicesWithHttpInfo($brandingThemeID, $paymentService);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createBrandingThemePaymentServicesWithHttpInfo
     *
     * Allow for the creation of new custom payment service for specified Branding Theme
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\PaymentService $paymentService (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\PaymentServices|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBrandingThemePaymentServicesWithHttpInfo($brandingThemeID, $paymentService)
    {
        $request = $this->createBrandingThemePaymentServicesRequest($brandingThemeID, $paymentService);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\PaymentServices'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\PaymentServices';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createBrandingThemePaymentServices'
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\PaymentService $paymentService (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createBrandingThemePaymentServicesRequest($brandingThemeID, $paymentService)
    {
        // Verify the required parameter 'brandingThemeID' is set

        if ($brandingThemeID === null || (is_array($brandingThemeID) && count($brandingThemeID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'brandingThemeID',
                'createBrandingThemePaymentServices'
            ));
        }
        // Verify the required parameter 'paymentService' is set

        if ($paymentService === null || (is_array($paymentService) && count($paymentService) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'paymentService',
                'createBrandingThemePaymentServices'
            ));
        }

        $resourcePath = '/BrandingThemes/{BrandingThemeID}/PaymentServices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($brandingThemeID !== null) {
            $resourcePath = str_replace(
                '{' . 'BrandingThemeID' . '}',
                ObjectSerializer::toPathValue($brandingThemeID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($paymentService)) {
            $_tempBody = $paymentService;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createContact
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Contact $contact contact (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Contacts|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createContact($contact)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createContactWithHttpInfo($contact);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createContactWithHttpInfo
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Contact $contact (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Contacts|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContactWithHttpInfo($contact)
    {
        $request = $this->createContactRequest($contact);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Contacts'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Contacts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createContact'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Contact $contact (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createContactRequest($contact)
    {
        // Verify the required parameter 'contact' is set

        if ($contact === null || (is_array($contact) && count($contact) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contact',
                'createContact'
            ));
        }

        $resourcePath = '/Contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($contact)) {
            $_tempBody = $contact;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createContactAttachmentByFileName
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createContactAttachmentByFileName($contactID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createContactAttachmentByFileNameWithHttpInfo($contactID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createContactAttachmentByFileNameWithHttpInfo
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContactAttachmentByFileNameWithHttpInfo($contactID, $fileName, $body)
    {
        $request = $this->createContactAttachmentByFileNameRequest($contactID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createContactAttachmentByFileName'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createContactAttachmentByFileNameRequest($contactID, $fileName, $body)
    {
        // Verify the required parameter 'contactID' is set

        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactID',
                'createContactAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'createContactAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'createContactAttachmentByFileName'
            ));
        }

        $resourcePath = '/Contacts/{ContactID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createContactGroup
     *
     * Allows you to create a contact group
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\ContactGroups $contactGroups contactGroups (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ContactGroups|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createContactGroup($contactGroups = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createContactGroupWithHttpInfo($contactGroups);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createContactGroupWithHttpInfo
     *
     * Allows you to create a contact group
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\ContactGroups $contactGroups (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ContactGroups|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContactGroupWithHttpInfo($contactGroups = null)
    {
        $request = $this->createContactGroupRequest($contactGroups);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ContactGroups'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ContactGroups';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createContactGroup'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\ContactGroups $contactGroups (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createContactGroupRequest($contactGroups = null)
    {

        $resourcePath = '/ContactGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($contactGroups)) {
            $_tempBody = $contactGroups;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createContactGroupContacts
     *
     * Allows you to add Contacts to a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Contacts $contacts contacts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Contacts|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createContactGroupContacts($contactGroupID, $contacts = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createContactGroupContactsWithHttpInfo($contactGroupID, $contacts);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createContactGroupContactsWithHttpInfo
     *
     * Allows you to add Contacts to a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Contacts $contacts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Contacts|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContactGroupContactsWithHttpInfo($contactGroupID, $contacts = null)
    {
        $request = $this->createContactGroupContactsRequest($contactGroupID, $contacts);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Contacts'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Contacts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createContactGroupContacts'
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Contacts $contacts (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createContactGroupContactsRequest($contactGroupID, $contacts = null)
    {
        // Verify the required parameter 'contactGroupID' is set

        if ($contactGroupID === null || (is_array($contactGroupID) && count($contactGroupID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactGroupID',
                'createContactGroupContacts'
            ));
        }

        $resourcePath = '/ContactGroups/{ContactGroupID}/Contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactGroupID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactGroupID' . '}',
                ObjectSerializer::toPathValue($contactGroupID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($contacts)) {
            $_tempBody = $contacts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createContactHistory
     *
     * Allows you to retrieve a history records of an Contact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createContactHistory($contactID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createContactHistoryWithHttpInfo($contactID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createContactHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an Contact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContactHistoryWithHttpInfo($contactID, $historyRecords)
    {
        $request = $this->createContactHistoryRequest($contactID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createContactHistory'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createContactHistoryRequest($contactID, $historyRecords)
    {
        // Verify the required parameter 'contactID' is set

        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactID',
                'createContactHistory'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createContactHistory'
            ));
        }

        $resourcePath = '/Contacts/{ContactID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createCreditNote
     *
     * Allows you to create a credit note
     *
     * @param  bool $summarizeErrors shows validation errors for each credit note (optional)
     * @param  \Consilience\Xero\AccountingSdk\Model\CreditNotes $creditNotes creditNotes (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\CreditNotes|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createCreditNote($summarizeErrors = null, $creditNotes = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createCreditNoteWithHttpInfo($summarizeErrors, $creditNotes);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createCreditNoteWithHttpInfo
     *
     * Allows you to create a credit note
     *
     * @param  bool $summarizeErrors shows validation errors for each credit note (optional)
     * @param  \Consilience\Xero\AccountingSdk\Model\CreditNotes $creditNotes (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\CreditNotes|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCreditNoteWithHttpInfo($summarizeErrors = null, $creditNotes = null)
    {
        $request = $this->createCreditNoteRequest($summarizeErrors, $creditNotes);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\CreditNotes'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\CreditNotes';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createCreditNote'
     *
     * @param  bool $summarizeErrors shows validation errors for each credit note (optional)
     * @param  \Consilience\Xero\AccountingSdk\Model\CreditNotes $creditNotes (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createCreditNoteRequest($summarizeErrors = null, $creditNotes = null)
    {

        $resourcePath = '/CreditNotes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($summarizeErrors !== null) {
            $queryParams['SummarizeErrors'] = ObjectSerializer::toQueryValue($summarizeErrors);
        }


        // body params
        $_tempBody = null;
        if (isset($creditNotes)) {
            $_tempBody = $creditNotes;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createCreditNoteAllocation
     *
     * Allows you to create Allocation on CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Allocations $allocations allocations (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Allocations|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createCreditNoteAllocation($creditNoteID, $allocations = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createCreditNoteAllocationWithHttpInfo($creditNoteID, $allocations);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createCreditNoteAllocationWithHttpInfo
     *
     * Allows you to create Allocation on CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Allocations $allocations (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Allocations|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCreditNoteAllocationWithHttpInfo($creditNoteID, $allocations = null)
    {
        $request = $this->createCreditNoteAllocationRequest($creditNoteID, $allocations);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Allocations'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Allocations';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createCreditNoteAllocation'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Allocations $allocations (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createCreditNoteAllocationRequest($creditNoteID, $allocations = null)
    {
        // Verify the required parameter 'creditNoteID' is set

        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'creditNoteID',
                'createCreditNoteAllocation'
            ));
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/Allocations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($allocations)) {
            $_tempBody = $allocations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createCreditNoteAttachmentByFileName
     *
     * Allows you to create Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createCreditNoteAttachmentByFileName($creditNoteID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createCreditNoteAttachmentByFileNameWithHttpInfo($creditNoteID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createCreditNoteAttachmentByFileNameWithHttpInfo
     *
     * Allows you to create Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCreditNoteAttachmentByFileNameWithHttpInfo($creditNoteID, $fileName, $body)
    {
        $request = $this->createCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createCreditNoteAttachmentByFileName'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $body)
    {
        // Verify the required parameter 'creditNoteID' is set

        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'creditNoteID',
                'createCreditNoteAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'createCreditNoteAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'createCreditNoteAttachmentByFileName'
            ));
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createCreditNoteHistory
     *
     * Allows you to retrieve a history records of an CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createCreditNoteHistory($creditNoteID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createCreditNoteHistoryWithHttpInfo($creditNoteID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createCreditNoteHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCreditNoteHistoryWithHttpInfo($creditNoteID, $historyRecords)
    {
        $request = $this->createCreditNoteHistoryRequest($creditNoteID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createCreditNoteHistory'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createCreditNoteHistoryRequest($creditNoteID, $historyRecords)
    {
        // Verify the required parameter 'creditNoteID' is set

        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'creditNoteID',
                'createCreditNoteHistory'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createCreditNoteHistory'
            ));
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createCurrency
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Currencies $currencies currencies (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Currencies
     */
    public function createCurrency($currencies)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createCurrencyWithHttpInfo($currencies);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createCurrencyWithHttpInfo
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Currencies $currencies (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Currencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCurrencyWithHttpInfo($currencies)
    {
        $request = $this->createCurrencyRequest($currencies);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Currencies'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Currencies';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createCurrency'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Currencies $currencies (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createCurrencyRequest($currencies)
    {
        // Verify the required parameter 'currencies' is set

        if ($currencies === null || (is_array($currencies) && count($currencies) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'currencies',
                'createCurrency'
            ));
        }

        $resourcePath = '/Currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($currencies)) {
            $_tempBody = $currencies;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createEmployee
     *
     * Allows you to create new employees used in Xero payrun
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Employees $employees employees (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Employees|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createEmployee($employees)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createEmployeeWithHttpInfo($employees);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createEmployeeWithHttpInfo
     *
     * Allows you to create new employees used in Xero payrun
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Employees $employees (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Employees|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEmployeeWithHttpInfo($employees)
    {
        $request = $this->createEmployeeRequest($employees);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Employees'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Employees';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createEmployee'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Employees $employees (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createEmployeeRequest($employees)
    {
        // Verify the required parameter 'employees' is set

        if ($employees === null || (is_array($employees) && count($employees) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'employees',
                'createEmployee'
            ));
        }

        $resourcePath = '/Employees';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($employees)) {
            $_tempBody = $employees;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createExpenseClaim
     *
     * Allows you to retrieve expense claims
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\ExpenseClaims $expenseClaims expenseClaims (required)
     * @param  bool $summarizeErrors shows validation errors for each expense claim (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ExpenseClaims|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createExpenseClaim($expenseClaims, $summarizeErrors = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createExpenseClaimWithHttpInfo($expenseClaims, $summarizeErrors);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createExpenseClaimWithHttpInfo
     *
     * Allows you to retrieve expense claims
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\ExpenseClaims $expenseClaims (required)
     * @param  bool $summarizeErrors shows validation errors for each expense claim (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ExpenseClaims|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createExpenseClaimWithHttpInfo($expenseClaims, $summarizeErrors = null)
    {
        $request = $this->createExpenseClaimRequest($expenseClaims, $summarizeErrors);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ExpenseClaims'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ExpenseClaims';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createExpenseClaim'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\ExpenseClaims $expenseClaims (required)
     * @param  bool $summarizeErrors shows validation errors for each expense claim (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createExpenseClaimRequest($expenseClaims, $summarizeErrors = null)
    {
        // Verify the required parameter 'expenseClaims' is set

        if ($expenseClaims === null || (is_array($expenseClaims) && count($expenseClaims) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'expenseClaims',
                'createExpenseClaim'
            ));
        }

        $resourcePath = '/ExpenseClaims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($summarizeErrors !== null) {
            $queryParams['SummarizeErrors'] = ObjectSerializer::toQueryValue($summarizeErrors);
        }


        // body params
        $_tempBody = null;
        if (isset($expenseClaims)) {
            $_tempBody = $expenseClaims;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createExpenseClaimHistory
     *
     * Allows you to create a history records of an ExpenseClaim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function createExpenseClaimHistory($expenseClaimID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createExpenseClaimHistoryWithHttpInfo($expenseClaimID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createExpenseClaimHistoryWithHttpInfo
     *
     * Allows you to create a history records of an ExpenseClaim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function createExpenseClaimHistoryWithHttpInfo($expenseClaimID, $historyRecords)
    {
        $request = $this->createExpenseClaimHistoryRequest($expenseClaimID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createExpenseClaimHistory'
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createExpenseClaimHistoryRequest($expenseClaimID, $historyRecords)
    {
        // Verify the required parameter 'expenseClaimID' is set

        if ($expenseClaimID === null || (is_array($expenseClaimID) && count($expenseClaimID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'expenseClaimID',
                'createExpenseClaimHistory'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createExpenseClaimHistory'
            ));
        }

        $resourcePath = '/ExpenseClaims/{ExpenseClaimID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($expenseClaimID !== null) {
            $resourcePath = str_replace(
                '{' . 'ExpenseClaimID' . '}',
                ObjectSerializer::toPathValue($expenseClaimID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createInvoice
     *
     * Allows you to create any sales invoices or purchase bills
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Invoices $invoices invoices (required)
     * @param  bool $summarizeErrors shows validation errors for each invoice (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Invoices|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createInvoice($invoices, $summarizeErrors = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createInvoiceWithHttpInfo($invoices, $summarizeErrors);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createInvoiceWithHttpInfo
     *
     * Allows you to create any sales invoices or purchase bills
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Invoices $invoices (required)
     * @param  bool $summarizeErrors shows validation errors for each invoice (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Invoices|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createInvoiceWithHttpInfo($invoices, $summarizeErrors = null)
    {
        $request = $this->createInvoiceRequest($invoices, $summarizeErrors);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Invoices'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Invoices';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createInvoice'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Invoices $invoices (required)
     * @param  bool $summarizeErrors shows validation errors for each invoice (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createInvoiceRequest($invoices, $summarizeErrors = null)
    {
        // Verify the required parameter 'invoices' is set

        if ($invoices === null || (is_array($invoices) && count($invoices) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoices',
                'createInvoice'
            ));
        }

        $resourcePath = '/Invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($summarizeErrors !== null) {
            $queryParams['SummarizeErrors'] = ObjectSerializer::toQueryValue($summarizeErrors);
        }


        // body params
        $_tempBody = null;
        if (isset($invoices)) {
            $_tempBody = $invoices;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createInvoiceAttachmentByFileName
     *
     * Allows you to create an Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createInvoiceAttachmentByFileName($invoiceID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createInvoiceAttachmentByFileNameWithHttpInfo($invoiceID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createInvoiceAttachmentByFileNameWithHttpInfo
     *
     * Allows you to create an Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createInvoiceAttachmentByFileNameWithHttpInfo($invoiceID, $fileName, $body)
    {
        $request = $this->createInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createInvoiceAttachmentByFileName'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $body)
    {
        // Verify the required parameter 'invoiceID' is set

        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoiceID',
                'createInvoiceAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'createInvoiceAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'createInvoiceAttachmentByFileName'
            ));
        }

        $resourcePath = '/Invoices/{InvoiceID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createInvoiceHistory
     *
     * Allows you to retrieve a history records of an invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createInvoiceHistory($invoiceID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createInvoiceHistoryWithHttpInfo($invoiceID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createInvoiceHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createInvoiceHistoryWithHttpInfo($invoiceID, $historyRecords)
    {
        $request = $this->createInvoiceHistoryRequest($invoiceID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createInvoiceHistory'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createInvoiceHistoryRequest($invoiceID, $historyRecords)
    {
        // Verify the required parameter 'invoiceID' is set

        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoiceID',
                'createInvoiceHistory'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createInvoiceHistory'
            ));
        }

        $resourcePath = '/Invoices/{InvoiceID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createItem
     *
     * Allows you to create an item
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Items $items items (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Items|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createItem($items)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createItemWithHttpInfo($items);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createItemWithHttpInfo
     *
     * Allows you to create an item
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Items $items (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Items|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createItemWithHttpInfo($items)
    {
        $request = $this->createItemRequest($items);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Items'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Items';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createItem'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Items $items (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createItemRequest($items)
    {
        // Verify the required parameter 'items' is set

        if ($items === null || (is_array($items) && count($items) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'items',
                'createItem'
            ));
        }

        $resourcePath = '/Items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($items)) {
            $_tempBody = $items;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createItemHistory
     *
     * Allows you to create a history record for items
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function createItemHistory($itemID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createItemHistoryWithHttpInfo($itemID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createItemHistoryWithHttpInfo
     *
     * Allows you to create a history record for items
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function createItemHistoryWithHttpInfo($itemID, $historyRecords)
    {
        $request = $this->createItemHistoryRequest($itemID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createItemHistory'
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createItemHistoryRequest($itemID, $historyRecords)
    {
        // Verify the required parameter 'itemID' is set

        if ($itemID === null || (is_array($itemID) && count($itemID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'itemID',
                'createItemHistory'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createItemHistory'
            ));
        }

        $resourcePath = '/Items/{ItemID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($itemID !== null) {
            $resourcePath = str_replace(
                '{' . 'ItemID' . '}',
                ObjectSerializer::toPathValue($itemID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createLinkedTransaction
     *
     * Allows you to create linked transactions (billable expenses)
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\LinkedTransactions $linkedTransactions linkedTransactions (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\LinkedTransactions|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createLinkedTransaction($linkedTransactions)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createLinkedTransactionWithHttpInfo($linkedTransactions);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createLinkedTransactionWithHttpInfo
     *
     * Allows you to create linked transactions (billable expenses)
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\LinkedTransactions $linkedTransactions (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\LinkedTransactions|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createLinkedTransactionWithHttpInfo($linkedTransactions)
    {
        $request = $this->createLinkedTransactionRequest($linkedTransactions);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\LinkedTransactions'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\LinkedTransactions';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createLinkedTransaction'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\LinkedTransactions $linkedTransactions (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createLinkedTransactionRequest($linkedTransactions)
    {
        // Verify the required parameter 'linkedTransactions' is set

        if ($linkedTransactions === null || (is_array($linkedTransactions) && count($linkedTransactions) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'linkedTransactions',
                'createLinkedTransaction'
            ));
        }

        $resourcePath = '/LinkedTransactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($linkedTransactions)) {
            $_tempBody = $linkedTransactions;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createManualJournal
     *
     * Allows you to create a manual journal
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\ManualJournals $manualJournals manualJournals (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ManualJournals|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createManualJournal($manualJournals)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createManualJournalWithHttpInfo($manualJournals);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createManualJournalWithHttpInfo
     *
     * Allows you to create a manual journal
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\ManualJournals $manualJournals (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ManualJournals|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createManualJournalWithHttpInfo($manualJournals)
    {
        $request = $this->createManualJournalRequest($manualJournals);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ManualJournals'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ManualJournals';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createManualJournal'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\ManualJournals $manualJournals (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createManualJournalRequest($manualJournals)
    {
        // Verify the required parameter 'manualJournals' is set

        if ($manualJournals === null || (is_array($manualJournals) && count($manualJournals) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'manualJournals',
                'createManualJournal'
            ));
        }

        $resourcePath = '/ManualJournals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($manualJournals)) {
            $_tempBody = $manualJournals;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createManualJournalAttachmentByFileName
     *
     * Allows you to create a specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createManualJournalAttachmentByFileName($manualJournalID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createManualJournalAttachmentByFileNameWithHttpInfo($manualJournalID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createManualJournalAttachmentByFileNameWithHttpInfo
     *
     * Allows you to create a specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createManualJournalAttachmentByFileNameWithHttpInfo($manualJournalID, $fileName, $body)
    {
        $request = $this->createManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createManualJournalAttachmentByFileName'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $body)
    {
        // Verify the required parameter 'manualJournalID' is set

        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'manualJournalID',
                'createManualJournalAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'createManualJournalAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'createManualJournalAttachmentByFileName'
            ));
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createOverpaymentAllocation
     *
     * Allows you to retrieve Allocations for overpayments
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Allocations $allocations allocations (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Allocations|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createOverpaymentAllocation($overpaymentID, $allocations)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createOverpaymentAllocationWithHttpInfo($overpaymentID, $allocations);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createOverpaymentAllocationWithHttpInfo
     *
     * Allows you to retrieve Allocations for overpayments
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Allocations $allocations (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Allocations|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOverpaymentAllocationWithHttpInfo($overpaymentID, $allocations)
    {
        $request = $this->createOverpaymentAllocationRequest($overpaymentID, $allocations);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Allocations'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Allocations';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createOverpaymentAllocation'
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Allocations $allocations (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createOverpaymentAllocationRequest($overpaymentID, $allocations)
    {
        // Verify the required parameter 'overpaymentID' is set

        if ($overpaymentID === null || (is_array($overpaymentID) && count($overpaymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'overpaymentID',
                'createOverpaymentAllocation'
            ));
        }
        // Verify the required parameter 'allocations' is set

        if ($allocations === null || (is_array($allocations) && count($allocations) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'allocations',
                'createOverpaymentAllocation'
            ));
        }

        $resourcePath = '/Overpayments/{OverpaymentID}/Allocations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($overpaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'OverpaymentID' . '}',
                ObjectSerializer::toPathValue($overpaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($allocations)) {
            $_tempBody = $allocations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createOverpaymentHistory
     *
     * Allows you to create history records of an Overpayment
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createOverpaymentHistory($overpaymentID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createOverpaymentHistoryWithHttpInfo($overpaymentID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createOverpaymentHistoryWithHttpInfo
     *
     * Allows you to create history records of an Overpayment
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOverpaymentHistoryWithHttpInfo($overpaymentID, $historyRecords)
    {
        $request = $this->createOverpaymentHistoryRequest($overpaymentID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createOverpaymentHistory'
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createOverpaymentHistoryRequest($overpaymentID, $historyRecords)
    {
        // Verify the required parameter 'overpaymentID' is set

        if ($overpaymentID === null || (is_array($overpaymentID) && count($overpaymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'overpaymentID',
                'createOverpaymentHistory'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createOverpaymentHistory'
            ));
        }

        $resourcePath = '/Overpayments/{OverpaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($overpaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'OverpaymentID' . '}',
                ObjectSerializer::toPathValue($overpaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPayment
     *
     * Allows you to create payments for invoices and credit notes
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Payments $payments payments (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Payments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createPayment($payments)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createPaymentWithHttpInfo($payments);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createPaymentWithHttpInfo
     *
     * Allows you to create payments for invoices and credit notes
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Payments $payments (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Payments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPaymentWithHttpInfo($payments)
    {
        $request = $this->createPaymentRequest($payments);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Payments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Payments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createPayment'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Payments $payments (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createPaymentRequest($payments)
    {
        // Verify the required parameter 'payments' is set

        if ($payments === null || (is_array($payments) && count($payments) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'payments',
                'createPayment'
            ));
        }

        $resourcePath = '/Payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($payments)) {
            $_tempBody = $payments;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPaymentHistory
     *
     * Allows you to create a history record for a payment
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createPaymentHistory($paymentID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createPaymentHistoryWithHttpInfo($paymentID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createPaymentHistoryWithHttpInfo
     *
     * Allows you to create a history record for a payment
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPaymentHistoryWithHttpInfo($paymentID, $historyRecords)
    {
        $request = $this->createPaymentHistoryRequest($paymentID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createPaymentHistory'
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createPaymentHistoryRequest($paymentID, $historyRecords)
    {
        // Verify the required parameter 'paymentID' is set

        if ($paymentID === null || (is_array($paymentID) && count($paymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'paymentID',
                'createPaymentHistory'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createPaymentHistory'
            ));
        }

        $resourcePath = '/Payments/{PaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($paymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PaymentID' . '}',
                ObjectSerializer::toPathValue($paymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPaymentService
     *
     * Allows you to create payment services
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\PaymentServices $paymentServices paymentServices (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\PaymentServices|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createPaymentService($paymentServices)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createPaymentServiceWithHttpInfo($paymentServices);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createPaymentServiceWithHttpInfo
     *
     * Allows you to create payment services
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\PaymentServices $paymentServices (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\PaymentServices|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPaymentServiceWithHttpInfo($paymentServices)
    {
        $request = $this->createPaymentServiceRequest($paymentServices);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\PaymentServices'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\PaymentServices';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createPaymentService'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\PaymentServices $paymentServices (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createPaymentServiceRequest($paymentServices)
    {
        // Verify the required parameter 'paymentServices' is set

        if ($paymentServices === null || (is_array($paymentServices) && count($paymentServices) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'paymentServices',
                'createPaymentService'
            ));
        }

        $resourcePath = '/PaymentServices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($paymentServices)) {
            $_tempBody = $paymentServices;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPrepaymentAllocation
     *
     * Allows you to create an Allocation for prepayments
     *
     * @param  string $prepaymentID prepaymentID (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Allocations $allocations allocations (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Allocations|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createPrepaymentAllocation($prepaymentID, $allocations)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createPrepaymentAllocationWithHttpInfo($prepaymentID, $allocations);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createPrepaymentAllocationWithHttpInfo
     *
     * Allows you to create an Allocation for prepayments
     *
     * @param  string $prepaymentID (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Allocations $allocations (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Allocations|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPrepaymentAllocationWithHttpInfo($prepaymentID, $allocations)
    {
        $request = $this->createPrepaymentAllocationRequest($prepaymentID, $allocations);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Allocations'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Allocations';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createPrepaymentAllocation'
     *
     * @param  string $prepaymentID (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Allocations $allocations (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createPrepaymentAllocationRequest($prepaymentID, $allocations)
    {
        // Verify the required parameter 'prepaymentID' is set

        if ($prepaymentID === null || (is_array($prepaymentID) && count($prepaymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'prepaymentID',
                'createPrepaymentAllocation'
            ));
        }
        // Verify the required parameter 'allocations' is set

        if ($allocations === null || (is_array($allocations) && count($allocations) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'allocations',
                'createPrepaymentAllocation'
            ));
        }

        $resourcePath = '/Prepayments/{PrepaymentID}/Allocations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($prepaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PrepaymentID' . '}',
                ObjectSerializer::toPathValue($prepaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($allocations)) {
            $_tempBody = $allocations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPrepaymentHistory
     *
     * Allows you to create a history record for an Prepayment
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createPrepaymentHistory($prepaymentID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createPrepaymentHistoryWithHttpInfo($prepaymentID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createPrepaymentHistoryWithHttpInfo
     *
     * Allows you to create a history record for an Prepayment
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPrepaymentHistoryWithHttpInfo($prepaymentID, $historyRecords)
    {
        $request = $this->createPrepaymentHistoryRequest($prepaymentID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createPrepaymentHistory'
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createPrepaymentHistoryRequest($prepaymentID, $historyRecords)
    {
        // Verify the required parameter 'prepaymentID' is set

        if ($prepaymentID === null || (is_array($prepaymentID) && count($prepaymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'prepaymentID',
                'createPrepaymentHistory'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createPrepaymentHistory'
            ));
        }

        $resourcePath = '/Prepayments/{PrepaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($prepaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PrepaymentID' . '}',
                ObjectSerializer::toPathValue($prepaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPurchaseOrder
     *
     * Allows you to create purchase orders
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\PurchaseOrders $purchaseOrders purchaseOrders (required)
     * @param  bool $summarizeErrors shows validation errors for each purchase order. (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\PurchaseOrders|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createPurchaseOrder($purchaseOrders, $summarizeErrors = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createPurchaseOrderWithHttpInfo($purchaseOrders, $summarizeErrors);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createPurchaseOrderWithHttpInfo
     *
     * Allows you to create purchase orders
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\PurchaseOrders $purchaseOrders (required)
     * @param  bool $summarizeErrors shows validation errors for each purchase order. (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\PurchaseOrders|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPurchaseOrderWithHttpInfo($purchaseOrders, $summarizeErrors = null)
    {
        $request = $this->createPurchaseOrderRequest($purchaseOrders, $summarizeErrors);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\PurchaseOrders'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\PurchaseOrders';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createPurchaseOrder'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\PurchaseOrders $purchaseOrders (required)
     * @param  bool $summarizeErrors shows validation errors for each purchase order. (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createPurchaseOrderRequest($purchaseOrders, $summarizeErrors = null)
    {
        // Verify the required parameter 'purchaseOrders' is set

        if ($purchaseOrders === null || (is_array($purchaseOrders) && count($purchaseOrders) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'purchaseOrders',
                'createPurchaseOrder'
            ));
        }

        $resourcePath = '/PurchaseOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($summarizeErrors !== null) {
            $queryParams['SummarizeErrors'] = ObjectSerializer::toQueryValue($summarizeErrors);
        }


        // body params
        $_tempBody = null;
        if (isset($purchaseOrders)) {
            $_tempBody = $purchaseOrders;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createPurchaseOrderHistory
     *
     * Allows you to create HistoryRecord for purchase orders
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createPurchaseOrderHistory($purchaseOrderID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createPurchaseOrderHistoryWithHttpInfo($purchaseOrderID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createPurchaseOrderHistoryWithHttpInfo
     *
     * Allows you to create HistoryRecord for purchase orders
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPurchaseOrderHistoryWithHttpInfo($purchaseOrderID, $historyRecords)
    {
        $request = $this->createPurchaseOrderHistoryRequest($purchaseOrderID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createPurchaseOrderHistory'
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createPurchaseOrderHistoryRequest($purchaseOrderID, $historyRecords)
    {
        // Verify the required parameter 'purchaseOrderID' is set

        if ($purchaseOrderID === null || (is_array($purchaseOrderID) && count($purchaseOrderID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'purchaseOrderID',
                'createPurchaseOrderHistory'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createPurchaseOrderHistory'
            ));
        }

        $resourcePath = '/PurchaseOrders/{PurchaseOrderID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($purchaseOrderID !== null) {
            $resourcePath = str_replace(
                '{' . 'PurchaseOrderID' . '}',
                ObjectSerializer::toPathValue($purchaseOrderID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createReceipt
     *
     * Allows you to create draft expense claim receipts for any user
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Receipts $receipts receipts (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Receipts|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createReceipt($receipts)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createReceiptWithHttpInfo($receipts);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createReceiptWithHttpInfo
     *
     * Allows you to create draft expense claim receipts for any user
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Receipts $receipts (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Receipts|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createReceiptWithHttpInfo($receipts)
    {
        $request = $this->createReceiptRequest($receipts);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Receipts'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Receipts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createReceipt'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\Receipts $receipts (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createReceiptRequest($receipts)
    {
        // Verify the required parameter 'receipts' is set

        if ($receipts === null || (is_array($receipts) && count($receipts) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'receipts',
                'createReceipt'
            ));
        }

        $resourcePath = '/Receipts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($receipts)) {
            $_tempBody = $receipts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createReceiptAttachmentByFileName
     *
     * Allows you to create Attachment on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createReceiptAttachmentByFileName($receiptID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createReceiptAttachmentByFileNameWithHttpInfo($receiptID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createReceiptAttachmentByFileNameWithHttpInfo
     *
     * Allows you to create Attachment on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createReceiptAttachmentByFileNameWithHttpInfo($receiptID, $fileName, $body)
    {
        $request = $this->createReceiptAttachmentByFileNameRequest($receiptID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createReceiptAttachmentByFileName'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createReceiptAttachmentByFileNameRequest($receiptID, $fileName, $body)
    {
        // Verify the required parameter 'receiptID' is set

        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'receiptID',
                'createReceiptAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'createReceiptAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'createReceiptAttachmentByFileName'
            ));
        }

        $resourcePath = '/Receipts/{ReceiptID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createReceiptHistory
     *
     * Allows you to retrieve a history records of an Receipt
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createReceiptHistory($receiptID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createReceiptHistoryWithHttpInfo($receiptID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createReceiptHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an Receipt
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createReceiptHistoryWithHttpInfo($receiptID, $historyRecords)
    {
        $request = $this->createReceiptHistoryRequest($receiptID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createReceiptHistory'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createReceiptHistoryRequest($receiptID, $historyRecords)
    {
        // Verify the required parameter 'receiptID' is set

        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'receiptID',
                'createReceiptHistory'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createReceiptHistory'
            ));
        }

        $resourcePath = '/Receipts/{ReceiptID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createRepeatingInvoiceAttachmentByFileName
     *
     * Allows you to create attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createRepeatingInvoiceAttachmentByFileName($repeatingInvoiceID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createRepeatingInvoiceAttachmentByFileNameWithHttpInfo($repeatingInvoiceID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createRepeatingInvoiceAttachmentByFileNameWithHttpInfo
     *
     * Allows you to create attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRepeatingInvoiceAttachmentByFileNameWithHttpInfo($repeatingInvoiceID, $fileName, $body)
    {
        $request = $this->createRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createRepeatingInvoiceAttachmentByFileName'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $body)
    {
        // Verify the required parameter 'repeatingInvoiceID' is set

        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'repeatingInvoiceID',
                'createRepeatingInvoiceAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'createRepeatingInvoiceAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'createRepeatingInvoiceAttachmentByFileName'
            ));
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createRepeatingInvoiceHistory
     *
     * Allows you to create history for a repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createRepeatingInvoiceHistory($repeatingInvoiceID, $historyRecords)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createRepeatingInvoiceHistoryWithHttpInfo($repeatingInvoiceID, $historyRecords);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createRepeatingInvoiceHistoryWithHttpInfo
     *
     * Allows you to create history for a repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRepeatingInvoiceHistoryWithHttpInfo($repeatingInvoiceID, $historyRecords)
    {
        $request = $this->createRepeatingInvoiceHistoryRequest($repeatingInvoiceID, $historyRecords);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createRepeatingInvoiceHistory'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\HistoryRecords $historyRecords (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createRepeatingInvoiceHistoryRequest($repeatingInvoiceID, $historyRecords)
    {
        // Verify the required parameter 'repeatingInvoiceID' is set

        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'repeatingInvoiceID',
                'createRepeatingInvoiceHistory'
            ));
        }
        // Verify the required parameter 'historyRecords' is set

        if ($historyRecords === null || (is_array($historyRecords) && count($historyRecords) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'historyRecords',
                'createRepeatingInvoiceHistory'
            ));
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($historyRecords)) {
            $_tempBody = $historyRecords;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createTaxRate
     *
     * Allows you to create Tax Rates
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\TaxRates $taxRates taxRates (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\TaxRates|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createTaxRate($taxRates)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createTaxRateWithHttpInfo($taxRates);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createTaxRateWithHttpInfo
     *
     * Allows you to create Tax Rates
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\TaxRates $taxRates (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\TaxRates|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTaxRateWithHttpInfo($taxRates)
    {
        $request = $this->createTaxRateRequest($taxRates);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\TaxRates'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\TaxRates';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createTaxRate'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\TaxRates $taxRates (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createTaxRateRequest($taxRates)
    {
        // Verify the required parameter 'taxRates' is set

        if ($taxRates === null || (is_array($taxRates) && count($taxRates) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'taxRates',
                'createTaxRate'
            ));
        }

        $resourcePath = '/TaxRates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($taxRates)) {
            $_tempBody = $taxRates;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createTrackingCategory
     *
     * Allows you to create tracking categories
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\TrackingCategory $trackingCategory trackingCategory (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\TrackingCategories|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createTrackingCategory($trackingCategory)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createTrackingCategoryWithHttpInfo($trackingCategory);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createTrackingCategoryWithHttpInfo
     *
     * Allows you to create tracking categories
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\TrackingCategory $trackingCategory (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\TrackingCategories|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTrackingCategoryWithHttpInfo($trackingCategory)
    {
        $request = $this->createTrackingCategoryRequest($trackingCategory);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\TrackingCategories'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\TrackingCategories';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createTrackingCategory'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\TrackingCategory $trackingCategory (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createTrackingCategoryRequest($trackingCategory)
    {
        // Verify the required parameter 'trackingCategory' is set

        if ($trackingCategory === null || (is_array($trackingCategory) && count($trackingCategory) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'trackingCategory',
                'createTrackingCategory'
            ));
        }

        $resourcePath = '/TrackingCategories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($trackingCategory)) {
            $_tempBody = $trackingCategory;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation createTrackingOptions
     *
     * Allows you to create options for a specified tracking category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\TrackingOption $trackingOption trackingOption (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\TrackingOptions|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function createTrackingOptions($trackingCategoryID, $trackingOption)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->createTrackingOptionsWithHttpInfo($trackingCategoryID, $trackingOption);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation createTrackingOptionsWithHttpInfo
     *
     * Allows you to create options for a specified tracking category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\TrackingOption $trackingOption (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\TrackingOptions|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTrackingOptionsWithHttpInfo($trackingCategoryID, $trackingOption)
    {
        $request = $this->createTrackingOptionsRequest($trackingCategoryID, $trackingOption);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\TrackingOptions'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\TrackingOptions';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'createTrackingOptions'
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\TrackingOption $trackingOption (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function createTrackingOptionsRequest($trackingCategoryID, $trackingOption)
    {
        // Verify the required parameter 'trackingCategoryID' is set

        if ($trackingCategoryID === null || (is_array($trackingCategoryID) && count($trackingCategoryID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'trackingCategoryID',
                'createTrackingOptions'
            ));
        }
        // Verify the required parameter 'trackingOption' is set

        if ($trackingOption === null || (is_array($trackingOption) && count($trackingOption) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'trackingOption',
                'createTrackingOptions'
            ));
        }

        $resourcePath = '/TrackingCategories/{TrackingCategoryID}/Options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($trackingCategoryID !== null) {
            $resourcePath = str_replace(
                '{' . 'TrackingCategoryID' . '}',
                ObjectSerializer::toPathValue($trackingCategoryID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($trackingOption)) {
            $_tempBody = $trackingOption;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'PUT'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('PUT', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteAccount
     *
     * Allows you to delete a chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Accounts|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function deleteAccount($accountID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->deleteAccountWithHttpInfo($accountID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation deleteAccountWithHttpInfo
     *
     * Allows you to delete a chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Accounts|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAccountWithHttpInfo($accountID)
    {
        $request = $this->deleteAccountRequest($accountID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Accounts'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Accounts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'deleteAccount'
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function deleteAccountRequest($accountID)
    {
        // Verify the required parameter 'accountID' is set

        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'accountID',
                'deleteAccount'
            ));
        }

        $resourcePath = '/Accounts/{AccountID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'DELETE'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteContactGroupContact
     *
     * Allows you to delete a specific Contact from a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteContactGroupContact($contactGroupID, $contactID)
    {
        $this->deleteContactGroupContactWithHttpInfo($contactGroupID, $contactID);
    }

    /**
     * Operation deleteContactGroupContactWithHttpInfo
     *
     * Allows you to delete a specific Contact from a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContactGroupContactWithHttpInfo($contactGroupID, $contactID)
    {
        $request = $this->deleteContactGroupContactRequest($contactGroupID, $contactID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        // No expected payload.

        return [null, $request, $response];
    }


    /**
     * Create request for operation 'deleteContactGroupContact'
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function deleteContactGroupContactRequest($contactGroupID, $contactID)
    {
        // Verify the required parameter 'contactGroupID' is set

        if ($contactGroupID === null || (is_array($contactGroupID) && count($contactGroupID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactGroupID',
                'deleteContactGroupContact'
            ));
        }
        // Verify the required parameter 'contactID' is set

        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactID',
                'deleteContactGroupContact'
            ));
        }

        $resourcePath = '/ContactGroups/{ContactGroupID}/Contacts/{ContactID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactGroupID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactGroupID' . '}',
                ObjectSerializer::toPathValue($contactGroupID),
                $resourcePath
            );
        }
        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'DELETE'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteContactGroupContacts
     *
     * Allows you to delete  all Contacts from a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteContactGroupContacts($contactGroupID)
    {
        $this->deleteContactGroupContactsWithHttpInfo($contactGroupID);
    }

    /**
     * Operation deleteContactGroupContactsWithHttpInfo
     *
     * Allows you to delete  all Contacts from a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContactGroupContactsWithHttpInfo($contactGroupID)
    {
        $request = $this->deleteContactGroupContactsRequest($contactGroupID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        // No expected payload.

        return [null, $request, $response];
    }


    /**
     * Create request for operation 'deleteContactGroupContacts'
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function deleteContactGroupContactsRequest($contactGroupID)
    {
        // Verify the required parameter 'contactGroupID' is set

        if ($contactGroupID === null || (is_array($contactGroupID) && count($contactGroupID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactGroupID',
                'deleteContactGroupContacts'
            ));
        }

        $resourcePath = '/ContactGroups/{ContactGroupID}/Contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactGroupID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactGroupID' . '}',
                ObjectSerializer::toPathValue($contactGroupID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'DELETE'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteItem
     *
     * Allows you to delete a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteItem($itemID)
    {
        $this->deleteItemWithHttpInfo($itemID);
    }

    /**
     * Operation deleteItemWithHttpInfo
     *
     * Allows you to delete a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteItemWithHttpInfo($itemID)
    {
        $request = $this->deleteItemRequest($itemID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        // No expected payload.

        return [null, $request, $response];
    }


    /**
     * Create request for operation 'deleteItem'
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function deleteItemRequest($itemID)
    {
        // Verify the required parameter 'itemID' is set

        if ($itemID === null || (is_array($itemID) && count($itemID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'itemID',
                'deleteItem'
            ));
        }

        $resourcePath = '/Items/{ItemID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($itemID !== null) {
            $resourcePath = str_replace(
                '{' . 'ItemID' . '}',
                ObjectSerializer::toPathValue($itemID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'DELETE'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteLinkedTransaction
     *
     * Allows you to delete a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteLinkedTransaction($linkedTransactionID)
    {
        $this->deleteLinkedTransactionWithHttpInfo($linkedTransactionID);
    }

    /**
     * Operation deleteLinkedTransactionWithHttpInfo
     *
     * Allows you to delete a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteLinkedTransactionWithHttpInfo($linkedTransactionID)
    {
        $request = $this->deleteLinkedTransactionRequest($linkedTransactionID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        // No expected payload.

        return [null, $request, $response];
    }


    /**
     * Create request for operation 'deleteLinkedTransaction'
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function deleteLinkedTransactionRequest($linkedTransactionID)
    {
        // Verify the required parameter 'linkedTransactionID' is set

        if ($linkedTransactionID === null || (is_array($linkedTransactionID) && count($linkedTransactionID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'linkedTransactionID',
                'deleteLinkedTransaction'
            ));
        }

        $resourcePath = '/LinkedTransactions/{LinkedTransactionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($linkedTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'LinkedTransactionID' . '}',
                ObjectSerializer::toPathValue($linkedTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'DELETE'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deletePayment
     *
     * Allows you to update a specified payment for invoices and credit notes
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Payments $payments payments (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Payments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function deletePayment($paymentID, $payments)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->deletePaymentWithHttpInfo($paymentID, $payments);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation deletePaymentWithHttpInfo
     *
     * Allows you to update a specified payment for invoices and credit notes
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Payments $payments (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Payments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePaymentWithHttpInfo($paymentID, $payments)
    {
        $request = $this->deletePaymentRequest($paymentID, $payments);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Payments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Payments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'deletePayment'
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Payments $payments (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function deletePaymentRequest($paymentID, $payments)
    {
        // Verify the required parameter 'paymentID' is set

        if ($paymentID === null || (is_array($paymentID) && count($paymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'paymentID',
                'deletePayment'
            ));
        }
        // Verify the required parameter 'payments' is set

        if ($payments === null || (is_array($payments) && count($payments) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'payments',
                'deletePayment'
            ));
        }

        $resourcePath = '/Payments/{PaymentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($paymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PaymentID' . '}',
                ObjectSerializer::toPathValue($paymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($payments)) {
            $_tempBody = $payments;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteTrackingCategory
     *
     * Allows you to delete tracking categories
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\TrackingCategories|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function deleteTrackingCategory($trackingCategoryID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->deleteTrackingCategoryWithHttpInfo($trackingCategoryID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation deleteTrackingCategoryWithHttpInfo
     *
     * Allows you to delete tracking categories
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\TrackingCategories|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTrackingCategoryWithHttpInfo($trackingCategoryID)
    {
        $request = $this->deleteTrackingCategoryRequest($trackingCategoryID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\TrackingCategories'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\TrackingCategories';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'deleteTrackingCategory'
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function deleteTrackingCategoryRequest($trackingCategoryID)
    {
        // Verify the required parameter 'trackingCategoryID' is set

        if ($trackingCategoryID === null || (is_array($trackingCategoryID) && count($trackingCategoryID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'trackingCategoryID',
                'deleteTrackingCategory'
            ));
        }

        $resourcePath = '/TrackingCategories/{TrackingCategoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($trackingCategoryID !== null) {
            $resourcePath = str_replace(
                '{' . 'TrackingCategoryID' . '}',
                ObjectSerializer::toPathValue($trackingCategoryID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'DELETE'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation deleteTrackingOptions
     *
     * Allows you to delete a specified option for a specified tracking category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  string $trackingOptionID Unique identifier for a Tracking Option (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\TrackingOptions|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function deleteTrackingOptions($trackingCategoryID, $trackingOptionID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->deleteTrackingOptionsWithHttpInfo($trackingCategoryID, $trackingOptionID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation deleteTrackingOptionsWithHttpInfo
     *
     * Allows you to delete a specified option for a specified tracking category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  string $trackingOptionID Unique identifier for a Tracking Option (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\TrackingOptions|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTrackingOptionsWithHttpInfo($trackingCategoryID, $trackingOptionID)
    {
        $request = $this->deleteTrackingOptionsRequest($trackingCategoryID, $trackingOptionID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\TrackingOptions'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\TrackingOptions';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'deleteTrackingOptions'
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  string $trackingOptionID Unique identifier for a Tracking Option (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function deleteTrackingOptionsRequest($trackingCategoryID, $trackingOptionID)
    {
        // Verify the required parameter 'trackingCategoryID' is set

        if ($trackingCategoryID === null || (is_array($trackingCategoryID) && count($trackingCategoryID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'trackingCategoryID',
                'deleteTrackingOptions'
            ));
        }
        // Verify the required parameter 'trackingOptionID' is set

        if ($trackingOptionID === null || (is_array($trackingOptionID) && count($trackingOptionID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'trackingOptionID',
                'deleteTrackingOptions'
            ));
        }

        $resourcePath = '/TrackingCategories/{TrackingCategoryID}/Options/{TrackingOptionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($trackingCategoryID !== null) {
            $resourcePath = str_replace(
                '{' . 'TrackingCategoryID' . '}',
                ObjectSerializer::toPathValue($trackingCategoryID),
                $resourcePath
            );
        }
        // path params
        if ($trackingOptionID !== null) {
            $resourcePath = str_replace(
                '{' . 'TrackingOptionID' . '}',
                ObjectSerializer::toPathValue($trackingOptionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'DELETE'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('DELETE', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation emailInvoice
     *
     * Allows you to email a copy of invoice to related Contact
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\RequestEmpty $requestEmpty requestEmpty (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return void
     */
    public function emailInvoice($invoiceID, $requestEmpty)
    {
        $this->emailInvoiceWithHttpInfo($invoiceID, $requestEmpty);
    }

    /**
     * Operation emailInvoiceWithHttpInfo
     *
     * Allows you to email a copy of invoice to related Contact
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\RequestEmpty $requestEmpty (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function emailInvoiceWithHttpInfo($invoiceID, $requestEmpty)
    {
        $request = $this->emailInvoiceRequest($invoiceID, $requestEmpty);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        // No expected payload.

        return [null, $request, $response];
    }


    /**
     * Create request for operation 'emailInvoice'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\RequestEmpty $requestEmpty (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function emailInvoiceRequest($invoiceID, $requestEmpty)
    {
        // Verify the required parameter 'invoiceID' is set

        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoiceID',
                'emailInvoice'
            ));
        }
        // Verify the required parameter 'requestEmpty' is set

        if ($requestEmpty === null || (is_array($requestEmpty) && count($requestEmpty) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'requestEmpty',
                'emailInvoice'
            ));
        }

        $resourcePath = '/Invoices/{InvoiceID}/Email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($requestEmpty)) {
            $_tempBody = $requestEmpty;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getAccount
     *
     * Allows you to retrieve a single chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Accounts
     */
    public function getAccount($accountID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getAccountWithHttpInfo($accountID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getAccountWithHttpInfo
     *
     * Allows you to retrieve a single chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Accounts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountWithHttpInfo($accountID)
    {
        $request = $this->getAccountRequest($accountID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Accounts'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Accounts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getAccount'
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getAccountRequest($accountID)
    {
        // Verify the required parameter 'accountID' is set

        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'accountID',
                'getAccount'
            ));
        }

        $resourcePath = '/Accounts/{AccountID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getAccountAttachmentByFileName
     *
     * Allows you to retrieve Attachment on Account by Filename
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getAccountAttachmentByFileName($accountID, $fileName, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getAccountAttachmentByFileNameWithHttpInfo($accountID, $fileName, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getAccountAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachment on Account by Filename
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountAttachmentByFileNameWithHttpInfo($accountID, $fileName, $contentType)
    {
        $request = $this->getAccountAttachmentByFileNameRequest($accountID, $fileName, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getAccountAttachmentByFileName'
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getAccountAttachmentByFileNameRequest($accountID, $fileName, $contentType)
    {
        // Verify the required parameter 'accountID' is set

        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'accountID',
                'getAccountAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'getAccountAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getAccountAttachmentByFileName'
            ));
        }

        $resourcePath = '/Accounts/{AccountID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getAccountAttachmentById
     *
     * Allows you to retrieve specific Attachment on Account
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $attachmentID Unique identifier for Attachment object (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getAccountAttachmentById($accountID, $attachmentID, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getAccountAttachmentByIdWithHttpInfo($accountID, $attachmentID, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getAccountAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve specific Attachment on Account
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $attachmentID Unique identifier for Attachment object (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountAttachmentByIdWithHttpInfo($accountID, $attachmentID, $contentType)
    {
        $request = $this->getAccountAttachmentByIdRequest($accountID, $attachmentID, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getAccountAttachmentById'
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $attachmentID Unique identifier for Attachment object (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getAccountAttachmentByIdRequest($accountID, $attachmentID, $contentType)
    {
        // Verify the required parameter 'accountID' is set

        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'accountID',
                'getAccountAttachmentById'
            ));
        }
        // Verify the required parameter 'attachmentID' is set

        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'attachmentID',
                'getAccountAttachmentById'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getAccountAttachmentById'
            ));
        }

        $resourcePath = '/Accounts/{AccountID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getAccountAttachments
     *
     * Allows you to retrieve Attachments for accounts
     *
     * @param  string $accountID Unique identifier for Account object (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments
     */
    public function getAccountAttachments($accountID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getAccountAttachmentsWithHttpInfo($accountID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getAccountAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachments for accounts
     *
     * @param  string $accountID Unique identifier for Account object (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountAttachmentsWithHttpInfo($accountID)
    {
        $request = $this->getAccountAttachmentsRequest($accountID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getAccountAttachments'
     *
     * @param  string $accountID Unique identifier for Account object (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getAccountAttachmentsRequest($accountID)
    {
        // Verify the required parameter 'accountID' is set

        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'accountID',
                'getAccountAttachments'
            ));
        }

        $resourcePath = '/Accounts/{AccountID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getAccounts
     *
     * Allows you to retrieve the full chart of accounts
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Accounts
     */
    public function getAccounts($ifModifiedSince = null, $where = null, $order = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getAccountsWithHttpInfo($ifModifiedSince, $where, $order);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getAccountsWithHttpInfo
     *
     * Allows you to retrieve the full chart of accounts
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Accounts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getAccountsRequest($ifModifiedSince, $where, $order);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Accounts'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Accounts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getAccounts'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getAccountsRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/Accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransaction
     *
     * Allows you to retrieve a single spend or receive money transaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\BankTransactions
     */
    public function getBankTransaction($bankTransactionID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBankTransactionWithHttpInfo($bankTransactionID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBankTransactionWithHttpInfo
     *
     * Allows you to retrieve a single spend or receive money transaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\BankTransactions, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransactionWithHttpInfo($bankTransactionID)
    {
        $request = $this->getBankTransactionRequest($bankTransactionID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\BankTransactions'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\BankTransactions';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBankTransaction'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBankTransactionRequest($bankTransactionID)
    {
        // Verify the required parameter 'bankTransactionID' is set

        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransactionID',
                'getBankTransaction'
            ));
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransactionAttachmentByFileName
     *
     * Allows you to retrieve Attachments on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getBankTransactionAttachmentByFileName($bankTransactionID, $fileName, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBankTransactionAttachmentByFileNameWithHttpInfo($bankTransactionID, $fileName, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBankTransactionAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachments on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransactionAttachmentByFileNameWithHttpInfo($bankTransactionID, $fileName, $contentType)
    {
        $request = $this->getBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBankTransactionAttachmentByFileName'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $contentType)
    {
        // Verify the required parameter 'bankTransactionID' is set

        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransactionID',
                'getBankTransactionAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'getBankTransactionAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getBankTransactionAttachmentByFileName'
            ));
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransactionAttachmentById
     *
     * Allows you to retrieve Attachments on a specific BankTransaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $attachmentID Xero generated unique identifier for an attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getBankTransactionAttachmentById($bankTransactionID, $attachmentID, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBankTransactionAttachmentByIdWithHttpInfo($bankTransactionID, $attachmentID, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBankTransactionAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve Attachments on a specific BankTransaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $attachmentID Xero generated unique identifier for an attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransactionAttachmentByIdWithHttpInfo($bankTransactionID, $attachmentID, $contentType)
    {
        $request = $this->getBankTransactionAttachmentByIdRequest($bankTransactionID, $attachmentID, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBankTransactionAttachmentById'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $attachmentID Xero generated unique identifier for an attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBankTransactionAttachmentByIdRequest($bankTransactionID, $attachmentID, $contentType)
    {
        // Verify the required parameter 'bankTransactionID' is set

        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransactionID',
                'getBankTransactionAttachmentById'
            ));
        }
        // Verify the required parameter 'attachmentID' is set

        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'attachmentID',
                'getBankTransactionAttachmentById'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getBankTransactionAttachmentById'
            ));
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransactionAttachments
     *
     * Allows you to retrieve any attachments to bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments
     */
    public function getBankTransactionAttachments($bankTransactionID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBankTransactionAttachmentsWithHttpInfo($bankTransactionID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBankTransactionAttachmentsWithHttpInfo
     *
     * Allows you to retrieve any attachments to bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransactionAttachmentsWithHttpInfo($bankTransactionID)
    {
        $request = $this->getBankTransactionAttachmentsRequest($bankTransactionID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBankTransactionAttachments'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBankTransactionAttachmentsRequest($bankTransactionID)
    {
        // Verify the required parameter 'bankTransactionID' is set

        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransactionID',
                'getBankTransactionAttachments'
            ));
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransactions
     *
     * Allows you to retrieve any spend or receive money transactions
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 bank transactions will be returned in a single API call with line items shown for each bank transaction (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\BankTransactions
     */
    public function getBankTransactions($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBankTransactionsWithHttpInfo($ifModifiedSince, $where, $order, $page, $unitdp);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBankTransactionsWithHttpInfo
     *
     * Allows you to retrieve any spend or receive money transactions
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 bank transactions will be returned in a single API call with line items shown for each bank transaction (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\BankTransactions, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransactionsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        $request = $this->getBankTransactionsRequest($ifModifiedSince, $where, $order, $page, $unitdp);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\BankTransactions'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\BankTransactions';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBankTransactions'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 bank transactions will be returned in a single API call with line items shown for each bank transaction (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBankTransactionsRequest($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {

        $resourcePath = '/BankTransactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($unitdp !== null) {
            $queryParams['unitdp'] = ObjectSerializer::toQueryValue($unitdp);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransactionsHistory
     *
     * Allows you to retrieve history from a bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getBankTransactionsHistory($bankTransactionID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBankTransactionsHistoryWithHttpInfo($bankTransactionID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBankTransactionsHistoryWithHttpInfo
     *
     * Allows you to retrieve history from a bank transactions
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransactionsHistoryWithHttpInfo($bankTransactionID)
    {
        $request = $this->getBankTransactionsHistoryRequest($bankTransactionID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBankTransactionsHistory'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBankTransactionsHistoryRequest($bankTransactionID)
    {
        // Verify the required parameter 'bankTransactionID' is set

        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransactionID',
                'getBankTransactionsHistory'
            ));
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransfer
     *
     * Allows you to retrieve any bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\BankTransfers
     */
    public function getBankTransfer($bankTransferID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBankTransferWithHttpInfo($bankTransferID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBankTransferWithHttpInfo
     *
     * Allows you to retrieve any bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\BankTransfers, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransferWithHttpInfo($bankTransferID)
    {
        $request = $this->getBankTransferRequest($bankTransferID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\BankTransfers'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\BankTransfers';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBankTransfer'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBankTransferRequest($bankTransferID)
    {
        // Verify the required parameter 'bankTransferID' is set

        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransferID',
                'getBankTransfer'
            ));
        }

        $resourcePath = '/BankTransfers/{BankTransferID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransferAttachmentByFileName
     *
     * Allows you to retrieve Attachments on BankTransfer by file name
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getBankTransferAttachmentByFileName($bankTransferID, $fileName, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBankTransferAttachmentByFileNameWithHttpInfo($bankTransferID, $fileName, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBankTransferAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachments on BankTransfer by file name
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransferAttachmentByFileNameWithHttpInfo($bankTransferID, $fileName, $contentType)
    {
        $request = $this->getBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBankTransferAttachmentByFileName'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $contentType)
    {
        // Verify the required parameter 'bankTransferID' is set

        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransferID',
                'getBankTransferAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'getBankTransferAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getBankTransferAttachmentByFileName'
            ));
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransferAttachmentById
     *
     * Allows you to retrieve Attachments on BankTransfer
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $attachmentID Xero generated unique identifier for an Attachment to a bank transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getBankTransferAttachmentById($bankTransferID, $attachmentID, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBankTransferAttachmentByIdWithHttpInfo($bankTransferID, $attachmentID, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBankTransferAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve Attachments on BankTransfer
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $attachmentID Xero generated unique identifier for an Attachment to a bank transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransferAttachmentByIdWithHttpInfo($bankTransferID, $attachmentID, $contentType)
    {
        $request = $this->getBankTransferAttachmentByIdRequest($bankTransferID, $attachmentID, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBankTransferAttachmentById'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $attachmentID Xero generated unique identifier for an Attachment to a bank transfer (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBankTransferAttachmentByIdRequest($bankTransferID, $attachmentID, $contentType)
    {
        // Verify the required parameter 'bankTransferID' is set

        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransferID',
                'getBankTransferAttachmentById'
            ));
        }
        // Verify the required parameter 'attachmentID' is set

        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'attachmentID',
                'getBankTransferAttachmentById'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getBankTransferAttachmentById'
            ));
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransferAttachments
     *
     * Allows you to retrieve Attachments from  bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments
     */
    public function getBankTransferAttachments($bankTransferID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBankTransferAttachmentsWithHttpInfo($bankTransferID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBankTransferAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachments from  bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransferAttachmentsWithHttpInfo($bankTransferID)
    {
        $request = $this->getBankTransferAttachmentsRequest($bankTransferID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBankTransferAttachments'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBankTransferAttachmentsRequest($bankTransferID)
    {
        // Verify the required parameter 'bankTransferID' is set

        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransferID',
                'getBankTransferAttachments'
            ));
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransferHistory
     *
     * Allows you to retrieve history from a bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getBankTransferHistory($bankTransferID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBankTransferHistoryWithHttpInfo($bankTransferID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBankTransferHistoryWithHttpInfo
     *
     * Allows you to retrieve history from a bank transfers
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransferHistoryWithHttpInfo($bankTransferID)
    {
        $request = $this->getBankTransferHistoryRequest($bankTransferID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBankTransferHistory'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBankTransferHistoryRequest($bankTransferID)
    {
        // Verify the required parameter 'bankTransferID' is set

        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransferID',
                'getBankTransferHistory'
            ));
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBankTransfers
     *
     * Allows you to retrieve all bank transfers
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\BankTransfers
     */
    public function getBankTransfers($ifModifiedSince = null, $where = null, $order = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBankTransfersWithHttpInfo($ifModifiedSince, $where, $order);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBankTransfersWithHttpInfo
     *
     * Allows you to retrieve all bank transfers
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\BankTransfers, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBankTransfersWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getBankTransfersRequest($ifModifiedSince, $where, $order);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\BankTransfers'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\BankTransfers';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBankTransfers'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBankTransfersRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/BankTransfers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBatchPaymentHistory
     *
     * Allows you to retrieve history from a Batch Payment
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getBatchPaymentHistory($batchPaymentID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBatchPaymentHistoryWithHttpInfo($batchPaymentID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBatchPaymentHistoryWithHttpInfo
     *
     * Allows you to retrieve history from a Batch Payment
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBatchPaymentHistoryWithHttpInfo($batchPaymentID)
    {
        $request = $this->getBatchPaymentHistoryRequest($batchPaymentID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBatchPaymentHistory'
     *
     * @param  string $batchPaymentID Unique identifier for BatchPayment (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBatchPaymentHistoryRequest($batchPaymentID)
    {
        // Verify the required parameter 'batchPaymentID' is set

        if ($batchPaymentID === null || (is_array($batchPaymentID) && count($batchPaymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'batchPaymentID',
                'getBatchPaymentHistory'
            ));
        }

        $resourcePath = '/BatchPayments/{BatchPaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($batchPaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'BatchPaymentID' . '}',
                ObjectSerializer::toPathValue($batchPaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBatchPayments
     *
     * Retrieve either one or many BatchPayments for invoices
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\BatchPayments
     */
    public function getBatchPayments($ifModifiedSince = null, $where = null, $order = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBatchPaymentsWithHttpInfo($ifModifiedSince, $where, $order);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBatchPaymentsWithHttpInfo
     *
     * Retrieve either one or many BatchPayments for invoices
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\BatchPayments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBatchPaymentsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getBatchPaymentsRequest($ifModifiedSince, $where, $order);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\BatchPayments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\BatchPayments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBatchPayments'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBatchPaymentsRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/BatchPayments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBrandingTheme
     *
     * Allows you to retrieve a specific BrandingThemes
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\BrandingThemes
     */
    public function getBrandingTheme($brandingThemeID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBrandingThemeWithHttpInfo($brandingThemeID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBrandingThemeWithHttpInfo
     *
     * Allows you to retrieve a specific BrandingThemes
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\BrandingThemes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandingThemeWithHttpInfo($brandingThemeID)
    {
        $request = $this->getBrandingThemeRequest($brandingThemeID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\BrandingThemes'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\BrandingThemes';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBrandingTheme'
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBrandingThemeRequest($brandingThemeID)
    {
        // Verify the required parameter 'brandingThemeID' is set

        if ($brandingThemeID === null || (is_array($brandingThemeID) && count($brandingThemeID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'brandingThemeID',
                'getBrandingTheme'
            ));
        }

        $resourcePath = '/BrandingThemes/{BrandingThemeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($brandingThemeID !== null) {
            $resourcePath = str_replace(
                '{' . 'BrandingThemeID' . '}',
                ObjectSerializer::toPathValue($brandingThemeID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBrandingThemePaymentServices
     *
     * Allows you to retrieve the Payment services for a Branding Theme
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\PaymentServices
     */
    public function getBrandingThemePaymentServices($brandingThemeID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBrandingThemePaymentServicesWithHttpInfo($brandingThemeID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBrandingThemePaymentServicesWithHttpInfo
     *
     * Allows you to retrieve the Payment services for a Branding Theme
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\PaymentServices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandingThemePaymentServicesWithHttpInfo($brandingThemeID)
    {
        $request = $this->getBrandingThemePaymentServicesRequest($brandingThemeID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\PaymentServices'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\PaymentServices';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBrandingThemePaymentServices'
     *
     * @param  string $brandingThemeID Unique identifier for a Branding Theme (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBrandingThemePaymentServicesRequest($brandingThemeID)
    {
        // Verify the required parameter 'brandingThemeID' is set

        if ($brandingThemeID === null || (is_array($brandingThemeID) && count($brandingThemeID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'brandingThemeID',
                'getBrandingThemePaymentServices'
            ));
        }

        $resourcePath = '/BrandingThemes/{BrandingThemeID}/PaymentServices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($brandingThemeID !== null) {
            $resourcePath = str_replace(
                '{' . 'BrandingThemeID' . '}',
                ObjectSerializer::toPathValue($brandingThemeID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getBrandingThemes
     *
     * Allows you to retrieve all the BrandingThemes
     *
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\BrandingThemes
     */
    public function getBrandingThemes()
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getBrandingThemesWithHttpInfo();

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getBrandingThemesWithHttpInfo
     *
     * Allows you to retrieve all the BrandingThemes
     *
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\BrandingThemes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandingThemesWithHttpInfo()
    {
        $request = $this->getBrandingThemesRequest();

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\BrandingThemes'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\BrandingThemes';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getBrandingThemes'
     *
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getBrandingThemesRequest()
    {

        $resourcePath = '/BrandingThemes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContact
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Contacts
     */
    public function getContact($contactID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getContactWithHttpInfo($contactID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getContactWithHttpInfo
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Contacts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactWithHttpInfo($contactID)
    {
        $request = $this->getContactRequest($contactID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Contacts'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Contacts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getContact'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getContactRequest($contactID)
    {
        // Verify the required parameter 'contactID' is set

        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactID',
                'getContact'
            ));
        }

        $resourcePath = '/Contacts/{ContactID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactAttachmentByFileName
     *
     * Allows you to retrieve Attachments on Contacts by file name
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getContactAttachmentByFileName($contactID, $fileName, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getContactAttachmentByFileNameWithHttpInfo($contactID, $fileName, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getContactAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachments on Contacts by file name
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAttachmentByFileNameWithHttpInfo($contactID, $fileName, $contentType)
    {
        $request = $this->getContactAttachmentByFileNameRequest($contactID, $fileName, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getContactAttachmentByFileName'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getContactAttachmentByFileNameRequest($contactID, $fileName, $contentType)
    {
        // Verify the required parameter 'contactID' is set

        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactID',
                'getContactAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'getContactAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getContactAttachmentByFileName'
            ));
        }

        $resourcePath = '/Contacts/{ContactID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactAttachmentById
     *
     * Allows you to retrieve Attachments on Contacts
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getContactAttachmentById($contactID, $attachmentID, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getContactAttachmentByIdWithHttpInfo($contactID, $attachmentID, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getContactAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve Attachments on Contacts
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAttachmentByIdWithHttpInfo($contactID, $attachmentID, $contentType)
    {
        $request = $this->getContactAttachmentByIdRequest($contactID, $attachmentID, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getContactAttachmentById'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getContactAttachmentByIdRequest($contactID, $attachmentID, $contentType)
    {
        // Verify the required parameter 'contactID' is set

        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactID',
                'getContactAttachmentById'
            ));
        }
        // Verify the required parameter 'attachmentID' is set

        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'attachmentID',
                'getContactAttachmentById'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getContactAttachmentById'
            ));
        }

        $resourcePath = '/Contacts/{ContactID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactAttachments
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments
     */
    public function getContactAttachments($contactID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getContactAttachmentsWithHttpInfo($contactID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getContactAttachmentsWithHttpInfo
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAttachmentsWithHttpInfo($contactID)
    {
        $request = $this->getContactAttachmentsRequest($contactID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getContactAttachments'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getContactAttachmentsRequest($contactID)
    {
        // Verify the required parameter 'contactID' is set

        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactID',
                'getContactAttachments'
            ));
        }

        $resourcePath = '/Contacts/{ContactID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactCISSettings
     *
     * Allows you to retrieve CISSettings for a contact in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\CISSettings
     */
    public function getContactCISSettings($contactID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getContactCISSettingsWithHttpInfo($contactID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getContactCISSettingsWithHttpInfo
     *
     * Allows you to retrieve CISSettings for a contact in a Xero organisation
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\CISSettings, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactCISSettingsWithHttpInfo($contactID)
    {
        $request = $this->getContactCISSettingsRequest($contactID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\CISSettings'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\CISSettings';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getContactCISSettings'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getContactCISSettingsRequest($contactID)
    {
        // Verify the required parameter 'contactID' is set

        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactID',
                'getContactCISSettings'
            ));
        }

        $resourcePath = '/Contacts/{ContactID}/CISSettings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactGroup
     *
     * Allows you to retrieve a unique Contract Group by ID
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ContactGroups
     */
    public function getContactGroup($contactGroupID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getContactGroupWithHttpInfo($contactGroupID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getContactGroupWithHttpInfo
     *
     * Allows you to retrieve a unique Contract Group by ID
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ContactGroups, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactGroupWithHttpInfo($contactGroupID)
    {
        $request = $this->getContactGroupRequest($contactGroupID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ContactGroups'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ContactGroups';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getContactGroup'
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getContactGroupRequest($contactGroupID)
    {
        // Verify the required parameter 'contactGroupID' is set

        if ($contactGroupID === null || (is_array($contactGroupID) && count($contactGroupID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactGroupID',
                'getContactGroup'
            ));
        }

        $resourcePath = '/ContactGroups/{ContactGroupID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactGroupID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactGroupID' . '}',
                ObjectSerializer::toPathValue($contactGroupID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactGroups
     *
     * Allows you to retrieve the ContactID and Name of all the contacts in a contact group
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ContactGroups
     */
    public function getContactGroups($where = null, $order = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getContactGroupsWithHttpInfo($where, $order);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getContactGroupsWithHttpInfo
     *
     * Allows you to retrieve the ContactID and Name of all the contacts in a contact group
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ContactGroups, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactGroupsWithHttpInfo($where = null, $order = null)
    {
        $request = $this->getContactGroupsRequest($where, $order);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ContactGroups'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ContactGroups';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getContactGroups'
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getContactGroupsRequest($where = null, $order = null)
    {

        $resourcePath = '/ContactGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContactHistory
     *
     * Allows you to retrieve a history records of an Contact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getContactHistory($contactID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getContactHistoryWithHttpInfo($contactID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getContactHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an Contact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactHistoryWithHttpInfo($contactID)
    {
        $request = $this->getContactHistoryRequest($contactID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getContactHistory'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getContactHistoryRequest($contactID)
    {
        // Verify the required parameter 'contactID' is set

        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactID',
                'getContactHistory'
            ));
        }

        $resourcePath = '/Contacts/{ContactID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getContacts
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call. (optional)
     * @param  int $page e.g. page&#x3D;1 - Up to 100 contacts will be returned in a single API call. (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Contacts
     */
    public function getContacts($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $page = null, $includeArchived = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getContactsWithHttpInfo($ifModifiedSince, $where, $order, $iDs, $page, $includeArchived);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getContactsWithHttpInfo
     *
     * Allows you to retrieve, add and update contacts in a Xero organisation
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call. (optional)
     * @param  int $page e.g. page&#x3D;1 - Up to 100 contacts will be returned in a single API call. (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Contacts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $page = null, $includeArchived = null)
    {
        $request = $this->getContactsRequest($ifModifiedSince, $where, $order, $iDs, $page, $includeArchived);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Contacts'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Contacts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getContacts'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call. (optional)
     * @param  int $page e.g. page&#x3D;1 - Up to 100 contacts will be returned in a single API call. (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getContactsRequest($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $page = null, $includeArchived = null)
    {

        $resourcePath = '/Contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($iDs !== null) {
            $queryParams['IDs'] = ObjectSerializer::toQueryValue($iDs);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($includeArchived !== null) {
            $queryParams['includeArchived'] = ObjectSerializer::toQueryValue($includeArchived);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNote
     *
     * Allows you to retrieve a specific credit note
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\CreditNotes
     */
    public function getCreditNote($creditNoteID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getCreditNoteWithHttpInfo($creditNoteID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getCreditNoteWithHttpInfo
     *
     * Allows you to retrieve a specific credit note
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\CreditNotes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNoteWithHttpInfo($creditNoteID)
    {
        $request = $this->getCreditNoteRequest($creditNoteID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\CreditNotes'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\CreditNotes';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getCreditNote'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getCreditNoteRequest($creditNoteID)
    {
        // Verify the required parameter 'creditNoteID' is set

        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'creditNoteID',
                'getCreditNote'
            ));
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNoteAsPdf
     *
     * Allows you to retrieve Credit Note as PDF files
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getCreditNoteAsPdf($creditNoteID, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getCreditNoteAsPdfWithHttpInfo($creditNoteID, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getCreditNoteAsPdfWithHttpInfo
     *
     * Allows you to retrieve Credit Note as PDF files
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNoteAsPdfWithHttpInfo($creditNoteID, $contentType)
    {
        $request = $this->getCreditNoteAsPdfRequest($creditNoteID, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getCreditNoteAsPdf'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getCreditNoteAsPdfRequest($creditNoteID, $contentType)
    {
        // Verify the required parameter 'creditNoteID' is set

        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'creditNoteID',
                'getCreditNoteAsPdf'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getCreditNoteAsPdf'
            ));
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNoteAttachmentByFileName
     *
     * Allows you to retrieve Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getCreditNoteAttachmentByFileName($creditNoteID, $fileName, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getCreditNoteAttachmentByFileNameWithHttpInfo($creditNoteID, $fileName, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getCreditNoteAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNoteAttachmentByFileNameWithHttpInfo($creditNoteID, $fileName, $contentType)
    {
        $request = $this->getCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getCreditNoteAttachmentByFileName'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $contentType)
    {
        // Verify the required parameter 'creditNoteID' is set

        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'creditNoteID',
                'getCreditNoteAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'getCreditNoteAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getCreditNoteAttachmentByFileName'
            ));
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNoteAttachmentById
     *
     * Allows you to retrieve Attachments on CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getCreditNoteAttachmentById($creditNoteID, $attachmentID, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getCreditNoteAttachmentByIdWithHttpInfo($creditNoteID, $attachmentID, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getCreditNoteAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve Attachments on CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNoteAttachmentByIdWithHttpInfo($creditNoteID, $attachmentID, $contentType)
    {
        $request = $this->getCreditNoteAttachmentByIdRequest($creditNoteID, $attachmentID, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getCreditNoteAttachmentById'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getCreditNoteAttachmentByIdRequest($creditNoteID, $attachmentID, $contentType)
    {
        // Verify the required parameter 'creditNoteID' is set

        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'creditNoteID',
                'getCreditNoteAttachmentById'
            ));
        }
        // Verify the required parameter 'attachmentID' is set

        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'attachmentID',
                'getCreditNoteAttachmentById'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getCreditNoteAttachmentById'
            ));
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNoteAttachments
     *
     * Allows you to retrieve Attachments for credit notes
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments
     */
    public function getCreditNoteAttachments($creditNoteID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getCreditNoteAttachmentsWithHttpInfo($creditNoteID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getCreditNoteAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachments for credit notes
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNoteAttachmentsWithHttpInfo($creditNoteID)
    {
        $request = $this->getCreditNoteAttachmentsRequest($creditNoteID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getCreditNoteAttachments'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getCreditNoteAttachmentsRequest($creditNoteID)
    {
        // Verify the required parameter 'creditNoteID' is set

        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'creditNoteID',
                'getCreditNoteAttachments'
            ));
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNoteHistory
     *
     * Allows you to retrieve a history records of an CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getCreditNoteHistory($creditNoteID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getCreditNoteHistoryWithHttpInfo($creditNoteID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getCreditNoteHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an CreditNote
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNoteHistoryWithHttpInfo($creditNoteID)
    {
        $request = $this->getCreditNoteHistoryRequest($creditNoteID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getCreditNoteHistory'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getCreditNoteHistoryRequest($creditNoteID)
    {
        // Verify the required parameter 'creditNoteID' is set

        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'creditNoteID',
                'getCreditNoteHistory'
            ));
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCreditNotes
     *
     * Allows you to retrieve any credit notes
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 credit notes will be returned in a single API call with line items shown for each credit note (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\CreditNotes
     */
    public function getCreditNotes($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getCreditNotesWithHttpInfo($ifModifiedSince, $where, $order, $page);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getCreditNotesWithHttpInfo
     *
     * Allows you to retrieve any credit notes
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 credit notes will be returned in a single API call with line items shown for each credit note (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\CreditNotes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNotesWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {
        $request = $this->getCreditNotesRequest($ifModifiedSince, $where, $order, $page);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\CreditNotes'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\CreditNotes';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getCreditNotes'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 credit notes will be returned in a single API call with line items shown for each credit note (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getCreditNotesRequest($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {

        $resourcePath = '/CreditNotes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getCurrencies
     *
     * Allows you to retrieve currencies for your organisation
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Currencies
     */
    public function getCurrencies($where = null, $order = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getCurrenciesWithHttpInfo($where, $order);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getCurrenciesWithHttpInfo
     *
     * Allows you to retrieve currencies for your organisation
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Currencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrenciesWithHttpInfo($where = null, $order = null)
    {
        $request = $this->getCurrenciesRequest($where, $order);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Currencies'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Currencies';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getCurrencies'
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getCurrenciesRequest($where = null, $order = null)
    {

        $resourcePath = '/Currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getEmployee
     *
     * Allows you to retrieve a specific employee used in Xero payrun
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Employees
     */
    public function getEmployee($employeeID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getEmployeeWithHttpInfo($employeeID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getEmployeeWithHttpInfo
     *
     * Allows you to retrieve a specific employee used in Xero payrun
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Employees, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmployeeWithHttpInfo($employeeID)
    {
        $request = $this->getEmployeeRequest($employeeID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Employees'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Employees';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getEmployee'
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getEmployeeRequest($employeeID)
    {
        // Verify the required parameter 'employeeID' is set

        if ($employeeID === null || (is_array($employeeID) && count($employeeID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'employeeID',
                'getEmployee'
            ));
        }

        $resourcePath = '/Employees/{EmployeeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($employeeID !== null) {
            $resourcePath = str_replace(
                '{' . 'EmployeeID' . '}',
                ObjectSerializer::toPathValue($employeeID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getEmployees
     *
     * Allows you to retrieve employees used in Xero payrun
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Employees
     */
    public function getEmployees($ifModifiedSince = null, $where = null, $order = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getEmployeesWithHttpInfo($ifModifiedSince, $where, $order);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getEmployeesWithHttpInfo
     *
     * Allows you to retrieve employees used in Xero payrun
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Employees, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmployeesWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getEmployeesRequest($ifModifiedSince, $where, $order);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Employees'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Employees';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getEmployees'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getEmployeesRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/Employees';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getExpenseClaim
     *
     * Allows you to retrieve a specified expense claim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ExpenseClaims
     */
    public function getExpenseClaim($expenseClaimID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getExpenseClaimWithHttpInfo($expenseClaimID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getExpenseClaimWithHttpInfo
     *
     * Allows you to retrieve a specified expense claim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ExpenseClaims, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExpenseClaimWithHttpInfo($expenseClaimID)
    {
        $request = $this->getExpenseClaimRequest($expenseClaimID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ExpenseClaims'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ExpenseClaims';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getExpenseClaim'
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getExpenseClaimRequest($expenseClaimID)
    {
        // Verify the required parameter 'expenseClaimID' is set

        if ($expenseClaimID === null || (is_array($expenseClaimID) && count($expenseClaimID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'expenseClaimID',
                'getExpenseClaim'
            ));
        }

        $resourcePath = '/ExpenseClaims/{ExpenseClaimID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($expenseClaimID !== null) {
            $resourcePath = str_replace(
                '{' . 'ExpenseClaimID' . '}',
                ObjectSerializer::toPathValue($expenseClaimID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getExpenseClaimHistory
     *
     * Allows you to retrieve a history records of an ExpenseClaim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getExpenseClaimHistory($expenseClaimID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getExpenseClaimHistoryWithHttpInfo($expenseClaimID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getExpenseClaimHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an ExpenseClaim
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExpenseClaimHistoryWithHttpInfo($expenseClaimID)
    {
        $request = $this->getExpenseClaimHistoryRequest($expenseClaimID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getExpenseClaimHistory'
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getExpenseClaimHistoryRequest($expenseClaimID)
    {
        // Verify the required parameter 'expenseClaimID' is set

        if ($expenseClaimID === null || (is_array($expenseClaimID) && count($expenseClaimID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'expenseClaimID',
                'getExpenseClaimHistory'
            ));
        }

        $resourcePath = '/ExpenseClaims/{ExpenseClaimID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($expenseClaimID !== null) {
            $resourcePath = str_replace(
                '{' . 'ExpenseClaimID' . '}',
                ObjectSerializer::toPathValue($expenseClaimID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getExpenseClaims
     *
     * Allows you to retrieve expense claims
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ExpenseClaims
     */
    public function getExpenseClaims($ifModifiedSince = null, $where = null, $order = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getExpenseClaimsWithHttpInfo($ifModifiedSince, $where, $order);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getExpenseClaimsWithHttpInfo
     *
     * Allows you to retrieve expense claims
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ExpenseClaims, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExpenseClaimsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getExpenseClaimsRequest($ifModifiedSince, $where, $order);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ExpenseClaims'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ExpenseClaims';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getExpenseClaims'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getExpenseClaimsRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/ExpenseClaims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoice
     *
     * Allows you to retrieve a specified sales invoice or purchase bill
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Invoices
     */
    public function getInvoice($invoiceID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getInvoiceWithHttpInfo($invoiceID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getInvoiceWithHttpInfo
     *
     * Allows you to retrieve a specified sales invoice or purchase bill
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Invoices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceWithHttpInfo($invoiceID)
    {
        $request = $this->getInvoiceRequest($invoiceID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Invoices'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Invoices';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getInvoice'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getInvoiceRequest($invoiceID)
    {
        // Verify the required parameter 'invoiceID' is set

        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoiceID',
                'getInvoice'
            ));
        }

        $resourcePath = '/Invoices/{InvoiceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoiceAsPdf
     *
     * Allows you to retrieve invoices or purchase bills as PDF files
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getInvoiceAsPdf($invoiceID, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getInvoiceAsPdfWithHttpInfo($invoiceID, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getInvoiceAsPdfWithHttpInfo
     *
     * Allows you to retrieve invoices or purchase bills as PDF files
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceAsPdfWithHttpInfo($invoiceID, $contentType)
    {
        $request = $this->getInvoiceAsPdfRequest($invoiceID, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getInvoiceAsPdf'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getInvoiceAsPdfRequest($invoiceID, $contentType)
    {
        // Verify the required parameter 'invoiceID' is set

        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoiceID',
                'getInvoiceAsPdf'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getInvoiceAsPdf'
            ));
        }

        $resourcePath = '/Invoices/{InvoiceID}/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoiceAttachmentByFileName
     *
     * Allows you to retrieve Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getInvoiceAttachmentByFileName($invoiceID, $fileName, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getInvoiceAttachmentByFileNameWithHttpInfo($invoiceID, $fileName, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getInvoiceAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceAttachmentByFileNameWithHttpInfo($invoiceID, $fileName, $contentType)
    {
        $request = $this->getInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getInvoiceAttachmentByFileName'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $contentType)
    {
        // Verify the required parameter 'invoiceID' is set

        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoiceID',
                'getInvoiceAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'getInvoiceAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getInvoiceAttachmentByFileName'
            ));
        }

        $resourcePath = '/Invoices/{InvoiceID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoiceAttachmentById
     *
     * Allows you to retrieve a specified Attachment on invoices or purchase bills by it's ID
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $attachmentID Unique identifier for an Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getInvoiceAttachmentById($invoiceID, $attachmentID, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getInvoiceAttachmentByIdWithHttpInfo($invoiceID, $attachmentID, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getInvoiceAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve a specified Attachment on invoices or purchase bills by it's ID
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $attachmentID Unique identifier for an Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceAttachmentByIdWithHttpInfo($invoiceID, $attachmentID, $contentType)
    {
        $request = $this->getInvoiceAttachmentByIdRequest($invoiceID, $attachmentID, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getInvoiceAttachmentById'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $attachmentID Unique identifier for an Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getInvoiceAttachmentByIdRequest($invoiceID, $attachmentID, $contentType)
    {
        // Verify the required parameter 'invoiceID' is set

        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoiceID',
                'getInvoiceAttachmentById'
            ));
        }
        // Verify the required parameter 'attachmentID' is set

        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'attachmentID',
                'getInvoiceAttachmentById'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getInvoiceAttachmentById'
            ));
        }

        $resourcePath = '/Invoices/{InvoiceID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoiceAttachments
     *
     * Allows you to retrieve Attachments on invoices or purchase bills
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments
     */
    public function getInvoiceAttachments($invoiceID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getInvoiceAttachmentsWithHttpInfo($invoiceID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getInvoiceAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachments on invoices or purchase bills
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceAttachmentsWithHttpInfo($invoiceID)
    {
        $request = $this->getInvoiceAttachmentsRequest($invoiceID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getInvoiceAttachments'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getInvoiceAttachmentsRequest($invoiceID)
    {
        // Verify the required parameter 'invoiceID' is set

        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoiceID',
                'getInvoiceAttachments'
            ));
        }

        $resourcePath = '/Invoices/{InvoiceID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoiceHistory
     *
     * Allows you to retrieve a history records of an invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getInvoiceHistory($invoiceID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getInvoiceHistoryWithHttpInfo($invoiceID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getInvoiceHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceHistoryWithHttpInfo($invoiceID)
    {
        $request = $this->getInvoiceHistoryRequest($invoiceID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getInvoiceHistory'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getInvoiceHistoryRequest($invoiceID)
    {
        // Verify the required parameter 'invoiceID' is set

        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoiceID',
                'getInvoiceHistory'
            ));
        }

        $resourcePath = '/Invoices/{InvoiceID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoiceReminders
     *
     * Allows you to retrieve invoice reminder settings
     *
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\InvoiceReminders
     */
    public function getInvoiceReminders()
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getInvoiceRemindersWithHttpInfo();

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getInvoiceRemindersWithHttpInfo
     *
     * Allows you to retrieve invoice reminder settings
     *
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\InvoiceReminders, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceRemindersWithHttpInfo()
    {
        $request = $this->getInvoiceRemindersRequest();

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\InvoiceReminders'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\InvoiceReminders';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getInvoiceReminders'
     *
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getInvoiceRemindersRequest()
    {

        $resourcePath = '/InvoiceReminders/Settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getInvoices
     *
     * Allows you to retrieve any sales invoices or purchase bills
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma-separated list of InvoicesIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $invoiceNumbers Filter by a comma-separated list of InvoiceNumbers. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $contactIDs Filter by a comma-separated list of ContactIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $statuses Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 invoices will be returned in a single API call with line items shown for each invoice (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     * @param  bool $createdByMyApp When set to true you&#39;ll only retrieve Invoices created by your app (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Invoices
     */
    public function getInvoices($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $invoiceNumbers = null, $contactIDs = null, $statuses = null, $page = null, $includeArchived = null, $createdByMyApp = null, $unitdp = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getInvoicesWithHttpInfo($ifModifiedSince, $where, $order, $iDs, $invoiceNumbers, $contactIDs, $statuses, $page, $includeArchived, $createdByMyApp, $unitdp);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getInvoicesWithHttpInfo
     *
     * Allows you to retrieve any sales invoices or purchase bills
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma-separated list of InvoicesIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $invoiceNumbers Filter by a comma-separated list of InvoiceNumbers. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $contactIDs Filter by a comma-separated list of ContactIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $statuses Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 invoices will be returned in a single API call with line items shown for each invoice (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     * @param  bool $createdByMyApp When set to true you&#39;ll only retrieve Invoices created by your app (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Invoices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoicesWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $invoiceNumbers = null, $contactIDs = null, $statuses = null, $page = null, $includeArchived = null, $createdByMyApp = null, $unitdp = null)
    {
        $request = $this->getInvoicesRequest($ifModifiedSince, $where, $order, $iDs, $invoiceNumbers, $contactIDs, $statuses, $page, $includeArchived, $createdByMyApp, $unitdp);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Invoices'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Invoices';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getInvoices'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $iDs Filter by a comma-separated list of InvoicesIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $invoiceNumbers Filter by a comma-separated list of InvoiceNumbers. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $contactIDs Filter by a comma-separated list of ContactIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  string $statuses Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter. (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 invoices will be returned in a single API call with line items shown for each invoice (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response (optional)
     * @param  bool $createdByMyApp When set to true you&#39;ll only retrieve Invoices created by your app (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getInvoicesRequest($ifModifiedSince = null, $where = null, $order = null, $iDs = null, $invoiceNumbers = null, $contactIDs = null, $statuses = null, $page = null, $includeArchived = null, $createdByMyApp = null, $unitdp = null)
    {

        $resourcePath = '/Invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($iDs !== null) {
            $queryParams['IDs'] = ObjectSerializer::toQueryValue($iDs);
        }
        // query params
        if ($invoiceNumbers !== null) {
            $queryParams['InvoiceNumbers'] = ObjectSerializer::toQueryValue($invoiceNumbers);
        }
        // query params
        if ($contactIDs !== null) {
            $queryParams['ContactIDs'] = ObjectSerializer::toQueryValue($contactIDs);
        }
        // query params
        if ($statuses !== null) {
            $queryParams['Statuses'] = ObjectSerializer::toQueryValue($statuses);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($includeArchived !== null) {
            $queryParams['includeArchived'] = ObjectSerializer::toQueryValue($includeArchived);
        }
        // query params
        if ($createdByMyApp !== null) {
            $queryParams['createdByMyApp'] = ObjectSerializer::toQueryValue($createdByMyApp);
        }
        // query params
        if ($unitdp !== null) {
            $queryParams['unitdp'] = ObjectSerializer::toQueryValue($unitdp);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getItem
     *
     * Allows you to retrieve a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Items
     */
    public function getItem($itemID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getItemWithHttpInfo($itemID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getItemWithHttpInfo
     *
     * Allows you to retrieve a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Items, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemWithHttpInfo($itemID)
    {
        $request = $this->getItemRequest($itemID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Items'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Items';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getItem'
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getItemRequest($itemID)
    {
        // Verify the required parameter 'itemID' is set

        if ($itemID === null || (is_array($itemID) && count($itemID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'itemID',
                'getItem'
            ));
        }

        $resourcePath = '/Items/{ItemID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($itemID !== null) {
            $resourcePath = str_replace(
                '{' . 'ItemID' . '}',
                ObjectSerializer::toPathValue($itemID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getItemHistory
     *
     * Allows you to retrieve history for items
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getItemHistory($itemID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getItemHistoryWithHttpInfo($itemID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getItemHistoryWithHttpInfo
     *
     * Allows you to retrieve history for items
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemHistoryWithHttpInfo($itemID)
    {
        $request = $this->getItemHistoryRequest($itemID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getItemHistory'
     *
     * @param  string $itemID Unique identifier for an Item (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getItemHistoryRequest($itemID)
    {
        // Verify the required parameter 'itemID' is set

        if ($itemID === null || (is_array($itemID) && count($itemID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'itemID',
                'getItemHistory'
            ));
        }

        $resourcePath = '/Items/{ItemID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($itemID !== null) {
            $resourcePath = str_replace(
                '{' . 'ItemID' . '}',
                ObjectSerializer::toPathValue($itemID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getItems
     *
     * Allows you to retrieve any items
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Items
     */
    public function getItems($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getItemsWithHttpInfo($ifModifiedSince, $where, $order, $unitdp);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getItemsWithHttpInfo
     *
     * Allows you to retrieve any items
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Items, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {
        $request = $this->getItemsRequest($ifModifiedSince, $where, $order, $unitdp);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Items'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Items';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getItems'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getItemsRequest($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {

        $resourcePath = '/Items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($unitdp !== null) {
            $queryParams['unitdp'] = ObjectSerializer::toQueryValue($unitdp);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getJournal
     *
     * Allows you to retrieve a specified journals.
     *
     * @param  string $journalID Unique identifier for a Journal (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Journals
     */
    public function getJournal($journalID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getJournalWithHttpInfo($journalID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getJournalWithHttpInfo
     *
     * Allows you to retrieve a specified journals.
     *
     * @param  string $journalID Unique identifier for a Journal (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Journals, HTTP status code, HTTP response headers (array of strings)
     */
    public function getJournalWithHttpInfo($journalID)
    {
        $request = $this->getJournalRequest($journalID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Journals'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Journals';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getJournal'
     *
     * @param  string $journalID Unique identifier for a Journal (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getJournalRequest($journalID)
    {
        // Verify the required parameter 'journalID' is set

        if ($journalID === null || (is_array($journalID) && count($journalID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'journalID',
                'getJournal'
            ));
        }

        $resourcePath = '/Journals/{JournalID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($journalID !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalID' . '}',
                ObjectSerializer::toPathValue($journalID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getJournals
     *
     * Allows you to retrieve any journals.
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  int $offset Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned (optional)
     * @param  bool $paymentsOnly Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default. (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Journals
     */
    public function getJournals($ifModifiedSince = null, $offset = null, $paymentsOnly = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getJournalsWithHttpInfo($ifModifiedSince, $offset, $paymentsOnly);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getJournalsWithHttpInfo
     *
     * Allows you to retrieve any journals.
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  int $offset Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned (optional)
     * @param  bool $paymentsOnly Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default. (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Journals, HTTP status code, HTTP response headers (array of strings)
     */
    public function getJournalsWithHttpInfo($ifModifiedSince = null, $offset = null, $paymentsOnly = null)
    {
        $request = $this->getJournalsRequest($ifModifiedSince, $offset, $paymentsOnly);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Journals'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Journals';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getJournals'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  int $offset Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned (optional)
     * @param  bool $paymentsOnly Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default. (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getJournalsRequest($ifModifiedSince = null, $offset = null, $paymentsOnly = null)
    {

        $resourcePath = '/Journals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($paymentsOnly !== null) {
            $queryParams['paymentsOnly'] = ObjectSerializer::toQueryValue($paymentsOnly);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getLinkedTransaction
     *
     * Allows you to retrieve a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\LinkedTransactions
     */
    public function getLinkedTransaction($linkedTransactionID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getLinkedTransactionWithHttpInfo($linkedTransactionID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getLinkedTransactionWithHttpInfo
     *
     * Allows you to retrieve a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\LinkedTransactions, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLinkedTransactionWithHttpInfo($linkedTransactionID)
    {
        $request = $this->getLinkedTransactionRequest($linkedTransactionID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\LinkedTransactions'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\LinkedTransactions';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getLinkedTransaction'
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getLinkedTransactionRequest($linkedTransactionID)
    {
        // Verify the required parameter 'linkedTransactionID' is set

        if ($linkedTransactionID === null || (is_array($linkedTransactionID) && count($linkedTransactionID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'linkedTransactionID',
                'getLinkedTransaction'
            ));
        }

        $resourcePath = '/LinkedTransactions/{LinkedTransactionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($linkedTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'LinkedTransactionID' . '}',
                ObjectSerializer::toPathValue($linkedTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getLinkedTransactions
     *
     * Retrieve linked transactions (billable expenses)
     *
     * @param  int $page Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page&#x3D;1. (optional)
     * @param  string $linkedTransactionID The Xero identifier for an Linked Transaction (optional)
     * @param  string $sourceTransactionID Filter by the SourceTransactionID. Get all the linked transactions created from a particular ACCPAY invoice (optional)
     * @param  string $contactID Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer. (optional)
     * @param  string $status Filter by the combination of ContactID and Status. Get all the linked transactions that have been assigned to a particular customer and have a particular status e.g. GET /LinkedTransactions?ContactID&#x3D;4bb34b03-3378-4bb2-a0ed-6345abf3224e&amp;Status&#x3D;APPROVED. (optional)
     * @param  string $targetTransactionID Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\LinkedTransactions
     */
    public function getLinkedTransactions($page = null, $linkedTransactionID = null, $sourceTransactionID = null, $contactID = null, $status = null, $targetTransactionID = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getLinkedTransactionsWithHttpInfo($page, $linkedTransactionID, $sourceTransactionID, $contactID, $status, $targetTransactionID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getLinkedTransactionsWithHttpInfo
     *
     * Retrieve linked transactions (billable expenses)
     *
     * @param  int $page Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page&#x3D;1. (optional)
     * @param  string $linkedTransactionID The Xero identifier for an Linked Transaction (optional)
     * @param  string $sourceTransactionID Filter by the SourceTransactionID. Get all the linked transactions created from a particular ACCPAY invoice (optional)
     * @param  string $contactID Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer. (optional)
     * @param  string $status Filter by the combination of ContactID and Status. Get all the linked transactions that have been assigned to a particular customer and have a particular status e.g. GET /LinkedTransactions?ContactID&#x3D;4bb34b03-3378-4bb2-a0ed-6345abf3224e&amp;Status&#x3D;APPROVED. (optional)
     * @param  string $targetTransactionID Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\LinkedTransactions, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLinkedTransactionsWithHttpInfo($page = null, $linkedTransactionID = null, $sourceTransactionID = null, $contactID = null, $status = null, $targetTransactionID = null)
    {
        $request = $this->getLinkedTransactionsRequest($page, $linkedTransactionID, $sourceTransactionID, $contactID, $status, $targetTransactionID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\LinkedTransactions'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\LinkedTransactions';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getLinkedTransactions'
     *
     * @param  int $page Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page&#x3D;1. (optional)
     * @param  string $linkedTransactionID The Xero identifier for an Linked Transaction (optional)
     * @param  string $sourceTransactionID Filter by the SourceTransactionID. Get all the linked transactions created from a particular ACCPAY invoice (optional)
     * @param  string $contactID Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer. (optional)
     * @param  string $status Filter by the combination of ContactID and Status. Get all the linked transactions that have been assigned to a particular customer and have a particular status e.g. GET /LinkedTransactions?ContactID&#x3D;4bb34b03-3378-4bb2-a0ed-6345abf3224e&amp;Status&#x3D;APPROVED. (optional)
     * @param  string $targetTransactionID Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getLinkedTransactionsRequest($page = null, $linkedTransactionID = null, $sourceTransactionID = null, $contactID = null, $status = null, $targetTransactionID = null)
    {

        $resourcePath = '/LinkedTransactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($linkedTransactionID !== null) {
            $queryParams['LinkedTransactionID'] = ObjectSerializer::toQueryValue($linkedTransactionID);
        }
        // query params
        if ($sourceTransactionID !== null) {
            $queryParams['SourceTransactionID'] = ObjectSerializer::toQueryValue($sourceTransactionID);
        }
        // query params
        if ($contactID !== null) {
            $queryParams['ContactID'] = ObjectSerializer::toQueryValue($contactID);
        }
        // query params
        if ($status !== null) {
            $queryParams['Status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($targetTransactionID !== null) {
            $queryParams['TargetTransactionID'] = ObjectSerializer::toQueryValue($targetTransactionID);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getManualJournal
     *
     * Allows you to retrieve a specified manual journals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ManualJournals
     */
    public function getManualJournal($manualJournalID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getManualJournalWithHttpInfo($manualJournalID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getManualJournalWithHttpInfo
     *
     * Allows you to retrieve a specified manual journals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ManualJournals, HTTP status code, HTTP response headers (array of strings)
     */
    public function getManualJournalWithHttpInfo($manualJournalID)
    {
        $request = $this->getManualJournalRequest($manualJournalID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ManualJournals'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ManualJournals';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getManualJournal'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getManualJournalRequest($manualJournalID)
    {
        // Verify the required parameter 'manualJournalID' is set

        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'manualJournalID',
                'getManualJournal'
            ));
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getManualJournalAttachmentByFileName
     *
     * Allows you to retrieve specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getManualJournalAttachmentByFileName($manualJournalID, $fileName, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getManualJournalAttachmentByFileNameWithHttpInfo($manualJournalID, $fileName, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getManualJournalAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getManualJournalAttachmentByFileNameWithHttpInfo($manualJournalID, $fileName, $contentType)
    {
        $request = $this->getManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getManualJournalAttachmentByFileName'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $contentType)
    {
        // Verify the required parameter 'manualJournalID' is set

        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'manualJournalID',
                'getManualJournalAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'getManualJournalAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getManualJournalAttachmentByFileName'
            ));
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getManualJournalAttachmentById
     *
     * Allows you to retrieve specified Attachment on ManualJournals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getManualJournalAttachmentById($manualJournalID, $attachmentID, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getManualJournalAttachmentByIdWithHttpInfo($manualJournalID, $attachmentID, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getManualJournalAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve specified Attachment on ManualJournals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getManualJournalAttachmentByIdWithHttpInfo($manualJournalID, $attachmentID, $contentType)
    {
        $request = $this->getManualJournalAttachmentByIdRequest($manualJournalID, $attachmentID, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getManualJournalAttachmentById'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getManualJournalAttachmentByIdRequest($manualJournalID, $attachmentID, $contentType)
    {
        // Verify the required parameter 'manualJournalID' is set

        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'manualJournalID',
                'getManualJournalAttachmentById'
            ));
        }
        // Verify the required parameter 'attachmentID' is set

        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'attachmentID',
                'getManualJournalAttachmentById'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getManualJournalAttachmentById'
            ));
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getManualJournalAttachments
     *
     * Allows you to retrieve Attachment for manual journals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments
     */
    public function getManualJournalAttachments($manualJournalID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getManualJournalAttachmentsWithHttpInfo($manualJournalID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getManualJournalAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachment for manual journals
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getManualJournalAttachmentsWithHttpInfo($manualJournalID)
    {
        $request = $this->getManualJournalAttachmentsRequest($manualJournalID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getManualJournalAttachments'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getManualJournalAttachmentsRequest($manualJournalID)
    {
        // Verify the required parameter 'manualJournalID' is set

        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'manualJournalID',
                'getManualJournalAttachments'
            ));
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getManualJournals
     *
     * Allows you to retrieve any manual journals
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ManualJournals
     */
    public function getManualJournals($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getManualJournalsWithHttpInfo($ifModifiedSince, $where, $order, $page);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getManualJournalsWithHttpInfo
     *
     * Allows you to retrieve any manual journals
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ManualJournals, HTTP status code, HTTP response headers (array of strings)
     */
    public function getManualJournalsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {
        $request = $this->getManualJournalsRequest($ifModifiedSince, $where, $order, $page);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ManualJournals'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ManualJournals';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getManualJournals'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getManualJournalsRequest($ifModifiedSince = null, $where = null, $order = null, $page = null)
    {

        $resourcePath = '/ManualJournals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getOnlineInvoice
     *
     * Allows you to retrieve a URL to an online invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\OnlineInvoices
     */
    public function getOnlineInvoice($invoiceID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getOnlineInvoiceWithHttpInfo($invoiceID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getOnlineInvoiceWithHttpInfo
     *
     * Allows you to retrieve a URL to an online invoice
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\OnlineInvoices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOnlineInvoiceWithHttpInfo($invoiceID)
    {
        $request = $this->getOnlineInvoiceRequest($invoiceID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\OnlineInvoices'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\OnlineInvoices';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getOnlineInvoice'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getOnlineInvoiceRequest($invoiceID)
    {
        // Verify the required parameter 'invoiceID' is set

        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoiceID',
                'getOnlineInvoice'
            ));
        }

        $resourcePath = '/Invoices/{InvoiceID}/OnlineInvoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getOrganisationCISSettings
     *
     * Allows you To verify if an organisation is using contruction industry scheme, you can retrieve the CIS settings for the organistaion.
     *
     * @param  string $organisationID organisationID (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\CISOrgSetting
     */
    public function getOrganisationCISSettings($organisationID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getOrganisationCISSettingsWithHttpInfo($organisationID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getOrganisationCISSettingsWithHttpInfo
     *
     * Allows you To verify if an organisation is using contruction industry scheme, you can retrieve the CIS settings for the organistaion.
     *
     * @param  string $organisationID (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\CISOrgSetting, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganisationCISSettingsWithHttpInfo($organisationID)
    {
        $request = $this->getOrganisationCISSettingsRequest($organisationID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\CISOrgSetting'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\CISOrgSetting';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getOrganisationCISSettings'
     *
     * @param  string $organisationID (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getOrganisationCISSettingsRequest($organisationID)
    {
        // Verify the required parameter 'organisationID' is set

        if ($organisationID === null || (is_array($organisationID) && count($organisationID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'organisationID',
                'getOrganisationCISSettings'
            ));
        }

        $resourcePath = '/Organisation/{OrganisationID}/CISSettings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($organisationID !== null) {
            $resourcePath = str_replace(
                '{' . 'OrganisationID' . '}',
                ObjectSerializer::toPathValue($organisationID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getOrganisations
     *
     * Allows you to retrieve Organisation details
     *
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Organisations
     */
    public function getOrganisations()
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getOrganisationsWithHttpInfo();

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getOrganisationsWithHttpInfo
     *
     * Allows you to retrieve Organisation details
     *
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Organisations, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganisationsWithHttpInfo()
    {
        $request = $this->getOrganisationsRequest();

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Organisations'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Organisations';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getOrganisations'
     *
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getOrganisationsRequest()
    {

        $resourcePath = '/Organisation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getOverpayment
     *
     * Allows you to retrieve a specified overpayments
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Overpayments
     */
    public function getOverpayment($overpaymentID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getOverpaymentWithHttpInfo($overpaymentID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getOverpaymentWithHttpInfo
     *
     * Allows you to retrieve a specified overpayments
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Overpayments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOverpaymentWithHttpInfo($overpaymentID)
    {
        $request = $this->getOverpaymentRequest($overpaymentID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Overpayments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Overpayments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getOverpayment'
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getOverpaymentRequest($overpaymentID)
    {
        // Verify the required parameter 'overpaymentID' is set

        if ($overpaymentID === null || (is_array($overpaymentID) && count($overpaymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'overpaymentID',
                'getOverpayment'
            ));
        }

        $resourcePath = '/Overpayments/{OverpaymentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($overpaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'OverpaymentID' . '}',
                ObjectSerializer::toPathValue($overpaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getOverpaymentHistory
     *
     * Allows you to retrieve a history records of an Overpayment
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getOverpaymentHistory($overpaymentID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getOverpaymentHistoryWithHttpInfo($overpaymentID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getOverpaymentHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an Overpayment
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOverpaymentHistoryWithHttpInfo($overpaymentID)
    {
        $request = $this->getOverpaymentHistoryRequest($overpaymentID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getOverpaymentHistory'
     *
     * @param  string $overpaymentID Unique identifier for a Overpayment (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getOverpaymentHistoryRequest($overpaymentID)
    {
        // Verify the required parameter 'overpaymentID' is set

        if ($overpaymentID === null || (is_array($overpaymentID) && count($overpaymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'overpaymentID',
                'getOverpaymentHistory'
            ));
        }

        $resourcePath = '/Overpayments/{OverpaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($overpaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'OverpaymentID' . '}',
                ObjectSerializer::toPathValue($overpaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getOverpayments
     *
     * Allows you to retrieve overpayments
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Overpayments
     */
    public function getOverpayments($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getOverpaymentsWithHttpInfo($ifModifiedSince, $where, $order, $page, $unitdp);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getOverpaymentsWithHttpInfo
     *
     * Allows you to retrieve overpayments
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Overpayments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOverpaymentsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        $request = $this->getOverpaymentsRequest($ifModifiedSince, $where, $order, $page, $unitdp);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Overpayments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Overpayments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getOverpayments'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getOverpaymentsRequest($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {

        $resourcePath = '/Overpayments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($unitdp !== null) {
            $queryParams['unitdp'] = ObjectSerializer::toQueryValue($unitdp);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPayment
     *
     * Allows you to retrieve a specified payment for invoices and credit notes
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Payments
     */
    public function getPayment($paymentID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getPaymentWithHttpInfo($paymentID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getPaymentWithHttpInfo
     *
     * Allows you to retrieve a specified payment for invoices and credit notes
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Payments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentWithHttpInfo($paymentID)
    {
        $request = $this->getPaymentRequest($paymentID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Payments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Payments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getPayment'
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getPaymentRequest($paymentID)
    {
        // Verify the required parameter 'paymentID' is set

        if ($paymentID === null || (is_array($paymentID) && count($paymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'paymentID',
                'getPayment'
            ));
        }

        $resourcePath = '/Payments/{PaymentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($paymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PaymentID' . '}',
                ObjectSerializer::toPathValue($paymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPaymentHistory
     *
     * Allows you to retrieve history records of a payment
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getPaymentHistory($paymentID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getPaymentHistoryWithHttpInfo($paymentID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getPaymentHistoryWithHttpInfo
     *
     * Allows you to retrieve history records of a payment
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentHistoryWithHttpInfo($paymentID)
    {
        $request = $this->getPaymentHistoryRequest($paymentID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getPaymentHistory'
     *
     * @param  string $paymentID Unique identifier for a Payment (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getPaymentHistoryRequest($paymentID)
    {
        // Verify the required parameter 'paymentID' is set

        if ($paymentID === null || (is_array($paymentID) && count($paymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'paymentID',
                'getPaymentHistory'
            ));
        }

        $resourcePath = '/Payments/{PaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($paymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PaymentID' . '}',
                ObjectSerializer::toPathValue($paymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPaymentServices
     *
     * Allows you to retrieve payment services
     *
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\PaymentServices
     */
    public function getPaymentServices()
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getPaymentServicesWithHttpInfo();

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getPaymentServicesWithHttpInfo
     *
     * Allows you to retrieve payment services
     *
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\PaymentServices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentServicesWithHttpInfo()
    {
        $request = $this->getPaymentServicesRequest();

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\PaymentServices'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\PaymentServices';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getPaymentServices'
     *
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getPaymentServicesRequest()
    {

        $resourcePath = '/PaymentServices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPayments
     *
     * Allows you to retrieve payments for invoices and credit notes
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Payments
     */
    public function getPayments($ifModifiedSince = null, $where = null, $order = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getPaymentsWithHttpInfo($ifModifiedSince, $where, $order);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getPaymentsWithHttpInfo
     *
     * Allows you to retrieve payments for invoices and credit notes
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Payments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getPaymentsRequest($ifModifiedSince, $where, $order);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Payments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Payments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getPayments'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getPaymentsRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/Payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPrepayment
     *
     * Allows you to retrieve a specified prepayments
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Prepayments
     */
    public function getPrepayment($prepaymentID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getPrepaymentWithHttpInfo($prepaymentID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getPrepaymentWithHttpInfo
     *
     * Allows you to retrieve a specified prepayments
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Prepayments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPrepaymentWithHttpInfo($prepaymentID)
    {
        $request = $this->getPrepaymentRequest($prepaymentID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Prepayments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Prepayments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getPrepayment'
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getPrepaymentRequest($prepaymentID)
    {
        // Verify the required parameter 'prepaymentID' is set

        if ($prepaymentID === null || (is_array($prepaymentID) && count($prepaymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'prepaymentID',
                'getPrepayment'
            ));
        }

        $resourcePath = '/Prepayments/{PrepaymentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($prepaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PrepaymentID' . '}',
                ObjectSerializer::toPathValue($prepaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPrepaymentHistory
     *
     * Allows you to retrieve a history records of an Prepayment
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getPrepaymentHistory($prepaymentID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getPrepaymentHistoryWithHttpInfo($prepaymentID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getPrepaymentHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an Prepayment
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPrepaymentHistoryWithHttpInfo($prepaymentID)
    {
        $request = $this->getPrepaymentHistoryRequest($prepaymentID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getPrepaymentHistory'
     *
     * @param  string $prepaymentID Unique identifier for a PrePayment (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getPrepaymentHistoryRequest($prepaymentID)
    {
        // Verify the required parameter 'prepaymentID' is set

        if ($prepaymentID === null || (is_array($prepaymentID) && count($prepaymentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'prepaymentID',
                'getPrepaymentHistory'
            ));
        }

        $resourcePath = '/Prepayments/{PrepaymentID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($prepaymentID !== null) {
            $resourcePath = str_replace(
                '{' . 'PrepaymentID' . '}',
                ObjectSerializer::toPathValue($prepaymentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPrepayments
     *
     * Allows you to retrieve prepayments
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Prepayments
     */
    public function getPrepayments($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getPrepaymentsWithHttpInfo($ifModifiedSince, $where, $order, $page, $unitdp);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getPrepaymentsWithHttpInfo
     *
     * Allows you to retrieve prepayments
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Prepayments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPrepaymentsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {
        $request = $this->getPrepaymentsRequest($ifModifiedSince, $where, $order, $page, $unitdp);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Prepayments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Prepayments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getPrepayments'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page e.g. page&#x3D;1 – Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getPrepaymentsRequest($ifModifiedSince = null, $where = null, $order = null, $page = null, $unitdp = null)
    {

        $resourcePath = '/Prepayments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($unitdp !== null) {
            $queryParams['unitdp'] = ObjectSerializer::toQueryValue($unitdp);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPurchaseOrder
     *
     * Allows you to retrieve a specified purchase orders
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\PurchaseOrders
     */
    public function getPurchaseOrder($purchaseOrderID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getPurchaseOrderWithHttpInfo($purchaseOrderID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getPurchaseOrderWithHttpInfo
     *
     * Allows you to retrieve a specified purchase orders
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\PurchaseOrders, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPurchaseOrderWithHttpInfo($purchaseOrderID)
    {
        $request = $this->getPurchaseOrderRequest($purchaseOrderID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\PurchaseOrders'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\PurchaseOrders';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getPurchaseOrder'
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getPurchaseOrderRequest($purchaseOrderID)
    {
        // Verify the required parameter 'purchaseOrderID' is set

        if ($purchaseOrderID === null || (is_array($purchaseOrderID) && count($purchaseOrderID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'purchaseOrderID',
                'getPurchaseOrder'
            ));
        }

        $resourcePath = '/PurchaseOrders/{PurchaseOrderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($purchaseOrderID !== null) {
            $resourcePath = str_replace(
                '{' . 'PurchaseOrderID' . '}',
                ObjectSerializer::toPathValue($purchaseOrderID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPurchaseOrderHistory
     *
     * Allows you to retrieve history for PurchaseOrder
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getPurchaseOrderHistory($purchaseOrderID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getPurchaseOrderHistoryWithHttpInfo($purchaseOrderID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getPurchaseOrderHistoryWithHttpInfo
     *
     * Allows you to retrieve history for PurchaseOrder
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPurchaseOrderHistoryWithHttpInfo($purchaseOrderID)
    {
        $request = $this->getPurchaseOrderHistoryRequest($purchaseOrderID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getPurchaseOrderHistory'
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getPurchaseOrderHistoryRequest($purchaseOrderID)
    {
        // Verify the required parameter 'purchaseOrderID' is set

        if ($purchaseOrderID === null || (is_array($purchaseOrderID) && count($purchaseOrderID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'purchaseOrderID',
                'getPurchaseOrderHistory'
            ));
        }

        $resourcePath = '/PurchaseOrders/{PurchaseOrderID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($purchaseOrderID !== null) {
            $resourcePath = str_replace(
                '{' . 'PurchaseOrderID' . '}',
                ObjectSerializer::toPathValue($purchaseOrderID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getPurchaseOrders
     *
     * Allows you to retrieve purchase orders
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $status Filter by purchase order status (optional)
     * @param  string $dateFrom Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $dateTo Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page To specify a page, append the page parameter to the URL e.g. ?page&#x3D;1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page&#x3D;2 and continuing this process until no more results are returned. (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\PurchaseOrders
     */
    public function getPurchaseOrders($ifModifiedSince = null, $status = null, $dateFrom = null, $dateTo = null, $order = null, $page = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getPurchaseOrdersWithHttpInfo($ifModifiedSince, $status, $dateFrom, $dateTo, $order, $page);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getPurchaseOrdersWithHttpInfo
     *
     * Allows you to retrieve purchase orders
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $status Filter by purchase order status (optional)
     * @param  string $dateFrom Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $dateTo Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page To specify a page, append the page parameter to the URL e.g. ?page&#x3D;1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page&#x3D;2 and continuing this process until no more results are returned. (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\PurchaseOrders, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPurchaseOrdersWithHttpInfo($ifModifiedSince = null, $status = null, $dateFrom = null, $dateTo = null, $order = null, $page = null)
    {
        $request = $this->getPurchaseOrdersRequest($ifModifiedSince, $status, $dateFrom, $dateTo, $order, $page);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\PurchaseOrders'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\PurchaseOrders';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getPurchaseOrders'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $status Filter by purchase order status (optional)
     * @param  string $dateFrom Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $dateTo Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31 (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $page To specify a page, append the page parameter to the URL e.g. ?page&#x3D;1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page&#x3D;2 and continuing this process until no more results are returned. (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getPurchaseOrdersRequest($ifModifiedSince = null, $status = null, $dateFrom = null, $dateTo = null, $order = null, $page = null)
    {

        $resourcePath = '/PurchaseOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($status !== null) {
            $queryParams['Status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($dateFrom !== null) {
            $queryParams['DateFrom'] = ObjectSerializer::toQueryValue($dateFrom);
        }
        // query params
        if ($dateTo !== null) {
            $queryParams['DateTo'] = ObjectSerializer::toQueryValue($dateTo);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReceipt
     *
     * Allows you to retrieve a specified draft expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Receipts
     */
    public function getReceipt($receiptID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReceiptWithHttpInfo($receiptID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReceiptWithHttpInfo
     *
     * Allows you to retrieve a specified draft expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Receipts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiptWithHttpInfo($receiptID)
    {
        $request = $this->getReceiptRequest($receiptID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Receipts'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Receipts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReceipt'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReceiptRequest($receiptID)
    {
        // Verify the required parameter 'receiptID' is set

        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'receiptID',
                'getReceipt'
            ));
        }

        $resourcePath = '/Receipts/{ReceiptID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReceiptAttachmentByFileName
     *
     * Allows you to retrieve Attachments on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getReceiptAttachmentByFileName($receiptID, $fileName, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReceiptAttachmentByFileNameWithHttpInfo($receiptID, $fileName, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReceiptAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve Attachments on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiptAttachmentByFileNameWithHttpInfo($receiptID, $fileName, $contentType)
    {
        $request = $this->getReceiptAttachmentByFileNameRequest($receiptID, $fileName, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReceiptAttachmentByFileName'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReceiptAttachmentByFileNameRequest($receiptID, $fileName, $contentType)
    {
        // Verify the required parameter 'receiptID' is set

        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'receiptID',
                'getReceiptAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'getReceiptAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getReceiptAttachmentByFileName'
            ));
        }

        $resourcePath = '/Receipts/{ReceiptID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReceiptAttachmentById
     *
     * Allows you to retrieve Attachments on expense claim receipts by ID
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getReceiptAttachmentById($receiptID, $attachmentID, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReceiptAttachmentByIdWithHttpInfo($receiptID, $attachmentID, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReceiptAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve Attachments on expense claim receipts by ID
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiptAttachmentByIdWithHttpInfo($receiptID, $attachmentID, $contentType)
    {
        $request = $this->getReceiptAttachmentByIdRequest($receiptID, $attachmentID, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReceiptAttachmentById'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReceiptAttachmentByIdRequest($receiptID, $attachmentID, $contentType)
    {
        // Verify the required parameter 'receiptID' is set

        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'receiptID',
                'getReceiptAttachmentById'
            ));
        }
        // Verify the required parameter 'attachmentID' is set

        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'attachmentID',
                'getReceiptAttachmentById'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getReceiptAttachmentById'
            ));
        }

        $resourcePath = '/Receipts/{ReceiptID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReceiptAttachments
     *
     * Allows you to retrieve Attachments for expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments
     */
    public function getReceiptAttachments($receiptID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReceiptAttachmentsWithHttpInfo($receiptID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReceiptAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachments for expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiptAttachmentsWithHttpInfo($receiptID)
    {
        $request = $this->getReceiptAttachmentsRequest($receiptID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReceiptAttachments'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReceiptAttachmentsRequest($receiptID)
    {
        // Verify the required parameter 'receiptID' is set

        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'receiptID',
                'getReceiptAttachments'
            ));
        }

        $resourcePath = '/Receipts/{ReceiptID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReceiptHistory
     *
     * Allows you to retrieve a history records of an Receipt
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getReceiptHistory($receiptID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReceiptHistoryWithHttpInfo($receiptID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReceiptHistoryWithHttpInfo
     *
     * Allows you to retrieve a history records of an Receipt
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiptHistoryWithHttpInfo($receiptID)
    {
        $request = $this->getReceiptHistoryRequest($receiptID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReceiptHistory'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReceiptHistoryRequest($receiptID)
    {
        // Verify the required parameter 'receiptID' is set

        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'receiptID',
                'getReceiptHistory'
            ));
        }

        $resourcePath = '/Receipts/{ReceiptID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReceipts
     *
     * Allows you to retrieve draft expense claim receipts for any user
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Receipts
     */
    public function getReceipts($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReceiptsWithHttpInfo($ifModifiedSince, $where, $order, $unitdp);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReceiptsWithHttpInfo
     *
     * Allows you to retrieve draft expense claim receipts for any user
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Receipts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReceiptsWithHttpInfo($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {
        $request = $this->getReceiptsRequest($ifModifiedSince, $where, $order, $unitdp);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Receipts'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Receipts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReceipts'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  int $unitdp e.g. unitdp&#x3D;4 – You can opt in to use four decimal places for unit amounts (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReceiptsRequest($ifModifiedSince = null, $where = null, $order = null, $unitdp = null)
    {

        $resourcePath = '/Receipts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($unitdp !== null) {
            $queryParams['unitdp'] = ObjectSerializer::toQueryValue($unitdp);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getRepeatingInvoice
     *
     * Allows you to retrieve a specified repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\RepeatingInvoices
     */
    public function getRepeatingInvoice($repeatingInvoiceID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getRepeatingInvoiceWithHttpInfo($repeatingInvoiceID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getRepeatingInvoiceWithHttpInfo
     *
     * Allows you to retrieve a specified repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\RepeatingInvoices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepeatingInvoiceWithHttpInfo($repeatingInvoiceID)
    {
        $request = $this->getRepeatingInvoiceRequest($repeatingInvoiceID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\RepeatingInvoices'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\RepeatingInvoices';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getRepeatingInvoice'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getRepeatingInvoiceRequest($repeatingInvoiceID)
    {
        // Verify the required parameter 'repeatingInvoiceID' is set

        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'repeatingInvoiceID',
                'getRepeatingInvoice'
            ));
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getRepeatingInvoiceAttachmentByFileName
     *
     * Allows you to retrieve specified attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getRepeatingInvoiceAttachmentByFileName($repeatingInvoiceID, $fileName, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getRepeatingInvoiceAttachmentByFileNameWithHttpInfo($repeatingInvoiceID, $fileName, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getRepeatingInvoiceAttachmentByFileNameWithHttpInfo
     *
     * Allows you to retrieve specified attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepeatingInvoiceAttachmentByFileNameWithHttpInfo($repeatingInvoiceID, $fileName, $contentType)
    {
        $request = $this->getRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getRepeatingInvoiceAttachmentByFileName'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $contentType)
    {
        // Verify the required parameter 'repeatingInvoiceID' is set

        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'repeatingInvoiceID',
                'getRepeatingInvoiceAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'getRepeatingInvoiceAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getRepeatingInvoiceAttachmentByFileName'
            ));
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getRepeatingInvoiceAttachmentById
     *
     * Allows you to retrieve a specified Attachments on repeating invoices
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \SplFileObject
     */
    public function getRepeatingInvoiceAttachmentById($repeatingInvoiceID, $attachmentID, $contentType)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getRepeatingInvoiceAttachmentByIdWithHttpInfo($repeatingInvoiceID, $attachmentID, $contentType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getRepeatingInvoiceAttachmentByIdWithHttpInfo
     *
     * Allows you to retrieve a specified Attachments on repeating invoices
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepeatingInvoiceAttachmentByIdWithHttpInfo($repeatingInvoiceID, $attachmentID, $contentType)
    {
        $request = $this->getRepeatingInvoiceAttachmentByIdRequest($repeatingInvoiceID, $attachmentID, $contentType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\SplFileObject'),
                    $request,
                    $response
                ];
        }

        $returnType = '\SplFileObject';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getRepeatingInvoiceAttachmentById'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $attachmentID Unique identifier for a Attachment (required)
     * @param  string $contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getRepeatingInvoiceAttachmentByIdRequest($repeatingInvoiceID, $attachmentID, $contentType)
    {
        // Verify the required parameter 'repeatingInvoiceID' is set

        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'repeatingInvoiceID',
                'getRepeatingInvoiceAttachmentById'
            ));
        }
        // Verify the required parameter 'attachmentID' is set

        if ($attachmentID === null || (is_array($attachmentID) && count($attachmentID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'attachmentID',
                'getRepeatingInvoiceAttachmentById'
            ));
        }
        // Verify the required parameter 'contentType' is set

        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contentType',
                'getRepeatingInvoiceAttachmentById'
            ));
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{AttachmentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($contentType !== null) {
            $headerParams['contentType'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }
        // path params
        if ($attachmentID !== null) {
            $resourcePath = str_replace(
                '{' . 'AttachmentID' . '}',
                ObjectSerializer::toPathValue($attachmentID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getRepeatingInvoiceAttachments
     *
     * Allows you to retrieve Attachments on repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments
     */
    public function getRepeatingInvoiceAttachments($repeatingInvoiceID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getRepeatingInvoiceAttachmentsWithHttpInfo($repeatingInvoiceID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getRepeatingInvoiceAttachmentsWithHttpInfo
     *
     * Allows you to retrieve Attachments on repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepeatingInvoiceAttachmentsWithHttpInfo($repeatingInvoiceID)
    {
        $request = $this->getRepeatingInvoiceAttachmentsRequest($repeatingInvoiceID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getRepeatingInvoiceAttachments'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getRepeatingInvoiceAttachmentsRequest($repeatingInvoiceID)
    {
        // Verify the required parameter 'repeatingInvoiceID' is set

        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'repeatingInvoiceID',
                'getRepeatingInvoiceAttachments'
            ));
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getRepeatingInvoiceHistory
     *
     * Allows you to retrieve history for a repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\HistoryRecords
     */
    public function getRepeatingInvoiceHistory($repeatingInvoiceID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getRepeatingInvoiceHistoryWithHttpInfo($repeatingInvoiceID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getRepeatingInvoiceHistoryWithHttpInfo
     *
     * Allows you to retrieve history for a repeating invoice
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\HistoryRecords, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepeatingInvoiceHistoryWithHttpInfo($repeatingInvoiceID)
    {
        $request = $this->getRepeatingInvoiceHistoryRequest($repeatingInvoiceID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\HistoryRecords'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\HistoryRecords';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getRepeatingInvoiceHistory'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getRepeatingInvoiceHistoryRequest($repeatingInvoiceID)
    {
        // Verify the required parameter 'repeatingInvoiceID' is set

        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'repeatingInvoiceID',
                'getRepeatingInvoiceHistory'
            ));
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/History';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getRepeatingInvoices
     *
     * Allows you to retrieve any repeating invoices
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\RepeatingInvoices
     */
    public function getRepeatingInvoices($where = null, $order = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getRepeatingInvoicesWithHttpInfo($where, $order);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getRepeatingInvoicesWithHttpInfo
     *
     * Allows you to retrieve any repeating invoices
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\RepeatingInvoices, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepeatingInvoicesWithHttpInfo($where = null, $order = null)
    {
        $request = $this->getRepeatingInvoicesRequest($where, $order);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\RepeatingInvoices'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\RepeatingInvoices';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getRepeatingInvoices'
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getRepeatingInvoicesRequest($where = null, $order = null)
    {

        $resourcePath = '/RepeatingInvoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportAgedPayablesByContact
     *
     * Allows you to retrieve report for AgedPayablesByContact
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Payables By Contact report (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ReportWithRows
     */
    public function getReportAgedPayablesByContact($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReportAgedPayablesByContactWithHttpInfo($contactId, $date, $fromDate, $toDate);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReportAgedPayablesByContactWithHttpInfo
     *
     * Allows you to retrieve report for AgedPayablesByContact
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Payables By Contact report (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportAgedPayablesByContactWithHttpInfo($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        $request = $this->getReportAgedPayablesByContactRequest($contactId, $date, $fromDate, $toDate);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ReportWithRows'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ReportWithRows';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReportAgedPayablesByContact'
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Payables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Payables By Contact report (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReportAgedPayablesByContactRequest($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        // Verify the required parameter 'contactId' is set

        if ($contactId === null || (is_array($contactId) && count($contactId) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactId',
                'getReportAgedPayablesByContact'
            ));
        }

        $resourcePath = '/Reports/AgedPayablesByContact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contactId !== null) {
            $queryParams['contactId'] = ObjectSerializer::toQueryValue($contactId);
        }
        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($fromDate !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($fromDate);
        }
        // query params
        if ($toDate !== null) {
            $queryParams['toDate'] = ObjectSerializer::toQueryValue($toDate);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportAgedReceivablesByContact
     *
     * Allows you to retrieve report for AgedReceivablesByContact
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Receivables By Contact report (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ReportWithRows
     */
    public function getReportAgedReceivablesByContact($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReportAgedReceivablesByContactWithHttpInfo($contactId, $date, $fromDate, $toDate);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReportAgedReceivablesByContactWithHttpInfo
     *
     * Allows you to retrieve report for AgedReceivablesByContact
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Receivables By Contact report (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportAgedReceivablesByContactWithHttpInfo($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        $request = $this->getReportAgedReceivablesByContactRequest($contactId, $date, $fromDate, $toDate);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ReportWithRows'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ReportWithRows';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReportAgedReceivablesByContact'
     *
     * @param  string $contactId Unique identifier for a Contact (required)
     * @param  \DateTime $date The date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $fromDate The from date of the Aged Receivables By Contact report (optional)
     * @param  \DateTime $toDate The to date of the Aged Receivables By Contact report (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReportAgedReceivablesByContactRequest($contactId, $date = null, $fromDate = null, $toDate = null)
    {
        // Verify the required parameter 'contactId' is set

        if ($contactId === null || (is_array($contactId) && count($contactId) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactId',
                'getReportAgedReceivablesByContact'
            ));
        }

        $resourcePath = '/Reports/AgedReceivablesByContact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contactId !== null) {
            $queryParams['contactId'] = ObjectSerializer::toQueryValue($contactId);
        }
        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($fromDate !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($fromDate);
        }
        // query params
        if ($toDate !== null) {
            $queryParams['toDate'] = ObjectSerializer::toQueryValue($toDate);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportBASorGST
     *
     * Allows you to retrieve report for BAS only valid for AU orgs
     *
     * @param  string $reportID Unique identifier for a Report (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ReportWithRows
     */
    public function getReportBASorGST($reportID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReportBASorGSTWithHttpInfo($reportID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReportBASorGSTWithHttpInfo
     *
     * Allows you to retrieve report for BAS only valid for AU orgs
     *
     * @param  string $reportID Unique identifier for a Report (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportBASorGSTWithHttpInfo($reportID)
    {
        $request = $this->getReportBASorGSTRequest($reportID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ReportWithRows'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ReportWithRows';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReportBASorGST'
     *
     * @param  string $reportID Unique identifier for a Report (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReportBASorGSTRequest($reportID)
    {
        // Verify the required parameter 'reportID' is set

        if ($reportID === null || (is_array($reportID) && count($reportID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'reportID',
                'getReportBASorGST'
            ));
        }

        $resourcePath = '/Reports/{ReportID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($reportID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReportID' . '}',
                ObjectSerializer::toPathValue($reportID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportBASorGSTList
     *
     * Allows you to retrieve report for BAS only valid for AU orgs
     *
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ReportWithRows
     */
    public function getReportBASorGSTList()
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReportBASorGSTListWithHttpInfo();

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReportBASorGSTListWithHttpInfo
     *
     * Allows you to retrieve report for BAS only valid for AU orgs
     *
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportBASorGSTListWithHttpInfo()
    {
        $request = $this->getReportBASorGSTListRequest();

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ReportWithRows'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ReportWithRows';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReportBASorGSTList'
     *
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReportBASorGSTListRequest()
    {

        $resourcePath = '/Reports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportBalanceSheet
     *
     * Allows you to retrieve report for BalanceSheet
     *
     * @param  string $date The date of the Balance Sheet report (optional)
     * @param  int $periods The number of periods for the Balance Sheet report (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingOptionID1 The tracking option 1 for the Balance Sheet report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the Balance Sheet report (optional)
     * @param  bool $standardLayout The standard layout boolean for the Balance Sheet report (optional)
     * @param  bool $paymentsOnly return a cash basis for the Balance Sheet report (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ReportWithRows
     */
    public function getReportBalanceSheet($date = null, $periods = null, $timeframe = null, $trackingOptionID1 = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReportBalanceSheetWithHttpInfo($date, $periods, $timeframe, $trackingOptionID1, $trackingOptionID2, $standardLayout, $paymentsOnly);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReportBalanceSheetWithHttpInfo
     *
     * Allows you to retrieve report for BalanceSheet
     *
     * @param  string $date The date of the Balance Sheet report (optional)
     * @param  int $periods The number of periods for the Balance Sheet report (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingOptionID1 The tracking option 1 for the Balance Sheet report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the Balance Sheet report (optional)
     * @param  bool $standardLayout The standard layout boolean for the Balance Sheet report (optional)
     * @param  bool $paymentsOnly return a cash basis for the Balance Sheet report (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportBalanceSheetWithHttpInfo($date = null, $periods = null, $timeframe = null, $trackingOptionID1 = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {
        $request = $this->getReportBalanceSheetRequest($date, $periods, $timeframe, $trackingOptionID1, $trackingOptionID2, $standardLayout, $paymentsOnly);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ReportWithRows'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ReportWithRows';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReportBalanceSheet'
     *
     * @param  string $date The date of the Balance Sheet report (optional)
     * @param  int $periods The number of periods for the Balance Sheet report (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingOptionID1 The tracking option 1 for the Balance Sheet report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the Balance Sheet report (optional)
     * @param  bool $standardLayout The standard layout boolean for the Balance Sheet report (optional)
     * @param  bool $paymentsOnly return a cash basis for the Balance Sheet report (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReportBalanceSheetRequest($date = null, $periods = null, $timeframe = null, $trackingOptionID1 = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {

        $resourcePath = '/Reports/BalanceSheet';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($periods !== null) {
            $queryParams['periods'] = ObjectSerializer::toQueryValue($periods);
        }
        // query params
        if ($timeframe !== null) {
            $queryParams['timeframe'] = ObjectSerializer::toQueryValue($timeframe);
        }
        // query params
        if ($trackingOptionID1 !== null) {
            $queryParams['trackingOptionID1'] = ObjectSerializer::toQueryValue($trackingOptionID1);
        }
        // query params
        if ($trackingOptionID2 !== null) {
            $queryParams['trackingOptionID2'] = ObjectSerializer::toQueryValue($trackingOptionID2);
        }
        // query params
        if ($standardLayout !== null) {
            $queryParams['standardLayout'] = ObjectSerializer::toQueryValue($standardLayout);
        }
        // query params
        if ($paymentsOnly !== null) {
            $queryParams['paymentsOnly'] = ObjectSerializer::toQueryValue($paymentsOnly);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportBankSummary
     *
     * Allows you to retrieve report for BankSummary
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ReportWithRows
     */
    public function getReportBankSummary($date = null, $period = null, $timeframe = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReportBankSummaryWithHttpInfo($date, $period, $timeframe);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReportBankSummaryWithHttpInfo
     *
     * Allows you to retrieve report for BankSummary
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportBankSummaryWithHttpInfo($date = null, $period = null, $timeframe = null)
    {
        $request = $this->getReportBankSummaryRequest($date, $period, $timeframe);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ReportWithRows'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ReportWithRows';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReportBankSummary'
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReportBankSummaryRequest($date = null, $period = null, $timeframe = null)
    {

        $resourcePath = '/Reports/BankSummary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($period !== null) {
            $queryParams['period'] = ObjectSerializer::toQueryValue($period);
        }
        // query params
        if ($timeframe !== null) {
            $queryParams['timeframe'] = ObjectSerializer::toQueryValue($timeframe);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportBudgetSummary
     *
     * Allows you to retrieve report for Budget Summary
     *
     * @param  \DateTime $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ReportWithRows
     */
    public function getReportBudgetSummary($date = null, $period = null, $timeframe = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReportBudgetSummaryWithHttpInfo($date, $period, $timeframe);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReportBudgetSummaryWithHttpInfo
     *
     * Allows you to retrieve report for Budget Summary
     *
     * @param  \DateTime $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportBudgetSummaryWithHttpInfo($date = null, $period = null, $timeframe = null)
    {
        $request = $this->getReportBudgetSummaryRequest($date, $period, $timeframe);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ReportWithRows'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ReportWithRows';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReportBudgetSummary'
     *
     * @param  \DateTime $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     * @param  int $period The number of periods to compare (integer between 1 and 12) (optional)
     * @param  int $timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year) (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReportBudgetSummaryRequest($date = null, $period = null, $timeframe = null)
    {

        $resourcePath = '/Reports/BudgetSummary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($period !== null) {
            $queryParams['period'] = ObjectSerializer::toQueryValue($period);
        }
        // query params
        if ($timeframe !== null) {
            $queryParams['timeframe'] = ObjectSerializer::toQueryValue($timeframe);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportExecutiveSummary
     *
     * Allows you to retrieve report for ExecutiveSummary
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ReportWithRows
     */
    public function getReportExecutiveSummary($date = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReportExecutiveSummaryWithHttpInfo($date);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReportExecutiveSummaryWithHttpInfo
     *
     * Allows you to retrieve report for ExecutiveSummary
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportExecutiveSummaryWithHttpInfo($date = null)
    {
        $request = $this->getReportExecutiveSummaryRequest($date);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ReportWithRows'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ReportWithRows';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReportExecutiveSummary'
     *
     * @param  string $date The date for the Bank Summary report e.g. 2018-03-31 (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReportExecutiveSummaryRequest($date = null)
    {

        $resourcePath = '/Reports/ExecutiveSummary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportProfitAndLoss
     *
     * Allows you to retrieve report for ProfitAndLoss
     *
     * @param  string $fromDate The from date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  string $toDate The to date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  int $periods The number of periods to compare (integer between 1 and 12) (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingCategoryID The trackingCategory 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingCategoryID2 The trackingCategory 2 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID The tracking option 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the ProfitAndLoss report (optional)
     * @param  bool $standardLayout Return the standard layout for the ProfitAndLoss report (optional)
     * @param  bool $paymentsOnly Return cash only basis for the ProfitAndLoss report (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ReportWithRows
     */
    public function getReportProfitAndLoss($fromDate = null, $toDate = null, $periods = null, $timeframe = null, $trackingCategoryID = null, $trackingCategoryID2 = null, $trackingOptionID = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReportProfitAndLossWithHttpInfo($fromDate, $toDate, $periods, $timeframe, $trackingCategoryID, $trackingCategoryID2, $trackingOptionID, $trackingOptionID2, $standardLayout, $paymentsOnly);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReportProfitAndLossWithHttpInfo
     *
     * Allows you to retrieve report for ProfitAndLoss
     *
     * @param  string $fromDate The from date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  string $toDate The to date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  int $periods The number of periods to compare (integer between 1 and 12) (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingCategoryID The trackingCategory 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingCategoryID2 The trackingCategory 2 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID The tracking option 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the ProfitAndLoss report (optional)
     * @param  bool $standardLayout Return the standard layout for the ProfitAndLoss report (optional)
     * @param  bool $paymentsOnly Return cash only basis for the ProfitAndLoss report (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportProfitAndLossWithHttpInfo($fromDate = null, $toDate = null, $periods = null, $timeframe = null, $trackingCategoryID = null, $trackingCategoryID2 = null, $trackingOptionID = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {
        $request = $this->getReportProfitAndLossRequest($fromDate, $toDate, $periods, $timeframe, $trackingCategoryID, $trackingCategoryID2, $trackingOptionID, $trackingOptionID2, $standardLayout, $paymentsOnly);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ReportWithRows'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ReportWithRows';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReportProfitAndLoss'
     *
     * @param  string $fromDate The from date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  string $toDate The to date for the ProfitAndLoss report e.g. 2018-03-31 (optional)
     * @param  int $periods The number of periods to compare (integer between 1 and 12) (optional)
     * @param  string $timeframe The period size to compare to (MONTH, QUARTER, YEAR) (optional)
     * @param  string $trackingCategoryID The trackingCategory 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingCategoryID2 The trackingCategory 2 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID The tracking option 1 for the ProfitAndLoss report (optional)
     * @param  string $trackingOptionID2 The tracking option 2 for the ProfitAndLoss report (optional)
     * @param  bool $standardLayout Return the standard layout for the ProfitAndLoss report (optional)
     * @param  bool $paymentsOnly Return cash only basis for the ProfitAndLoss report (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReportProfitAndLossRequest($fromDate = null, $toDate = null, $periods = null, $timeframe = null, $trackingCategoryID = null, $trackingCategoryID2 = null, $trackingOptionID = null, $trackingOptionID2 = null, $standardLayout = null, $paymentsOnly = null)
    {

        $resourcePath = '/Reports/ProfitAndLoss';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fromDate !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($fromDate);
        }
        // query params
        if ($toDate !== null) {
            $queryParams['toDate'] = ObjectSerializer::toQueryValue($toDate);
        }
        // query params
        if ($periods !== null) {
            $queryParams['periods'] = ObjectSerializer::toQueryValue($periods);
        }
        // query params
        if ($timeframe !== null) {
            $queryParams['timeframe'] = ObjectSerializer::toQueryValue($timeframe);
        }
        // query params
        if ($trackingCategoryID !== null) {
            $queryParams['trackingCategoryID'] = ObjectSerializer::toQueryValue($trackingCategoryID);
        }
        // query params
        if ($trackingCategoryID2 !== null) {
            $queryParams['trackingCategoryID2'] = ObjectSerializer::toQueryValue($trackingCategoryID2);
        }
        // query params
        if ($trackingOptionID !== null) {
            $queryParams['trackingOptionID'] = ObjectSerializer::toQueryValue($trackingOptionID);
        }
        // query params
        if ($trackingOptionID2 !== null) {
            $queryParams['trackingOptionID2'] = ObjectSerializer::toQueryValue($trackingOptionID2);
        }
        // query params
        if ($standardLayout !== null) {
            $queryParams['standardLayout'] = ObjectSerializer::toQueryValue($standardLayout);
        }
        // query params
        if ($paymentsOnly !== null) {
            $queryParams['paymentsOnly'] = ObjectSerializer::toQueryValue($paymentsOnly);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportTenNinetyNine
     *
     * Allows you to retrieve report for TenNinetyNine
     *
     * @param  string $reportYear The year of the 1099 report (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Reports
     */
    public function getReportTenNinetyNine($reportYear = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReportTenNinetyNineWithHttpInfo($reportYear);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReportTenNinetyNineWithHttpInfo
     *
     * Allows you to retrieve report for TenNinetyNine
     *
     * @param  string $reportYear The year of the 1099 report (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Reports, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportTenNinetyNineWithHttpInfo($reportYear = null)
    {
        $request = $this->getReportTenNinetyNineRequest($reportYear);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Reports'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Reports';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReportTenNinetyNine'
     *
     * @param  string $reportYear The year of the 1099 report (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReportTenNinetyNineRequest($reportYear = null)
    {

        $resourcePath = '/Reports/TenNinetyNine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($reportYear !== null) {
            $queryParams['reportYear'] = ObjectSerializer::toQueryValue($reportYear);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getReportTrialBalance
     *
     * Allows you to retrieve report for TrialBalance
     *
     * @param  string $date The date for the Trial Balance report e.g. 2018-03-31 (optional)
     * @param  bool $paymentsOnly Return cash only basis for the Trial Balance report (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ReportWithRows
     */
    public function getReportTrialBalance($date = null, $paymentsOnly = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getReportTrialBalanceWithHttpInfo($date, $paymentsOnly);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getReportTrialBalanceWithHttpInfo
     *
     * Allows you to retrieve report for TrialBalance
     *
     * @param  string $date The date for the Trial Balance report e.g. 2018-03-31 (optional)
     * @param  bool $paymentsOnly Return cash only basis for the Trial Balance report (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ReportWithRows, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportTrialBalanceWithHttpInfo($date = null, $paymentsOnly = null)
    {
        $request = $this->getReportTrialBalanceRequest($date, $paymentsOnly);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ReportWithRows'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ReportWithRows';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getReportTrialBalance'
     *
     * @param  string $date The date for the Trial Balance report e.g. 2018-03-31 (optional)
     * @param  bool $paymentsOnly Return cash only basis for the Trial Balance report (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getReportTrialBalanceRequest($date = null, $paymentsOnly = null)
    {

        $resourcePath = '/Reports/TrialBalance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($paymentsOnly !== null) {
            $queryParams['paymentsOnly'] = ObjectSerializer::toQueryValue($paymentsOnly);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getTaxRates
     *
     * Allows you to retrieve Tax Rates
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $taxType Filter by tax type (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\TaxRates
     */
    public function getTaxRates($where = null, $order = null, $taxType = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getTaxRatesWithHttpInfo($where, $order, $taxType);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getTaxRatesWithHttpInfo
     *
     * Allows you to retrieve Tax Rates
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $taxType Filter by tax type (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\TaxRates, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTaxRatesWithHttpInfo($where = null, $order = null, $taxType = null)
    {
        $request = $this->getTaxRatesRequest($where, $order, $taxType);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\TaxRates'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\TaxRates';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getTaxRates'
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  string $taxType Filter by tax type (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getTaxRatesRequest($where = null, $order = null, $taxType = null)
    {

        $resourcePath = '/TaxRates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($taxType !== null) {
            $queryParams['TaxType'] = ObjectSerializer::toQueryValue($taxType);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getTrackingCategories
     *
     * Allows you to retrieve tracking categories and options
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Categories and options with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\TrackingCategories
     */
    public function getTrackingCategories($where = null, $order = null, $includeArchived = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getTrackingCategoriesWithHttpInfo($where, $order, $includeArchived);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getTrackingCategoriesWithHttpInfo
     *
     * Allows you to retrieve tracking categories and options
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Categories and options with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\TrackingCategories, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTrackingCategoriesWithHttpInfo($where = null, $order = null, $includeArchived = null)
    {
        $request = $this->getTrackingCategoriesRequest($where, $order, $includeArchived);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\TrackingCategories'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\TrackingCategories';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getTrackingCategories'
     *
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     * @param  bool $includeArchived e.g. includeArchived&#x3D;true - Categories and options with a status of ARCHIVED will be included in the response (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getTrackingCategoriesRequest($where = null, $order = null, $includeArchived = null)
    {

        $resourcePath = '/TrackingCategories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // query params
        if ($includeArchived !== null) {
            $queryParams['includeArchived'] = ObjectSerializer::toQueryValue($includeArchived);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getTrackingCategory
     *
     * Allows you to retrieve tracking categories and options for specified category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\TrackingCategories
     */
    public function getTrackingCategory($trackingCategoryID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getTrackingCategoryWithHttpInfo($trackingCategoryID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getTrackingCategoryWithHttpInfo
     *
     * Allows you to retrieve tracking categories and options for specified category
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\TrackingCategories, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTrackingCategoryWithHttpInfo($trackingCategoryID)
    {
        $request = $this->getTrackingCategoryRequest($trackingCategoryID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\TrackingCategories'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\TrackingCategories';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getTrackingCategory'
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getTrackingCategoryRequest($trackingCategoryID)
    {
        // Verify the required parameter 'trackingCategoryID' is set

        if ($trackingCategoryID === null || (is_array($trackingCategoryID) && count($trackingCategoryID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'trackingCategoryID',
                'getTrackingCategory'
            ));
        }

        $resourcePath = '/TrackingCategories/{TrackingCategoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($trackingCategoryID !== null) {
            $resourcePath = str_replace(
                '{' . 'TrackingCategoryID' . '}',
                ObjectSerializer::toPathValue($trackingCategoryID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getUser
     *
     * Allows you to retrieve a specified user
     *
     * @param  string $userID Unique identifier for a User (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Users
     */
    public function getUser($userID)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getUserWithHttpInfo($userID);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getUserWithHttpInfo
     *
     * Allows you to retrieve a specified user
     *
     * @param  string $userID Unique identifier for a User (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Users, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserWithHttpInfo($userID)
    {
        $request = $this->getUserRequest($userID);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Users'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Users';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getUser'
     *
     * @param  string $userID Unique identifier for a User (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getUserRequest($userID)
    {
        // Verify the required parameter 'userID' is set

        if ($userID === null || (is_array($userID) && count($userID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'userID',
                'getUser'
            ));
        }

        $resourcePath = '/Users/{UserID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($userID !== null) {
            $resourcePath = str_replace(
                '{' . 'UserID' . '}',
                ObjectSerializer::toPathValue($userID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation getUsers
     *
     * Allows you to retrieve users
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Users
     */
    public function getUsers($ifModifiedSince = null, $where = null, $order = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->getUsersWithHttpInfo($ifModifiedSince, $where, $order);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation getUsersWithHttpInfo
     *
     * Allows you to retrieve users
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Users, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUsersWithHttpInfo($ifModifiedSince = null, $where = null, $order = null)
    {
        $request = $this->getUsersRequest($ifModifiedSince, $where, $order);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Users'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Users';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'getUsers'
     *
     * @param  \DateTime $ifModifiedSince Only records created or modified since this timestamp will be returned (optional)
     * @param  string $where Filter by an any element (optional)
     * @param  string $order Order by an any element (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function getUsersRequest($ifModifiedSince = null, $where = null, $order = null)
    {

        $resourcePath = '/Users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = ObjectSerializer::toQueryValue($order);
        }
        // header params
        if ($ifModifiedSince !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($ifModifiedSince);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'GET'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('GET', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateAccount
     *
     * Allows you to update a chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Accounts $accounts Request of type Accounts array with one Account (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Accounts|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateAccount($accountID, $accounts)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateAccountWithHttpInfo($accountID, $accounts);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateAccountWithHttpInfo
     *
     * Allows you to update a chart of accounts
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Accounts $accounts Request of type Accounts array with one Account (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Accounts|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAccountWithHttpInfo($accountID, $accounts)
    {
        $request = $this->updateAccountRequest($accountID, $accounts);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Accounts'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Accounts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateAccount'
     *
     * @param  string $accountID Unique identifier for retrieving single object (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Accounts $accounts Request of type Accounts array with one Account (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateAccountRequest($accountID, $accounts)
    {
        // Verify the required parameter 'accountID' is set

        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'accountID',
                'updateAccount'
            ));
        }
        // Verify the required parameter 'accounts' is set

        if ($accounts === null || (is_array($accounts) && count($accounts) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'accounts',
                'updateAccount'
            ));
        }

        $resourcePath = '/Accounts/{AccountID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($accounts)) {
            $_tempBody = $accounts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateAccountAttachmentByFileName
     *
     * Allows you to update Attachment on Account by Filename
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateAccountAttachmentByFileName($accountID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateAccountAttachmentByFileNameWithHttpInfo($accountID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateAccountAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update Attachment on Account by Filename
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAccountAttachmentByFileNameWithHttpInfo($accountID, $fileName, $body)
    {
        $request = $this->updateAccountAttachmentByFileNameRequest($accountID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateAccountAttachmentByFileName'
     *
     * @param  string $accountID Unique identifier for Account object (required)
     * @param  string $fileName Name of the attachment (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateAccountAttachmentByFileNameRequest($accountID, $fileName, $body)
    {
        // Verify the required parameter 'accountID' is set

        if ($accountID === null || (is_array($accountID) && count($accountID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'accountID',
                'updateAccountAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'updateAccountAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'updateAccountAttachmentByFileName'
            ));
        }

        $resourcePath = '/Accounts/{AccountID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($accountID !== null) {
            $resourcePath = str_replace(
                '{' . 'AccountID' . '}',
                ObjectSerializer::toPathValue($accountID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateBankTransaction
     *
     * Allows you to update a single spend or receive money transaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\BankTransactions $bankTransactions bankTransactions (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\BankTransactions|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateBankTransaction($bankTransactionID, $bankTransactions)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateBankTransactionWithHttpInfo($bankTransactionID, $bankTransactions);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateBankTransactionWithHttpInfo
     *
     * Allows you to update a single spend or receive money transaction
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\BankTransactions $bankTransactions (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\BankTransactions|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBankTransactionWithHttpInfo($bankTransactionID, $bankTransactions)
    {
        $request = $this->updateBankTransactionRequest($bankTransactionID, $bankTransactions);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\BankTransactions'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\BankTransactions';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateBankTransaction'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\BankTransactions $bankTransactions (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateBankTransactionRequest($bankTransactionID, $bankTransactions)
    {
        // Verify the required parameter 'bankTransactionID' is set

        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransactionID',
                'updateBankTransaction'
            ));
        }
        // Verify the required parameter 'bankTransactions' is set

        if ($bankTransactions === null || (is_array($bankTransactions) && count($bankTransactions) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransactions',
                'updateBankTransaction'
            ));
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($bankTransactions)) {
            $_tempBody = $bankTransactions;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateBankTransactionAttachmentByFileName
     *
     * Allows you to update an Attachment on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateBankTransactionAttachmentByFileName($bankTransactionID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateBankTransactionAttachmentByFileNameWithHttpInfo($bankTransactionID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateBankTransactionAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update an Attachment on BankTransaction by Filename
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBankTransactionAttachmentByFileNameWithHttpInfo($bankTransactionID, $fileName, $body)
    {
        $request = $this->updateBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateBankTransactionAttachmentByFileName'
     *
     * @param  string $bankTransactionID Xero generated unique identifier for a bank transaction (required)
     * @param  string $fileName The name of the file being attached (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateBankTransactionAttachmentByFileNameRequest($bankTransactionID, $fileName, $body)
    {
        // Verify the required parameter 'bankTransactionID' is set

        if ($bankTransactionID === null || (is_array($bankTransactionID) && count($bankTransactionID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransactionID',
                'updateBankTransactionAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'updateBankTransactionAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'updateBankTransactionAttachmentByFileName'
            ));
        }

        $resourcePath = '/BankTransactions/{BankTransactionID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransactionID' . '}',
                ObjectSerializer::toPathValue($bankTransactionID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateBankTransferAttachmentByFileName
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateBankTransferAttachmentByFileName($bankTransferID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateBankTransferAttachmentByFileNameWithHttpInfo($bankTransferID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateBankTransferAttachmentByFileNameWithHttpInfo
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBankTransferAttachmentByFileNameWithHttpInfo($bankTransferID, $fileName, $body)
    {
        $request = $this->updateBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateBankTransferAttachmentByFileName'
     *
     * @param  string $bankTransferID Xero generated unique identifier for a bank transfer (required)
     * @param  string $fileName The name of the file being attached to a Bank Transfer (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateBankTransferAttachmentByFileNameRequest($bankTransferID, $fileName, $body)
    {
        // Verify the required parameter 'bankTransferID' is set

        if ($bankTransferID === null || (is_array($bankTransferID) && count($bankTransferID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'bankTransferID',
                'updateBankTransferAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'updateBankTransferAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'updateBankTransferAttachmentByFileName'
            ));
        }

        $resourcePath = '/BankTransfers/{BankTransferID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bankTransferID !== null) {
            $resourcePath = str_replace(
                '{' . 'BankTransferID' . '}',
                ObjectSerializer::toPathValue($bankTransferID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateContact
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Contacts $contacts contacts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Contacts|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateContact($contactID, $contacts = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateContactWithHttpInfo($contactID, $contacts);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateContactWithHttpInfo
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Contacts $contacts (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Contacts|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContactWithHttpInfo($contactID, $contacts = null)
    {
        $request = $this->updateContactRequest($contactID, $contacts);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Contacts'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Contacts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateContact'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Contacts $contacts (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateContactRequest($contactID, $contacts = null)
    {
        // Verify the required parameter 'contactID' is set

        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactID',
                'updateContact'
            ));
        }

        $resourcePath = '/Contacts/{ContactID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($contacts)) {
            $_tempBody = $contacts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateContactAttachmentByFileName
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateContactAttachmentByFileName($contactID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateContactAttachmentByFileNameWithHttpInfo($contactID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateContactAttachmentByFileNameWithHttpInfo
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContactAttachmentByFileNameWithHttpInfo($contactID, $fileName, $body)
    {
        $request = $this->updateContactAttachmentByFileNameRequest($contactID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateContactAttachmentByFileName'
     *
     * @param  string $contactID Unique identifier for a Contact (required)
     * @param  string $fileName Name for the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateContactAttachmentByFileNameRequest($contactID, $fileName, $body)
    {
        // Verify the required parameter 'contactID' is set

        if ($contactID === null || (is_array($contactID) && count($contactID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactID',
                'updateContactAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'updateContactAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'updateContactAttachmentByFileName'
            ));
        }

        $resourcePath = '/Contacts/{ContactID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactID' . '}',
                ObjectSerializer::toPathValue($contactID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateContactGroup
     *
     * Allows you to update a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\ContactGroups $contactGroups contactGroups (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ContactGroups|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateContactGroup($contactGroupID, $contactGroups = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateContactGroupWithHttpInfo($contactGroupID, $contactGroups);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateContactGroupWithHttpInfo
     *
     * Allows you to update a Contract Group
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\ContactGroups $contactGroups (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ContactGroups|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContactGroupWithHttpInfo($contactGroupID, $contactGroups = null)
    {
        $request = $this->updateContactGroupRequest($contactGroupID, $contactGroups);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ContactGroups'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ContactGroups';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateContactGroup'
     *
     * @param  string $contactGroupID Unique identifier for a Contact Group (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\ContactGroups $contactGroups (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateContactGroupRequest($contactGroupID, $contactGroups = null)
    {
        // Verify the required parameter 'contactGroupID' is set

        if ($contactGroupID === null || (is_array($contactGroupID) && count($contactGroupID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'contactGroupID',
                'updateContactGroup'
            ));
        }

        $resourcePath = '/ContactGroups/{ContactGroupID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contactGroupID !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactGroupID' . '}',
                ObjectSerializer::toPathValue($contactGroupID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($contactGroups)) {
            $_tempBody = $contactGroups;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateCreditNote
     *
     * Allows you to update a specific credit note
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\CreditNotes $creditNotes creditNotes (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\CreditNotes|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateCreditNote($creditNoteID, $creditNotes = null)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateCreditNoteWithHttpInfo($creditNoteID, $creditNotes);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateCreditNoteWithHttpInfo
     *
     * Allows you to update a specific credit note
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\CreditNotes $creditNotes (optional)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\CreditNotes|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCreditNoteWithHttpInfo($creditNoteID, $creditNotes = null)
    {
        $request = $this->updateCreditNoteRequest($creditNoteID, $creditNotes);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\CreditNotes'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\CreditNotes';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateCreditNote'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\CreditNotes $creditNotes (optional)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateCreditNoteRequest($creditNoteID, $creditNotes = null)
    {
        // Verify the required parameter 'creditNoteID' is set

        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'creditNoteID',
                'updateCreditNote'
            ));
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($creditNotes)) {
            $_tempBody = $creditNotes;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateCreditNoteAttachmentByFileName
     *
     * Allows you to update Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateCreditNoteAttachmentByFileName($creditNoteID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateCreditNoteAttachmentByFileNameWithHttpInfo($creditNoteID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateCreditNoteAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update Attachments on CreditNote by file name
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCreditNoteAttachmentByFileNameWithHttpInfo($creditNoteID, $fileName, $body)
    {
        $request = $this->updateCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateCreditNoteAttachmentByFileName'
     *
     * @param  string $creditNoteID Unique identifier for a Credit Note (required)
     * @param  string $fileName Name of the file you are attaching to Credit Note (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateCreditNoteAttachmentByFileNameRequest($creditNoteID, $fileName, $body)
    {
        // Verify the required parameter 'creditNoteID' is set

        if ($creditNoteID === null || (is_array($creditNoteID) && count($creditNoteID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'creditNoteID',
                'updateCreditNoteAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'updateCreditNoteAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'updateCreditNoteAttachmentByFileName'
            ));
        }

        $resourcePath = '/CreditNotes/{CreditNoteID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($creditNoteID !== null) {
            $resourcePath = str_replace(
                '{' . 'CreditNoteID' . '}',
                ObjectSerializer::toPathValue($creditNoteID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateEmployee
     *
     * Allows you to update a specific employee used in Xero payrun
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Employees $employees employees (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Employees|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateEmployee($employeeID, $employees)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateEmployeeWithHttpInfo($employeeID, $employees);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateEmployeeWithHttpInfo
     *
     * Allows you to update a specific employee used in Xero payrun
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Employees $employees (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Employees|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEmployeeWithHttpInfo($employeeID, $employees)
    {
        $request = $this->updateEmployeeRequest($employeeID, $employees);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Employees'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Employees';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateEmployee'
     *
     * @param  string $employeeID Unique identifier for a Employee (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Employees $employees (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateEmployeeRequest($employeeID, $employees)
    {
        // Verify the required parameter 'employeeID' is set

        if ($employeeID === null || (is_array($employeeID) && count($employeeID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'employeeID',
                'updateEmployee'
            ));
        }
        // Verify the required parameter 'employees' is set

        if ($employees === null || (is_array($employees) && count($employees) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'employees',
                'updateEmployee'
            ));
        }

        $resourcePath = '/Employees/{EmployeeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($employeeID !== null) {
            $resourcePath = str_replace(
                '{' . 'EmployeeID' . '}',
                ObjectSerializer::toPathValue($employeeID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($employees)) {
            $_tempBody = $employees;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateExpenseClaim
     *
     * Allows you to update specified expense claims
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\ExpenseClaims $expenseClaims expenseClaims (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ExpenseClaims|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateExpenseClaim($expenseClaimID, $expenseClaims)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateExpenseClaimWithHttpInfo($expenseClaimID, $expenseClaims);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateExpenseClaimWithHttpInfo
     *
     * Allows you to update specified expense claims
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\ExpenseClaims $expenseClaims (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ExpenseClaims|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateExpenseClaimWithHttpInfo($expenseClaimID, $expenseClaims)
    {
        $request = $this->updateExpenseClaimRequest($expenseClaimID, $expenseClaims);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ExpenseClaims'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ExpenseClaims';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateExpenseClaim'
     *
     * @param  string $expenseClaimID Unique identifier for a ExpenseClaim (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\ExpenseClaims $expenseClaims (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateExpenseClaimRequest($expenseClaimID, $expenseClaims)
    {
        // Verify the required parameter 'expenseClaimID' is set

        if ($expenseClaimID === null || (is_array($expenseClaimID) && count($expenseClaimID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'expenseClaimID',
                'updateExpenseClaim'
            ));
        }
        // Verify the required parameter 'expenseClaims' is set

        if ($expenseClaims === null || (is_array($expenseClaims) && count($expenseClaims) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'expenseClaims',
                'updateExpenseClaim'
            ));
        }

        $resourcePath = '/ExpenseClaims/{ExpenseClaimID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($expenseClaimID !== null) {
            $resourcePath = str_replace(
                '{' . 'ExpenseClaimID' . '}',
                ObjectSerializer::toPathValue($expenseClaimID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($expenseClaims)) {
            $_tempBody = $expenseClaims;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateInvoice
     *
     * Allows you to update a specified sales invoices or purchase bills
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Invoices $invoices invoices (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Invoices|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateInvoice($invoiceID, $invoices)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateInvoiceWithHttpInfo($invoiceID, $invoices);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateInvoiceWithHttpInfo
     *
     * Allows you to update a specified sales invoices or purchase bills
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Invoices $invoices (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Invoices|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateInvoiceWithHttpInfo($invoiceID, $invoices)
    {
        $request = $this->updateInvoiceRequest($invoiceID, $invoices);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Invoices'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Invoices';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateInvoice'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Invoices $invoices (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateInvoiceRequest($invoiceID, $invoices)
    {
        // Verify the required parameter 'invoiceID' is set

        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoiceID',
                'updateInvoice'
            ));
        }
        // Verify the required parameter 'invoices' is set

        if ($invoices === null || (is_array($invoices) && count($invoices) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoices',
                'updateInvoice'
            ));
        }

        $resourcePath = '/Invoices/{InvoiceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($invoices)) {
            $_tempBody = $invoices;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateInvoiceAttachmentByFileName
     *
     * Allows you to update Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateInvoiceAttachmentByFileName($invoiceID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateInvoiceAttachmentByFileNameWithHttpInfo($invoiceID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateInvoiceAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update Attachment on invoices or purchase bills by it's filename
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateInvoiceAttachmentByFileNameWithHttpInfo($invoiceID, $fileName, $body)
    {
        $request = $this->updateInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateInvoiceAttachmentByFileName'
     *
     * @param  string $invoiceID Unique identifier for an Invoice (required)
     * @param  string $fileName Name of the file you are attaching (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateInvoiceAttachmentByFileNameRequest($invoiceID, $fileName, $body)
    {
        // Verify the required parameter 'invoiceID' is set

        if ($invoiceID === null || (is_array($invoiceID) && count($invoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'invoiceID',
                'updateInvoiceAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'updateInvoiceAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'updateInvoiceAttachmentByFileName'
            ));
        }

        $resourcePath = '/Invoices/{InvoiceID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'InvoiceID' . '}',
                ObjectSerializer::toPathValue($invoiceID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateItem
     *
     * Allows you to udpate a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Items $items items (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Items|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateItem($itemID, $items)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateItemWithHttpInfo($itemID, $items);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateItemWithHttpInfo
     *
     * Allows you to udpate a specified item
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Items $items (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Items|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateItemWithHttpInfo($itemID, $items)
    {
        $request = $this->updateItemRequest($itemID, $items);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Items'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Items';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateItem'
     *
     * @param  string $itemID Unique identifier for an Item (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Items $items (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateItemRequest($itemID, $items)
    {
        // Verify the required parameter 'itemID' is set

        if ($itemID === null || (is_array($itemID) && count($itemID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'itemID',
                'updateItem'
            ));
        }
        // Verify the required parameter 'items' is set

        if ($items === null || (is_array($items) && count($items) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'items',
                'updateItem'
            ));
        }

        $resourcePath = '/Items/{ItemID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($itemID !== null) {
            $resourcePath = str_replace(
                '{' . 'ItemID' . '}',
                ObjectSerializer::toPathValue($itemID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($items)) {
            $_tempBody = $items;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateLinkedTransaction
     *
     * Allows you to update a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\LinkedTransactions $linkedTransactions linkedTransactions (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\LinkedTransactions|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateLinkedTransaction($linkedTransactionID, $linkedTransactions)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateLinkedTransactionWithHttpInfo($linkedTransactionID, $linkedTransactions);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateLinkedTransactionWithHttpInfo
     *
     * Allows you to update a specified linked transactions (billable expenses)
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\LinkedTransactions $linkedTransactions (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\LinkedTransactions|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateLinkedTransactionWithHttpInfo($linkedTransactionID, $linkedTransactions)
    {
        $request = $this->updateLinkedTransactionRequest($linkedTransactionID, $linkedTransactions);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\LinkedTransactions'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\LinkedTransactions';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateLinkedTransaction'
     *
     * @param  string $linkedTransactionID Unique identifier for a LinkedTransaction (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\LinkedTransactions $linkedTransactions (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateLinkedTransactionRequest($linkedTransactionID, $linkedTransactions)
    {
        // Verify the required parameter 'linkedTransactionID' is set

        if ($linkedTransactionID === null || (is_array($linkedTransactionID) && count($linkedTransactionID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'linkedTransactionID',
                'updateLinkedTransaction'
            ));
        }
        // Verify the required parameter 'linkedTransactions' is set

        if ($linkedTransactions === null || (is_array($linkedTransactions) && count($linkedTransactions) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'linkedTransactions',
                'updateLinkedTransaction'
            ));
        }

        $resourcePath = '/LinkedTransactions/{LinkedTransactionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($linkedTransactionID !== null) {
            $resourcePath = str_replace(
                '{' . 'LinkedTransactionID' . '}',
                ObjectSerializer::toPathValue($linkedTransactionID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($linkedTransactions)) {
            $_tempBody = $linkedTransactions;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateManualJournal
     *
     * Allows you to update a specified manual journal
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\ManualJournals $manualJournals manualJournals (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\ManualJournals|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateManualJournal($manualJournalID, $manualJournals)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateManualJournalWithHttpInfo($manualJournalID, $manualJournals);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateManualJournalWithHttpInfo
     *
     * Allows you to update a specified manual journal
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\ManualJournals $manualJournals (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\ManualJournals|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateManualJournalWithHttpInfo($manualJournalID, $manualJournals)
    {
        $request = $this->updateManualJournalRequest($manualJournalID, $manualJournals);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\ManualJournals'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\ManualJournals';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateManualJournal'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\ManualJournals $manualJournals (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateManualJournalRequest($manualJournalID, $manualJournals)
    {
        // Verify the required parameter 'manualJournalID' is set

        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'manualJournalID',
                'updateManualJournal'
            ));
        }
        // Verify the required parameter 'manualJournals' is set

        if ($manualJournals === null || (is_array($manualJournals) && count($manualJournals) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'manualJournals',
                'updateManualJournal'
            ));
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($manualJournals)) {
            $_tempBody = $manualJournals;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateManualJournalAttachmentByFileName
     *
     * Allows you to update a specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateManualJournalAttachmentByFileName($manualJournalID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateManualJournalAttachmentByFileNameWithHttpInfo($manualJournalID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateManualJournalAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update a specified Attachment on ManualJournal by file name
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateManualJournalAttachmentByFileNameWithHttpInfo($manualJournalID, $fileName, $body)
    {
        $request = $this->updateManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateManualJournalAttachmentByFileName'
     *
     * @param  string $manualJournalID Unique identifier for a ManualJournal (required)
     * @param  string $fileName The name of the file being attached to a ManualJournal (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateManualJournalAttachmentByFileNameRequest($manualJournalID, $fileName, $body)
    {
        // Verify the required parameter 'manualJournalID' is set

        if ($manualJournalID === null || (is_array($manualJournalID) && count($manualJournalID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'manualJournalID',
                'updateManualJournalAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'updateManualJournalAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'updateManualJournalAttachmentByFileName'
            ));
        }

        $resourcePath = '/ManualJournals/{ManualJournalID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($manualJournalID !== null) {
            $resourcePath = str_replace(
                '{' . 'ManualJournalID' . '}',
                ObjectSerializer::toPathValue($manualJournalID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updatePurchaseOrder
     *
     * Allows you to update a specified purchase order
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\PurchaseOrders $purchaseOrders purchaseOrders (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\PurchaseOrders|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updatePurchaseOrder($purchaseOrderID, $purchaseOrders)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updatePurchaseOrderWithHttpInfo($purchaseOrderID, $purchaseOrders);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updatePurchaseOrderWithHttpInfo
     *
     * Allows you to update a specified purchase order
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\PurchaseOrders $purchaseOrders (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\PurchaseOrders|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePurchaseOrderWithHttpInfo($purchaseOrderID, $purchaseOrders)
    {
        $request = $this->updatePurchaseOrderRequest($purchaseOrderID, $purchaseOrders);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\PurchaseOrders'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\PurchaseOrders';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updatePurchaseOrder'
     *
     * @param  string $purchaseOrderID Unique identifier for a PurchaseOrder (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\PurchaseOrders $purchaseOrders (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updatePurchaseOrderRequest($purchaseOrderID, $purchaseOrders)
    {
        // Verify the required parameter 'purchaseOrderID' is set

        if ($purchaseOrderID === null || (is_array($purchaseOrderID) && count($purchaseOrderID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'purchaseOrderID',
                'updatePurchaseOrder'
            ));
        }
        // Verify the required parameter 'purchaseOrders' is set

        if ($purchaseOrders === null || (is_array($purchaseOrders) && count($purchaseOrders) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'purchaseOrders',
                'updatePurchaseOrder'
            ));
        }

        $resourcePath = '/PurchaseOrders/{PurchaseOrderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($purchaseOrderID !== null) {
            $resourcePath = str_replace(
                '{' . 'PurchaseOrderID' . '}',
                ObjectSerializer::toPathValue($purchaseOrderID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($purchaseOrders)) {
            $_tempBody = $purchaseOrders;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateReceipt
     *
     * Allows you to retrieve a specified draft expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Receipts $receipts receipts (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Receipts|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateReceipt($receiptID, $receipts)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateReceiptWithHttpInfo($receiptID, $receipts);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateReceiptWithHttpInfo
     *
     * Allows you to retrieve a specified draft expense claim receipts
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Receipts $receipts (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Receipts|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateReceiptWithHttpInfo($receiptID, $receipts)
    {
        $request = $this->updateReceiptRequest($receiptID, $receipts);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Receipts'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Receipts';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateReceipt'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\Receipts $receipts (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateReceiptRequest($receiptID, $receipts)
    {
        // Verify the required parameter 'receiptID' is set

        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'receiptID',
                'updateReceipt'
            ));
        }
        // Verify the required parameter 'receipts' is set

        if ($receipts === null || (is_array($receipts) && count($receipts) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'receipts',
                'updateReceipt'
            ));
        }

        $resourcePath = '/Receipts/{ReceiptID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($receipts)) {
            $_tempBody = $receipts;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateReceiptAttachmentByFileName
     *
     * Allows you to update Attachment on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateReceiptAttachmentByFileName($receiptID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateReceiptAttachmentByFileNameWithHttpInfo($receiptID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateReceiptAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update Attachment on expense claim receipts by file name
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateReceiptAttachmentByFileNameWithHttpInfo($receiptID, $fileName, $body)
    {
        $request = $this->updateReceiptAttachmentByFileNameRequest($receiptID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateReceiptAttachmentByFileName'
     *
     * @param  string $receiptID Unique identifier for a Receipt (required)
     * @param  string $fileName The name of the file being attached to the Receipt (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateReceiptAttachmentByFileNameRequest($receiptID, $fileName, $body)
    {
        // Verify the required parameter 'receiptID' is set

        if ($receiptID === null || (is_array($receiptID) && count($receiptID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'receiptID',
                'updateReceiptAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'updateReceiptAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'updateReceiptAttachmentByFileName'
            ));
        }

        $resourcePath = '/Receipts/{ReceiptID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receiptID !== null) {
            $resourcePath = str_replace(
                '{' . 'ReceiptID' . '}',
                ObjectSerializer::toPathValue($receiptID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateRepeatingInvoiceAttachmentByFileName
     *
     * Allows you to update specified attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateRepeatingInvoiceAttachmentByFileName($repeatingInvoiceID, $fileName, $body)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateRepeatingInvoiceAttachmentByFileNameWithHttpInfo($repeatingInvoiceID, $fileName, $body);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateRepeatingInvoiceAttachmentByFileNameWithHttpInfo
     *
     * Allows you to update specified attachment on repeating invoices by file name
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\Attachments|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateRepeatingInvoiceAttachmentByFileNameWithHttpInfo($repeatingInvoiceID, $fileName, $body)
    {
        $request = $this->updateRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $body);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Attachments'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\Attachments';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateRepeatingInvoiceAttachmentByFileName'
     *
     * @param  string $repeatingInvoiceID Unique identifier for a Repeating Invoice (required)
     * @param  string $fileName The name of the file being attached to a Repeating Invoice (required)
     * @param  string $body Byte array of file in body of request (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateRepeatingInvoiceAttachmentByFileNameRequest($repeatingInvoiceID, $fileName, $body)
    {
        // Verify the required parameter 'repeatingInvoiceID' is set

        if ($repeatingInvoiceID === null || (is_array($repeatingInvoiceID) && count($repeatingInvoiceID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'repeatingInvoiceID',
                'updateRepeatingInvoiceAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'fileName' is set

        if ($fileName === null || (is_array($fileName) && count($fileName) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'fileName',
                'updateRepeatingInvoiceAttachmentByFileName'
            ));
        }
        // Verify the required parameter 'body' is set

        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'body',
                'updateRepeatingInvoiceAttachmentByFileName'
            ));
        }

        $resourcePath = '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($repeatingInvoiceID !== null) {
            $resourcePath = str_replace(
                '{' . 'RepeatingInvoiceID' . '}',
                ObjectSerializer::toPathValue($repeatingInvoiceID),
                $resourcePath
            );
        }
        // path params
        if ($fileName !== null) {
            $resourcePath = str_replace(
                '{' . 'FileName' . '}',
                ObjectSerializer::toPathValue($fileName),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/octet-stream']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateTaxRate
     *
     * Allows you to update Tax Rates
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\TaxRates $taxRates taxRates (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\TaxRates|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateTaxRate($taxRates)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateTaxRateWithHttpInfo($taxRates);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateTaxRateWithHttpInfo
     *
     * Allows you to update Tax Rates
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\TaxRates $taxRates (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\TaxRates|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTaxRateWithHttpInfo($taxRates)
    {
        $request = $this->updateTaxRateRequest($taxRates);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\TaxRates'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\TaxRates';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateTaxRate'
     *
     * @param  \Consilience\Xero\AccountingSdk\Model\TaxRates $taxRates (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateTaxRateRequest($taxRates)
    {
        // Verify the required parameter 'taxRates' is set

        if ($taxRates === null || (is_array($taxRates) && count($taxRates) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'taxRates',
                'updateTaxRate'
            ));
        }

        $resourcePath = '/TaxRates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($taxRates)) {
            $_tempBody = $taxRates;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }

    /**
     * Operation updateTrackingCategory
     *
     * Allows you to update tracking categories
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\TrackingCategory $trackingCategory trackingCategory (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @return \Consilience\Xero\AccountingSdk\Model\TrackingCategories|\Consilience\Xero\AccountingSdk\Model\Error
     */
    public function updateTrackingCategory($trackingCategoryID, $trackingCategory)
    {
        list($responseData, $requestMessage, $responseMessage) = $this->updateTrackingCategoryWithHttpInfo($trackingCategoryID, $trackingCategory);

        $statusCode = (int)$responseMessage->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $requestMessage->getUri()
                ),
                $statusCode,
                $requestMessage,
                $responseMessage
            );
        }

        return $responseData;
    }

    /**
     * Operation updateTrackingCategoryWithHttpInfo
     *
     * Allows you to update tracking categories
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\TrackingCategory $trackingCategory (required)
     *
     * @throws \Consilience\Xero\AccountingSdk\ApiException on non-2xx response
     * @throws InvalidArgumentException
     * @throws RequestExceptionInterface if the request is malformed
     * @throws NetworkExceptionInterface if the network is down
     * @return array of \Consilience\Xero\AccountingSdk\Model\TrackingCategories|\Consilience\Xero\AccountingSdk\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTrackingCategoryWithHttpInfo($trackingCategoryID, $trackingCategory)
    {
        $request = $this->updateTrackingCategoryRequest($trackingCategoryID, $trackingCategory);

        $response = $this->getSyncClient()->sendRequest($request);

        $statusCode = (int)$response->getStatusCode();


        $responseBody = $response->getBody();

        switch($statusCode) {
            case 200:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\TrackingCategories'),
                    $request,
                    $response
                ];
            case 400:
                return [
                    ObjectSerializer::deserialize($response, '\Consilience\Xero\AccountingSdk\Model\Error'),
                    $request,
                    $response
                ];
        }

        $returnType = '\Consilience\Xero\AccountingSdk\Model\TrackingCategories';

        return [
            ObjectSerializer::deserialize($response, $returnType),
            $request,
            $response
        ];
    }


    /**
     * Create request for operation 'updateTrackingCategory'
     *
     * @param  string $trackingCategoryID Unique identifier for a TrackingCategory (required)
     * @param  \Consilience\Xero\AccountingSdk\Model\TrackingCategory $trackingCategory (required)
     *
     * @throws InvalidArgumentException
     * @return RequestInterface
     */
    public function updateTrackingCategoryRequest($trackingCategoryID, $trackingCategory)
    {
        // Verify the required parameter 'trackingCategoryID' is set

        if ($trackingCategoryID === null || (is_array($trackingCategoryID) && count($trackingCategoryID) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'trackingCategoryID',
                'updateTrackingCategory'
            ));
        }
        // Verify the required parameter 'trackingCategory' is set

        if ($trackingCategory === null || (is_array($trackingCategory) && count($trackingCategory) === 0)) {
            throw new InvalidArgumentException(sprintf(
                'Missing the required parameter $%s when calling %s',
                'trackingCategory',
                'updateTrackingCategory'
            ));
        }

        $resourcePath = '/TrackingCategories/{TrackingCategoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($trackingCategoryID !== null) {
            $resourcePath = str_replace(
                '{' . 'TrackingCategoryID' . '}',
                ObjectSerializer::toPathValue($trackingCategoryID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($trackingCategory)) {
            $_tempBody = $trackingCategory;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // For model (json/xml)

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present.

            if ($headers['Content-Type'] === 'application/json') {
                $httpBodyText = $this->jsonEncode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBodyText = $_tempBody;
            }

            $httpBody = $this->createStream($httpBodyText);
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }

                // FIXME: how do we do multiparts with PSR-7?
                // MultipartStream() is a Guzzle tool.

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = $this->createStream($this->jsonEncode($formParams));

            } else {
                // for HTTP post (form)
                $httpBody = $this->createStream($this->buildQuery($formParams));
            }
        }





        return $this->buildHttpRequest(
            $headerParams,
            $headers,
            $queryParams,
            $httpBody,
            'POST'
        );





        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest('POST', $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }


    /**
     * Return a PSR-7 request.
     *
     * @return RequestInterface
     */
    protected function createRequest(string $method, $uri): RequestInterface
    {
        // Get the factory from Configuration.

        $requestFactory = $this->config->getRequestFactory();

        return $requestFactory->createRequest($method, $uri);
    }

    /**
     * Return a PSR-7 URI.
     *
     * @return UriInterface
     */
    protected function createUri(string $uri = ''): UriInterface
    {
        // Get the factory from Configuration.

        $uriFactory = $this->config->getUriFactory();

        return $uriFactory->createUri($uri);
    }

    /**
     * Get a synchronous client.
     */
    protected function getSyncClient(): ClientInterface
    {
        return $this->config->getSyncClient();
    }

    /**
     * Get an asynchronous client.
     */
    protected function getAsyncClient(): GuzzleClientInterface
    {
        return $this->config->getAsyncClient();
    }

    /**
     * Return a PSR-7 URI.
     *
     * @return UriInterface
     */
    protected function createStream(string $content = ''): StreamInterface
    {
        // Get the factory from Configuration.

        $streamFactory = $this->config->getStreamFactory();

        return $streamFactory->createStream($content);
    }

    /**
    * Wrapper for JSON encoding that throws when an error occurs.
    *
    * @param mixed $value   The value being encoded
    * @param int    $options JSON encode option bitmask
    * @param int    $depth   Set the maximum depth. Must be greater than zero.
    *
    * @return string
    * @throws \InvalidArgumentException if the JSON cannot be encoded.
    * @link http://www.php.net/manual/en/function.json-encode.php
    */
    function jsonEncode($value, $options = 0, $depth = 512)
    {
        $json = \json_encode($value, $options, $depth);
        if (JSON_ERROR_NONE !== json_last_error()) {
            throw new \InvalidArgumentException(
                'json_encode error: ' . json_last_error_msg()
            );
        }

        return $json;
    }

    /**
    * Safely opens a PHP stream resource using a filename.
    *
    * When fopen fails, PHP normally raises a warning. This function adds an
    * error handler that checks for errors and throws an exception instead.
    *
    * @param string $filename File to open
    * @param string $mode     Mode used to open the file
    *
    * @return resource
    * @throws \RuntimeException if the file cannot be opened
    */
    function tryFopen($filename, $mode)
    {
        $ex = null;
        set_error_handler(function () use ($filename, $mode, &$ex) {
            $ex = new \RuntimeException(sprintf(
                'Unable to open %s using mode %s: %s',
                $filename,
                $mode,
                func_get_args()[1]
            ));
        });

        $handle = fopen($filename, $mode);
        restore_error_handler();

        if ($ex) {
            /** @var $ex \RuntimeException */
            throw $ex;
        }

        return $handle;
    }

    /**
    * Build a query string from an array of key value pairs.
    *
    * This function can use the return value of parse_query() to build a query
    * string. This function does not modify the provided keys when an array is
    * encountered (like http_build_query would).
    *
    * @param array     $params   Query string parameters.
    * @param int|false $encoding Set to false to not encode, PHP_QUERY_RFC3986
    *                            to encode using RFC3986, or PHP_QUERY_RFC1738
    *                            to encode using RFC1738.
    * @return string
    */
    function buildQuery(array $params, $encoding = PHP_QUERY_RFC3986)
    {
        if (!$params) {
            return '';
        }
        if ($encoding === false) {
            $encoder = function ($str) { return $str; };
        } elseif ($encoding === PHP_QUERY_RFC3986) {
            $encoder = 'rawurlencode';
        } elseif ($encoding === PHP_QUERY_RFC1738) {
            $encoder = 'urlencode';
        } else {
            throw new \InvalidArgumentException('Invalid type');
        }
        $qs = '';
        foreach ($params as $k => $v) {
            $k = $encoder($k);
            if (!is_array($v)) {
                $qs .= $k;
                if ($v !== null) {
                    $qs .= '=' . $encoder($v);
                }
                $qs .= '&';
            } else {
                foreach ($v as $vv) {
                    $qs .= $k;
                    if ($vv !== null) {
                        $qs .= '=' . $encoder($vv);
                    }
                    $qs .= '&';
                }
            }
        }
        return $qs ? (string) substr($qs, 0, -1) : '';
    }

    function buildHttpRequest(
        array $headerParams,
        array $headers,
        array $queryParams,
        $httpBody,
        string $method
    ) {
        $defaultHeaders = [];

        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );


        $url = $this->createUri($this->config->getHost() . $resourcePath);

        if ($queryParams) {
            $url = $url->withQuery($this->buildQuery($queryParams));
        }

        $request = $this->createRequest($method, $url);

        if ($headers) {
            foreach ($headers as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
        }

        // Add the body if set.

        if ($httpBody) {
            $request = $request->withBody($httpBody);
        }

        return $request;
    }
}
